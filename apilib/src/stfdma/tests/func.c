/*****************************************************************************
File Name   : func.c

Description : STFDMA functional test source

Copyright (C) 2002 STMicroelectronics

History     :

Reference   :
*****************************************************************************/

/* Includes --------------------------------------------------------------- */

/*#define DEBUG               1*/
/*#define STFDMA_TEST_VERBOSE 1 */
#define STTBX_PRINT 1   /*Always required on */

#if defined (ST_OSLINUX)
#include <linux/stddef.h>
#include <linux/interrupt.h>
#include <linux/errno.h>
#include <linux/delay.h>
#include <linux/time.h>
#include <linux/dmapool.h>
#include <linux/dma-mapping.h>
#include <linux/kthread.h>
#include <asm/semaphore.h>
#else
#include <string.h>                     /* C libs */
#include "sttbx.h"
#include "stcommon.h"
#endif

#if !defined (ST_OSLINUX)
#include "stsys.h"
#endif

#include "stdevice.h"
#include "stddefs.h"

#include "stfdma.h"                     /* fdma api header file */

#include "func.h"
#include "fdmatst.h"

extern void stfdma_ReqSetRead(int Index);
extern void stfdma_ReqSetWrite(int Index);
extern void stfdma_ReqSetIncrement(int Index, int On);

extern partition_t* system_partition;

#if defined (ST_OSLINUX)
#if defined (CONFIG_STM_DMA)
extern int Lock_7100_fdma2[NUM_CHANNELS];
#endif
extern struct dma_pool* g_NodePool;
#endif

/* Private Constants ------------------------------------------------------ */
#define K       (1024)
#define M       (1024 * K)

#if defined (ST_7200)
#define STFDMA_PES STFDMA_2
#define FDMA_PES_BASE_ADDRESS (U32 *)FDMA_1_BASE_ADDRESS
#define FDMA_PES_INTERRUPT_NUMBER FDMA_1_INTERRUPT
#else
#define STFDMA_PES STFDMA_1
#define FDMA_PES_BASE_ADDRESS fdmatst_GetBaseAddress()
#define FDMA_PES_INTERRUPT_NUMBER FDMA_INTERRUPT_NUMBER
#endif

#if !defined(ST_5517)
#if defined (ST_5100) || defined (ST_5101) || defined (ST_5301)
#define INTERRUPT_MASK_REG 0x20305FDC
#elif defined (ST_5105) || defined (ST_5107)
#define INTERRUPT_MASK_REG 0x20D05FDC
#elif defined (ST_5188)
#define INTERRUPT_MASK_REG 0x20D0BFDC
#elif defined (ST_5162)
#define INTERRUPT_MASK_REG 0x20D0BFDC
#elif defined (ST_5525)
#define INTERRUPT_MASK_REG 0x1A00BFDC
#elif defined (ST_7710)
#define INTERRUPT_MASK_REG 0x38055FDC
#elif defined (ST_7100) || defined (ST_5528) || defined (ST_7109)
#define INTERRUPT_MASK_REG 0xB922BFDC
#elif defined (ST_7200)
#define INTERRUPT_MASK_REG 0xFD81BFDC
#else
#error INTERRUPT_MASK_REG undefined
#endif
#endif

/* The maximum length of the start code list */

#define SC_LIST_MAX         64
#define DELAY_MODIFIER      1 /* Should normally be 1 but may be increased for emulation */

/* Memory size for defines for F401.
 * Test performs two transfers:
 * 1) 720 * 288 * 16bit 1D transfer.
 * 2) 720 * 288 * 16bit 2D transfer with a 720 * 16bit gap between lines.
 *
 */

#define F401_USEFUL_LINE_LENGTH    (720 * 2)  /* 720 16bit words */
#if defined (ST_OSLINUX)
#define F401_USEFUL_NUMBER_LINES   (44)   /* 44 lines, can't do dma_allocate of such a large buffer */
#else
#define F401_USEFUL_NUMBER_LINES   (288)   /* 288 lines */
#endif

#define F401_NUMBER_USEFUL_BYTES  (F401_USEFUL_NUMBER_LINES * F401_USEFUL_LINE_LENGTH)

/* Simulate a field move by "skipping" next line in a 2D transfer */
#define F401_NUMBER_UNUSED_BYTES_PER_LINE    (F401_USEFUL_LINE_LENGTH)

#define F401_MEMSIZE_1D  (F401_USEFUL_LINE_LENGTH * F401_USEFUL_NUMBER_LINES)

/* 2D transfer requires "unused" space of 1 full line between usefull lines */
#define F401_MEMSIZE_2D ((F401_USEFUL_LINE_LENGTH * 2) * F401_USEFUL_NUMBER_LINES)

#define F401_UNUSED_TEST_PATTERN   (0xDEAD)


/* Number of times to poll TransferStatus.NodeAddress to assess if transfer is running */
#define TRANSFER_RUNNING_COUNT_MAX   (1000)

/* Small number of bytes for deliberately short, special case transfers */
#define SMALL_NUMBER_BYTES (4)

/* Aligned/unaligned transfer test control */
typedef enum TransferAlignment_e
{
    UNALIGNED_TRANSFER = 0,
    ALIGNED_TRANSFER,
    TEST_COMPLETE
} TransferAlignment_t;

/* Private Variables ------------------------------------------------------ */
typedef struct TransferTaskParam_s
{
    BOOL        Paced;
    BOOL        Blocking;
    BOOL        Circular;
    BOOL        LockChannel;
    U32         TestID;         /* ((TestCaseID << 8) | task number) */
} TransferTaskParams_t;

#if defined (ST_OS21)
#define TASK_STACK_SIZE  (16 * 1024)
#elif defined (ST_OS20)
#define TASK_STACK_SIZE  (16 * 1024)
#else
/* Linux part of STOS_TaskCreate() doesn't require this value */
#define TASK_STACK_SIZE  0
#endif

/* Local task details */

#if !defined (ST_5517)
static tdesc_t  *BlockingMultipleDreqTestTransferTaskDescriptor = NULL;
#endif
static tdesc_t  *TransferTask1Descriptor = NULL;
static tdesc_t  *TransferTask2Descriptor = NULL;
static tdesc_t  *TransferTask3Descriptor = NULL;
#if !defined (ST_5517) && !defined(ST_OSLINUX)
static tdesc_t  *CaseF110TaskDescriptor  = NULL;
#endif

#if !defined (ST_5517)
static U32      *BlockingMultipleDreqTestTransferTaskStack = NULL;
#endif
static U32      *TransferTask1Stack = NULL;
static U32      *TransferTask2Stack = NULL;
static U32      *TransferTask3Stack = NULL;
#if !defined (ST_5517) && !defined(ST_OSLINUX)
static U32      *CaseF110TaskStack  = NULL;
#endif

#if defined (ST_OSLINUX)
#if !defined (ST_5517)
static struct task_struct *pBlockingMultipleDreqTestTransferTask;
#endif
static struct task_struct *pTransferTask1;
static struct task_struct *pTransferTask2;
static struct task_struct *pTransferTask3;
#if !defined (ST_5517) && !defined(ST_OSLINUX)
static struct task_struct *pCaseF110Task;
#endif

#else
#if !defined (ST_5517)
static task_t *pBlockingMultipleDreqTestTransferTask;
#endif
static task_t *pTransferTask1;
static task_t *pTransferTask2;
static task_t *pTransferTask3;
#if !defined (ST_5517) && !defined(ST_OSLINUX)
static task_t *pCaseF110Task;
#endif
#endif

#if defined (ST_OSLINUX)
static int  TransferTask(void *TaskParams_p);
#else
static void TransferTask(void *TaskParams_p);
#endif

#if !defined (ST_5517) && !defined(ST_OSLINUX)
void CaseF110Task(void* params);
#endif

/* Utility variables */
static semaphore_t *pTestContinue;
static semaphore_t *pTaskContinue1;
static semaphore_t *pTaskContinue2;
static semaphore_t *pTaskContinue3;
static semaphore_t *pAbortSemap;
static semaphore_t *pPausedSemap;
static semaphore_t *pTransferCompleteSemap;
static semaphore_t *pListCompleteSemap;
static semaphore_t *pNodeCompleteSemap;

static STOS_Clock_t      WaitTime;

#define F102_TRANSFER_COUNT 6
#define F209_TRANSFER_COUNT 6
#define F211_TRANSFER_COUNT 2
#define F212_TRANSFER_COUNT 6

static STFDMA_TransferId_t     GeneralTransferId;
static STFDMA_TransferId_t     F209TransferIds[F209_TRANSFER_COUNT];
static STFDMA_TransferId_t     F102TransferIds[F102_TRANSFER_COUNT];
static STFDMA_TransferId_t     F211TransferIds[F211_TRANSFER_COUNT];
static STFDMA_TransferId_t     F212TransferIds[F212_TRANSFER_COUNT];
static STFDMA_TransferId_t     PES1TransferId  = 0;
static STFDMA_TransferId_t     PES2TransferId  = 0;
static STFDMA_TransferId_t     F221TransferId  = 0;
static STFDMA_TransferId_t     SPDIFTransferId = 0;
static STFDMA_TransferId_t     F319TransferId;

#if !defined (ST_5517)
static STFDMA_TransferId_t 	   NonblockingMultipleDreqTestTransferId1 = 0;
static STFDMA_TransferId_t 	   NonblockingMultipleDreqTestTransferId2 = 0;
static STFDMA_TransferId_t 	   BlockingMultipleDreqTestTransferId1 = 0;
static STFDMA_TransferId_t 	   BlockingMultipleDreqTestTransferId2 = 0;
#endif

static void *F211AppDataA_p = NULL;
static void *F211AppDataB_p = NULL;

/* Utility enu for test case identification in common functions */
typedef enum func_TestCase_e
{
    F201,
    F202,
    F203,
    F204,
    F205,
    F206,
    F207,
    F208,
    F209,
    F210
}func_TestCase_t;

typedef  STFDMA_SCEntry_t SCTable_t[SC_LIST_MAX];
static SCTable_t *SCList  = NULL;
static char *SCListMalloc = NULL;
#if defined (ST_OSLINUX)
static dma_addr_t SCListPhysicalAddrMalloc;
static dma_addr_t SCListPhysicalAddr;
#endif
static BOOL g_Test319     = FALSE;

#if !defined(ST_5517)  /* FDMA 2 ONLY */

#define ES_SC_ENTRIES        (0 +14 + 4)
#define PES_SC_ENTRIES       (3 +13 + 3)
#define ES_SC_ENTRIES_2      (0 +13 + 3)
#define PES_HEADER_SIZE      94
#define H264_ES_SC_ENTRIES   (19)

static U8 PESData[] =                                                                                /* PES                   ES            */
{
    0X00, 0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07, 0X08, 0X09, 0X0A, 0X0B, 0X00, 0X00, 0X01, 0X00,  /* Picture SC          : Picture SC    */
    0X00, 0X00, 0X01, 0XBC, 0X00, 0X00, 0X80, 0X80, 0X07, 0X21, 0X00, 0X01, 0X00, 0X01, 0X0E, 0X0F,  /* PTS == 0X000000000  : SC            */

    0X20, 0X21, 0X22, 0X23, 0X24, 0X00, 0X00, 0X01, 0X01, 0X29, 0X2A, 0X2B, 0X2C, 0X2D, 0X2E, 0X2F,  /* Slice SC            : Slice SC      */
    0X30, 0X31, 0X32, 0X33, 0X34, 0X35, 0X36, 0X37, 0X38, 0X39, 0X3A, 0X3B, 0X3C, 0X3D, 0X3E, 0X3F,

    0X40, 0X41, 0X42, 0X43, 0X44, 0X45, 0X46, 0X47, 0X48, 0X49, 0X4A, 0X4B, 0X4C, 0X00, 0X00, 0X01,
    0X00, 0X00, 0X01, 0XFF, 0X00, 0X00, 0X80, 0X80, 0X07, 0X2F, 0X88, 0X89, 0X88, 0X89, 0X0E, 0X0F,  /* PTS == 0X1E2224444  : SC            */

    0X00, 0X61, 0X62, 0X63, 0X64, 0X65, 0X66, 0X67, 0X68, 0X69, 0X6A, 0X6B, 0X6C, 0X6D, 0X6E, 0X6F,  /* Picture SC          : None          */
    0X70, 0X71, 0X72, 0X73, 0X74, 0X75, 0X76, 0X77, 0X78, 0X79, 0X7A, 0X7B, 0X7C, 0X7D, 0X7E, 0X7F,

    0X80, 0X81, 0X00, 0X00, 0X01, 0X58, 0X86, 0X87, 0X88, 0X00, 0X00, 0X01, 0XAF, 0X8D, 0X00, 0X00,  /* 2xSlice SC          : 2xSlice SC    */
    0X00, 0X00, 0X01, 0XBC, 0X00, 0X00, 0X80, 0X00, 0X07, 0X2F, 0X88, 0X89, 0X88, 0X89, 0X0E, 0X0F,  /* NO PTS              : SC            */

    0X01, 0X00, 0XA2, 0XA3, 0XA4, 0XA5, 0XA6, 0XA7, 0XA8, 0XA9, 0XAA, 0XAB, 0XAC, 0XAD, 0XAE, 0X0F,  /* Picture SC          : None          */
    0XB0, 0XB1, 0XB2, 0XB3, 0XB4, 0XB5, 0XB6, 0XB7, 0XB8, 0XB9, 0XBA, 0XBB, 0XBC, 0XBD, 0XBE, 0X0F,

    0XC0, 0XC1, 0XC2, 0XC3, 0XC4, 0XC5, 0XC6, 0XC7, 0XC8, 0XC9, 0XCA, 0XCB, 0XCC, 0XCD, 0XCE, 0X00,
    0X00, 0X00, 0X01, 0XFF, 0X00, 0X00, 0X80, 0X00, 0X07, 0X2F, 0X88, 0X89, 0X88, 0X89, 0X0E, 0X0F,  /* NO PTS              : SC            */

    0X00, 0X01, 0X00, 0XE3, 0XE4, 0XE5, 0XE6, 0XE7, 0XE8, 0XE9, 0XEA, 0XEB, 0XEC, 0XED, 0XEE, 0XEF,  /* Picture SC          : None          */
    0XF0, 0XF1, 0XF2, 0XF3, 0XF4, 0XF5, 0XF6, 0XF7, 0XF8, 0XF9, 0XFA, 0XFB, 0XFC, 0XFD, 0XFE, 0XFF,

    0X00, 0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07, 0X08, 0X09, 0X0A, 0X0B, 0X0C, 0X0D, 0X0E, 0X0F,
    0X00, 0X00, 0X01, 0XDD, 0X00, 0X00, 0X80, 0X00, 0X07, 0X2F, 0X88, 0X89, 0X88, 0X89, 0X0E, 0X0F,  /* NO PTS              : Slice SC      */

    0X00, 0X00, 0X01, 0X00, 0X24, 0X25, 0X26, 0X27, 0X28, 0X29, 0X2A, 0X2B, 0X2C, 0X2D, 0X2E, 0X2F,  /* Picture SC          : Picture SC    */
    0X30, 0X31, 0X32, 0X33, 0X34, 0X35, 0X36, 0X37, 0X38, 0X39, 0X3A, 0X3B, 0X3C, 0X3D, 0X3E, 0X3F,

    0X00, 0X00, 0X01, 0XB0, 0X44, 0X45, 0X46, 0X47, 0X48, 0X49, 0X4A, 0X4B, 0X4C, 0X4D, 0X4E, 0X4F,  /* SC                  : SC            */
    0X50, 0X51, 0X52, 0X53, 0X54, 0X55, 0X56, 0X57, 0X58, 0X59, 0X5A, 0X5B, 0X5C, 0X5D, 0X5E, 0X5F,

    0X00, 0X00, 0X01, 0XBB, 0X64, 0X65, 0X66, 0X67, 0X68, 0X69, 0X6A, 0X6B, 0X6C, 0X6D, 0X6E, 0X6F,  /* SC                  : SC            */
    0X70, 0X71, 0X72, 0X73, 0X74, 0X75, 0X76, 0X77, 0X78, 0X79, 0X7A, 0X7B, 0X7C, 0X7D, 0X7E, 0X7F,

    0X00, 0X00, 0X01, 0XB1, 0X00, 0X00, 0X01, 0XB2, 0X88, 0X00, 0X00, 0X01, 0XB3, 0X8D, 0X8E, 0X8F,  /* 3xSC                : 3xSC          */
    0X90, 0X91, 0X92, 0X93, 0X94, 0X95, 0X96, 0X97, 0X98, 0X99, 0X9A, 0X9B, 0X9C, 0X9D, 0X9E, 0X9F,

    0XA0, 0XA1, 0X00, 0X00, 0X01, 0XB4, 0XA6, 0X00, 0X00, 0X01, 0XB5, 0XAB, 0XAC, 0XAD, 0XAE, 0XAF,  /* 2xSC                : 2xSC          */
    0X00, 0X00, 0X01, 0X01, 0XB4, 0XB5, 0XB6, 0X00, 0X00, 0X01, 0X02, 0XBB, 0XBC, 0XBD, 0X00, 0X00,  /* 2xSlice SC          : 2xSlice SC    */

    0X01, 0X03, 0XC2, 0XC3, 0XC4, 0X00, 0X00, 0X01, 0X04, 0XC9, 0XCA, 0XCB, 0XCC, 0XCD, 0XCE, 0X00,  /* 2xSlice SC          : 2xSlice SC    */
    0X00, 0X00, 0X00, 0X01, 0XFF, 0X00, 0X00, 0X80, 0X80, 0X05, 0X2F, 0X88, 0X89, 0X88, 0X89, 0X01,  /* PTS == 0X1E2224444  : SC            */

    0X00, 0XE1, 0XE2, 0XE3, 0XE4, 0XE5, 0XE6, 0XE7, 0XE8, 0XE9, 0XEA, 0XEB, 0XEC, 0XED, 0XEE, 0XEF,  /* Picture SC          : None          */
    0XF0, 0XF1, 0XF2, 0XF3, 0XF4, 0XF5, 0XF6, 0XF7, 0XF8, 0XF9, 0XFA, 0XFB, 0XFC, 0XFD, 0XFE, 0XFF,
};

static U8 ESData[] =
{
    0X00, 0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07, 0X08, 0X09, 0X0A, 0X0B, 0X00, 0X00, 0X01, 0X00,  /* Picture SC */
    0X20, 0X21, 0X22, 0X23, 0X24, 0X00, 0X00, 0X01, 0X01, 0X29, 0X2A, 0X2B, 0X2C, 0X2D, 0X2E, 0X2F,  /* Slice SC */

    0X30, 0X31, 0X32, 0X33, 0X34, 0X35, 0X36, 0X37, 0X38, 0X39, 0X3A, 0X3B, 0X3C, 0X3D, 0X3E, 0X3F,
    0X40, 0X41, 0X42, 0X43, 0X44, 0X45, 0X46, 0X47, 0X48, 0X49, 0X4A, 0X4B, 0X4C, 0X00, 0X00, 0X01,

    0X00, 0X61, 0X62, 0X63, 0X64, 0X65, 0X66, 0X67, 0X68, 0X69, 0X6A, 0X6B, 0X6C, 0X6D, 0X6E, 0X6F,  /* Picture SC */
    0X70, 0X71, 0X72, 0X73, 0X74, 0X75, 0X76, 0X77, 0X78, 0X79, 0X7A, 0X7B, 0X7C, 0X7D, 0X7E, 0X7F,

    0X80, 0X81, 0X00, 0X00, 0X01, 0X58, 0X86, 0X87, 0X88, 0X00, 0X00, 0X01, 0XAF, 0X8D, 0X00, 0X00,  /* 2xSlice SC */
    0X01, 0X00, 0XA2, 0XA3, 0XA4, 0XA5, 0XA6, 0XA7, 0XA8, 0XA9, 0XAA, 0XAB, 0XAC, 0XAD, 0XAE, 0X0F,  /* Picture SC */

    0XB0, 0XB1, 0XB2, 0XB3, 0XB4, 0XB5, 0XB6, 0XB7, 0XB8, 0XB9, 0XBA, 0XBB, 0XBC, 0XBD, 0XBE, 0X0F,
    0XC0, 0XC1, 0XC2, 0XC3, 0XC4, 0XC5, 0XC6, 0XC7, 0XC8, 0XC9, 0XCA, 0XCB, 0XCC, 0XCD, 0XCE, 0X00,

    0X00, 0X01, 0X00, 0XE3, 0XE4, 0XE5, 0XE6, 0XE7, 0XE8, 0XE9, 0XEA, 0XEB, 0XEC, 0XED, 0XEE, 0XEF,  /* Picture SC */
    0XF0, 0XF1, 0XF2, 0XF3, 0XF4, 0XF5, 0XF6, 0XF7, 0XF8, 0XF9, 0XFA, 0XFB, 0XFC, 0XFD, 0XFE, 0XFF,

    0X00, 0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07, 0X08, 0X09, 0X0A, 0X0B, 0X0C, 0X0D, 0X0E, 0X0F,
    0X00, 0X00, 0X01, 0X00, 0X24, 0X25, 0X26, 0X27, 0X28, 0X29, 0X2A, 0X2B, 0X2C, 0X2D, 0X2E, 0X2F,  /* Picture SC */

    0X30, 0X31, 0X32, 0X33, 0X34, 0X35, 0X36, 0X37, 0X38, 0X39, 0X3A, 0X3B, 0X3C, 0X3D, 0X3E, 0X3F,
    0X00, 0X00, 0X01, 0XB0, 0X44, 0X45, 0X46, 0X47, 0X48, 0X49, 0X4A, 0X4B, 0X4C, 0X4D, 0X4E, 0X4F,  /* SC */

    0X50, 0X51, 0X52, 0X53, 0X54, 0X55, 0X56, 0X57, 0X58, 0X59, 0X5A, 0X5B, 0X5C, 0X5D, 0X5E, 0X5F,
    0X00, 0X00, 0X01, 0XBB, 0X64, 0X65, 0X66, 0X67, 0X68, 0X69, 0X6A, 0X6B, 0X6C, 0X6D, 0X6E, 0X6F,  /* SC */

    0X70, 0X71, 0X72, 0X73, 0X74, 0X75, 0X76, 0X77, 0X78, 0X79, 0X7A, 0X7B, 0X7C, 0X7D, 0X7E, 0X7F,
    0X00, 0X00, 0X01, 0XB1, 0X00, 0X00, 0X01, 0XB2, 0X88, 0X00, 0X00, 0X01, 0XB3, 0X8D, 0X8E, 0X8F,  /* 3xSC */

    0X90, 0X91, 0X92, 0X93, 0X94, 0X95, 0X96, 0X97, 0X98, 0X99, 0X9A, 0X9B, 0X9C, 0X9D, 0X9E, 0X9F,
    0XA0, 0XA1, 0X00, 0X00, 0X01, 0XB4, 0XA6, 0X00, 0X00, 0X01, 0XB5, 0XAB, 0XAC, 0XAD, 0XAE, 0XAF,  /* 2xSC */

    0X00, 0X00, 0X01, 0X01, 0XB4, 0XB5, 0XB6, 0X00, 0X00, 0X01, 0X02, 0XBB, 0XBC, 0XBD, 0X00, 0X00,  /* 2xSlice SC */
    0X01, 0X03, 0XC2, 0XC3, 0XC4, 0X00, 0X00, 0X01, 0X04, 0XC9, 0XCA, 0XCB, 0XCC, 0XCD, 0XCE, 0X00,  /* 2xSlice SC */

    0X00,                                                                                     0X01,  /* PTS == 0X1E2224444 */
    0X00, 0XE1, 0XE2, 0XE3, 0XE4, 0XE5, 0XE6, 0XE7, 0XE8, 0XE9, 0XEA, 0XEB, 0XEC, 0XED, 0XEE, 0XEF,  /* Picture SC */
    0XF0, 0XF1, 0XF2, 0XF3, 0XF4, 0XF5, 0XF6, 0XF7, 0XF8, 0XF9, 0XFA, 0XFB, 0XFC, 0XFD, 0XFE, 0XFF,

          0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07, 0X08, 0X09, 0X0A, 0X0B, 0X0C, 0X0D, 0X0E,
    0X10, 0X11, 0X12, 0X13, 0X14, 0X15, 0X16, 0X17, 0X18, 0X19, 0X1A, 0X1B, 0X1C, 0X1D, 0X1E, 0X1F,

    0X20, 0X21, 0X22, 0X23, 0X24, 0X25, 0X26, 0X27, 0X28, 0X29, 0X2A, 0X2B, 0X2C, 0X2D, 0X2E, 0X2F,
    0X30, 0X31, 0X32, 0X33, 0X34, 0X35, 0X36, 0X37, 0X38, 0X39, 0X3A, 0X3B, 0X3C, 0X3D, 0X3E, 0X3F,

    0X40, 0X41, 0X42, 0X43, 0X44, 0X45, 0X46, 0X47, 0X48, 0X49, 0X4A, 0X4B, 0X4C, 0X4D, 0X4E, 0X4F,
    0X50, 0X51, 0X52, 0X53, 0X54, 0X55, 0X56, 0X57, 0X58, 0X59, 0X5A, 0X5B, 0X5C, 0X5D, 0X5E, 0X5F,
};

#if defined (ST_7100)  || defined (ST_7109) || defined (ST_7200)
static U8 H264ESData[] =
{
    0X00, 0X00, 0X00, 0X01, 0X27, 0X4D, 0X00, 0X15, 0X8D, 0X8D, 0X28, 0X58, 0X98, 0X80, 0X00, 0X00,
    0X00, 0X01, 0X28, 0XEE, 0X08, 0X15, 0X0C, 0XC8, 0X00, 0X00, 0X00, 0X01, 0X25, 0XB8, 0X00, 0X02,

    0X00, 0X00, 0X2F, 0XB4, 0X40, 0XBA, 0X85, 0X8D, 0XC0, 0X3F, 0XD3, 0X7B, 0X0F, 0X13, 0XA5, 0X67,
    0XD6, 0X53, 0X8A, 0X59, 0XA1, 0X79, 0X23, 0XD0, 0XF4, 0X59, 0XF9, 0X87, 0X3A, 0X94, 0XEE, 0XDC,

    0X81, 0X5A, 0X8A, 0XFD, 0XD7, 0X69, 0XFD, 0X73, 0X67, 0X58, 0XCD, 0XCA, 0X4E, 0X86, 0X40, 0XC6,
    0X95, 0X8F, 0X59, 0X88, 0XC4, 0X93, 0XD5, 0XD1, 0XFD, 0XA5, 0X14, 0XFD, 0XAA, 0X68, 0X6D, 0X58,

    0XD2, 0XF4, 0X9B, 0XD6, 0XE2, 0X43, 0X83, 0X08, 0XB0, 0XF9, 0X00, 0X3B, 0XED, 0XF6, 0X5C, 0XBD,
    0XC6, 0X73, 0X5E, 0X4C, 0XE8, 0X44, 0X87, 0X13, 0XB5, 0XB0, 0X4E, 0X46, 0X53, 0XC8, 0X21, 0X1C,

    0X49, 0XB8, 0XEE, 0X83, 0XDA, 0XF1, 0XA2, 0X98, 0X40, 0XF6, 0X42, 0X9D, 0XFE, 0XD9, 0XD4, 0X94,
    0X1A, 0XF9, 0X69, 0X70, 0X49, 0X08, 0XD2, 0X3D, 0XC5, 0X86, 0X6F, 0XE1, 0X9D, 0X68, 0X25, 0X07,

    0XC1, 0XFD, 0XC4, 0XEE, 0X24, 0XE8, 0X24, 0X56, 0X23, 0XA0, 0XCA, 0XB4, 0X67, 0X86, 0X94, 0X86,
    0X2F, 0XC3, 0XF0, 0X26, 0XA3, 0X79, 0X3C, 0X98, 0X9C, 0XBF, 0X13, 0X4F, 0XBB, 0X88, 0X92, 0X0C,

    0XC2, 0X7E, 0XCA, 0X95, 0X43, 0XA2, 0X74, 0X32, 0XC2, 0X0A, 0XED, 0X4E, 0X0D, 0X0C, 0XBC, 0X20,
    0XF7, 0X4D, 0X85, 0X18, 0X3D, 0XDC, 0X7D, 0X50, 0X47, 0XC6, 0XEE, 0X86, 0X79, 0X1C, 0X97, 0X7D,

    0X89, 0X01, 0XED, 0X59, 0X08, 0XDC, 0XBC, 0X98, 0XD3, 0X0A, 0X60, 0X52, 0X9E, 0X85, 0X04, 0X7A,
    0XDC, 0XD9, 0X2A, 0X57, 0X21, 0X33, 0XB5, 0X44, 0XA9, 0X67, 0X31, 0X02, 0X5A, 0X0F, 0X09, 0XE7,

    0X69, 0X63, 0X15, 0X4A, 0XF1, 0X01, 0X11, 0XC1, 0X36, 0X29, 0XFA, 0X4A, 0XF0, 0X5C, 0X97, 0X8F,
    0X6B, 0XEF, 0X2B, 0X1A, 0XFE, 0X29, 0XD5, 0X5B, 0XD8, 0X0F, 0XF3, 0X5A, 0XD6, 0X21, 0XCA, 0X92,

    0X74, 0X4E, 0X97, 0XDA, 0XBB, 0X0D, 0XA3, 0X13, 0X1F, 0XB6, 0X91, 0X95, 0XB8, 0X26, 0XA7, 0X4B,
    0X19, 0X20, 0X30, 0XC2, 0X87, 0X1A, 0X11, 0X47, 0XB8, 0X51, 0X8E, 0X87, 0X66, 0X02, 0XA0, 0XF8,

    0XFC, 0X37, 0XEC, 0X14, 0XFF, 0XB3, 0X17, 0X42, 0XA8, 0XF4, 0XD0, 0X28, 0XDB, 0XCE, 0X71, 0X2E,
    0X21, 0X24, 0XBB, 0X62, 0X78, 0X93, 0X69, 0XA7, 0XF9, 0X91, 0X5B, 0X11, 0XB4, 0X9F, 0X2B, 0X63,

    0XFA, 0X4C, 0X15, 0X58, 0X72, 0X10, 0X1E, 0X43, 0X5E, 0XF2, 0X32, 0XB3, 0X95, 0XD6, 0X38, 0X8A,
    0X33, 0X1D, 0X98, 0X8C, 0XFA, 0X8F, 0XC2, 0X46, 0X0E, 0X36, 0X14, 0XE5, 0X8A, 0X1F, 0X9D, 0XD9,

    0XC5, 0XAF, 0X98, 0XCC, 0XA3, 0XE5, 0X40, 0XB8, 0XA8, 0X06, 0XC9, 0X80, 0XCE, 0X83, 0X51, 0X76,
    0X4A, 0X03, 0X52, 0X86, 0X31, 0XD6, 0XBB, 0XA6, 0XB1, 0XE8, 0X7F, 0X64, 0X35, 0X8B, 0XC4, 0X58,

    0X87, 0X1A, 0XD0, 0X43, 0XAC, 0XBF, 0XD8, 0XA5, 0XA7, 0XA0, 0X8B, 0X5A, 0XD3, 0X11, 0XA3, 0X67,
    0XEA, 0X9B, 0XC5, 0X63, 0X6A, 0X28, 0XAD, 0X85, 0X54, 0XD5, 0X4A, 0X30, 0X60, 0X99, 0XF5, 0X41,

    0X03, 0X83, 0X6F, 0X57, 0X83, 0X60, 0X35, 0X89, 0X24, 0X7E, 0X87, 0X0B, 0X3F, 0XE9, 0XBF, 0XA6,
    0X65, 0XDF, 0X44, 0X8B, 0XC0, 0X23, 0X03, 0X58, 0X63, 0X5C, 0X50, 0X51, 0XBE, 0X49, 0XEA, 0XB2,

    0X4C, 0X3A, 0X6D, 0X4D, 0XCF, 0X5A, 0X16, 0X2C, 0XEC, 0X5D, 0X32, 0X5C, 0X64, 0X19, 0XD9, 0X9A,
    0XC5, 0X1D, 0XDD, 0X30, 0X8E, 0X39, 0X73, 0X3E, 0X4D, 0X77, 0XFF, 0X7B, 0X2B, 0X7C, 0X08, 0X33,

    0XCC, 0XD0, 0X59, 0X87, 0XB5, 0XB6, 0X0A, 0X5A, 0XDC, 0XE8, 0X5C, 0X43, 0X1A, 0XD2, 0X54, 0X73,
    0XF8, 0XEF, 0X7C, 0XC2, 0X22, 0X0A, 0X6E, 0X12, 0XDC, 0X4E, 0XD6, 0XAF, 0X1F, 0X74, 0X11, 0X46,

    0X7E, 0X11, 0XA5, 0X77, 0XD1, 0X41, 0XFD, 0X45, 0X43, 0X9A, 0XCF, 0XF6, 0X0A, 0X87, 0XC9, 0XEB,
    0XEE, 0X00, 0X2E, 0X9E, 0X6F, 0XA9, 0X41, 0XD2, 0XFD, 0XE4, 0X0A, 0X07, 0XFC, 0X7E, 0XA1, 0X93,

    0X4F, 0XBA, 0X12, 0XB8, 0X52, 0X38, 0XE0, 0XF1, 0X73, 0XBC, 0X7F, 0X06, 0X71, 0X82, 0XAF, 0X62,
    0XAC, 0XF9, 0XAB, 0X66, 0X90, 0X3B, 0XDC, 0XDB, 0X2F, 0XF2, 0X47, 0X56, 0XF4, 0X59, 0X76, 0X71,

    0X49, 0X22, 0XCC, 0XC0, 0X16, 0XF2, 0X70, 0X20, 0X51, 0X4A, 0X17, 0X38, 0X27, 0XFE, 0X39, 0X36,
    0X72, 0X41, 0XBE, 0X78, 0X68, 0XE7, 0X8C, 0X55, 0X30, 0XC1, 0X69, 0X15, 0X32, 0X5A, 0XCE, 0XDE,

    0XAE, 0XD7, 0X46, 0X4A, 0XBB, 0X4B, 0X06, 0X8F, 0XA6, 0X76, 0X5F, 0X60, 0X22, 0XED, 0XE8, 0XFE,
    0XBB, 0X83, 0XC0, 0X94, 0XB6, 0X5F, 0XB1, 0XD0, 0X49, 0X3D, 0X4B, 0X60, 0XC1, 0X73, 0XCC, 0X2A,

    0X3B, 0X70, 0X68, 0XB2, 0X3A, 0X16, 0X80, 0X37, 0X6D, 0XF3, 0X62, 0XE9, 0XF4, 0XC1, 0XD1, 0X4E,
    0XC8, 0X58, 0XCF, 0XC7, 0X05, 0XEA, 0X7F, 0X7B, 0X04, 0X4A, 0XEB, 0XFE, 0XB0, 0XA6, 0X0A, 0X79,

    0XCB, 0X23, 0X07, 0X54, 0XE7, 0XF9, 0X78, 0X6C, 0XFF, 0XCF, 0X77, 0X70, 0X5B, 0X8C, 0X96, 0X28,
    0X9A, 0X03, 0XDA, 0XFF, 0XE5, 0X08, 0X57, 0XE8, 0X25, 0XDE, 0X0B, 0X6C, 0XC5, 0X88, 0X0A, 0X1F,

    0XC4, 0XB1, 0X80, 0XDF, 0X47, 0XDE, 0XDF, 0XEC, 0XCD, 0X82, 0X24, 0X19, 0X3E, 0XC4, 0X60, 0X27,
    0X23, 0XAD, 0XBB, 0X00, 0XD8, 0X4F, 0XD1, 0X6B, 0XD2, 0XAE, 0XB9, 0X2A, 0XAD, 0X27, 0X5F, 0X1E,

    0X36, 0X53, 0X48, 0X68, 0X5D, 0X22, 0XCA, 0XA7, 0XF0, 0X58, 0X17, 0X6B, 0XAA, 0X02, 0X1A, 0X72,
    0XE6, 0XF9, 0X8F, 0X67, 0X0B, 0X80, 0X70, 0XA0, 0X0F, 0X39, 0XE2, 0X99, 0X2F, 0X4C, 0XAC, 0X19,

    0XF4, 0XCA, 0X13, 0X34, 0X6A, 0XE7, 0X1D, 0X04, 0XF6, 0XC1, 0XBA, 0XAA, 0X75, 0X98, 0X7D, 0X95,
    0X79, 0XCA, 0XFB, 0XD1, 0X76, 0X5A, 0X5C, 0XAC, 0X34, 0XA3, 0XF0, 0X46, 0X5E, 0X38, 0XB4, 0X03,

    0X81, 0XC9, 0XDE, 0XF4, 0X6E, 0X1E, 0XAD, 0X05, 0X44, 0X38, 0X28, 0X54, 0X21, 0XB9, 0X30, 0XE7,
    0XFD, 0X9A, 0X10, 0XE8, 0XA9, 0XA2, 0XF7, 0XF9, 0X8A, 0X44, 0XF9, 0X15, 0XBC, 0X6A, 0XEC, 0XA2,

    0X6C, 0X5F, 0X1F, 0XC0, 0X81, 0X64, 0X45, 0X67, 0X88, 0XD1, 0X06, 0XA3, 0X77, 0X7A, 0XCC, 0XCB,
    0X7C, 0XE7, 0XA8, 0X08, 0XE6, 0X45, 0X78, 0X50, 0XA7, 0X02, 0XF7, 0X9F, 0X8B, 0X96, 0X64, 0X9C,

    0X34, 0X44, 0X9F, 0X82, 0X86, 0XFE, 0XE7, 0X66, 0X62, 0X4D, 0XCC, 0X11, 0XD6, 0XD1, 0X08, 0X9D,
    0X02, 0XE7, 0X59, 0X59, 0X65, 0XD5, 0XCA, 0XC2, 0X13, 0X52, 0X05, 0X3F, 0XDA, 0X5A, 0X9E, 0X7A,

    0XB2, 0XCD, 0XD8, 0X49, 0X90, 0XF2, 0XDA, 0X3C, 0X0B, 0XC7, 0X92, 0XFE, 0X57, 0XBA, 0X27, 0X41,
    0X47, 0XAB, 0XEB, 0X84, 0XD2, 0XC1, 0X4F, 0X72, 0XB1, 0X71, 0X48, 0XC3, 0X19, 0XC6, 0X6F, 0X68,

    0X2B, 0X7B, 0X1C, 0X5C, 0X23, 0X4A, 0XDB, 0X61, 0XAB, 0X2D, 0X3C, 0XDA, 0X57, 0XEE, 0X31, 0X4D,
    0XC3, 0X1F, 0X0B, 0X7E, 0XF7, 0XE0, 0X7E, 0X80, 0X7F, 0X5E, 0X78, 0XF8, 0XA6, 0X8A, 0XEA, 0XBD,

    0X1A, 0X29, 0X5D, 0XA4, 0XF6, 0XE2, 0X56, 0X63, 0XAF, 0XCC, 0X18, 0X30, 0X88, 0XE4, 0XED, 0XCC,
    0XDF, 0XA2, 0XB1, 0XF3, 0X59, 0X38, 0X8D, 0X91, 0X52, 0XAA, 0X67, 0XE3, 0X12, 0XD4, 0X50, 0X07,

    0X74, 0X04, 0X12, 0XB5, 0X16, 0XA1, 0X5D, 0XC5, 0XBB, 0X17, 0X89, 0X40, 0XDC, 0XFC, 0X04, 0X16,
    0XED, 0X43, 0XFE, 0X88, 0X7D, 0X16, 0X5E, 0X8B, 0X2F, 0XB5, 0X29, 0X1C, 0X4F, 0XA5, 0X23, 0XCB,

    0X6D, 0X63, 0X6A, 0X68, 0X41, 0X98, 0XAA, 0XBD, 0XFC, 0X4E, 0X5B, 0XD5, 0XC5, 0XE2, 0X94, 0XF5,
    0X02, 0X46, 0XDB, 0X7B, 0XE4, 0X5A, 0X81, 0X19, 0X75, 0X34, 0XDC, 0XD3, 0X3D, 0X98, 0XE8, 0X70,

    0XE3, 0XEC, 0X9C, 0XC1, 0XFB, 0X83, 0XC8, 0XC7, 0X39, 0XDF, 0XAB, 0XF4, 0X7B, 0X4F, 0X5A, 0XE8,
    0XA8, 0X4B, 0XCB, 0XD1, 0X2E, 0X80, 0X68, 0XCF, 0X5A, 0X03, 0X32, 0X8B, 0XEB, 0X8D, 0XE2, 0XAB,

    0X05, 0XC7, 0X57, 0XB0, 0X28, 0X01, 0XB2, 0X67, 0X55, 0X7B, 0X9D, 0XEF, 0X83, 0X46, 0X2E, 0X6E,
    0X0F, 0X95, 0XB6, 0X99, 0X2F, 0XF0, 0X2F, 0XFB, 0X61, 0X7B, 0X1A, 0X7A, 0X15, 0XA6, 0X0E, 0XE9,

    0X43, 0X6C, 0X01, 0XFF, 0X46, 0X51, 0XD2, 0X93, 0XD8, 0XD0, 0XAE, 0XE4, 0X12, 0X8A, 0X68, 0XDD,
    0XB2, 0XBA, 0X80, 0XCE, 0X92, 0XF8, 0X25, 0X2C, 0X0D, 0XFE, 0X77, 0XC6, 0X58, 0XAE, 0X47, 0XD6,

    0XDF, 0X3E, 0XE7, 0XFF, 0XDC, 0X74, 0X83, 0XFA, 0XA2, 0X6E, 0XD9, 0XF9, 0X48, 0X01, 0X01, 0XE8,
    0X58, 0X92, 0XEE, 0X9B, 0X8D, 0X9F, 0XF4, 0X83, 0X08, 0X4D, 0X0F, 0X59, 0XBE, 0XCE, 0X76, 0X22,

    0XD6, 0XBD, 0X76, 0XAB, 0X78, 0X9E, 0X29, 0X85, 0X7D, 0X98, 0X43, 0X3D, 0X65, 0X63, 0XD5, 0X32,
    0X23, 0X8A, 0X22, 0X48, 0X8A, 0X96, 0X01, 0X6F, 0X5C, 0XFE, 0X13, 0X27, 0X00, 0XBC, 0X0E, 0X45,

    0XB3, 0XFC, 0X0F, 0XA9, 0XED, 0X0D, 0X3C, 0X03, 0X3F, 0XC3, 0X98, 0XFB, 0X85, 0XBE, 0XA7, 0X59,
    0X5B, 0X39, 0X8B, 0X66, 0X73, 0XDC, 0X98, 0XFF, 0XAA, 0X2B, 0X87, 0XDC, 0X8B, 0XED, 0X2A, 0X9F,

    0X6B, 0XAF, 0XE8, 0XB2, 0X1C, 0X03, 0X35, 0X18, 0X89, 0XDF, 0XA6, 0XEA, 0XCC, 0XB9, 0X23, 0X88,
    0XD5, 0X91, 0X35, 0X5F, 0X08, 0X4D, 0X66, 0X4C, 0XEA, 0XF7, 0X79, 0XF1, 0X09, 0X64, 0XF5, 0X39,

    0XEA, 0X98, 0XC2, 0X5C, 0X0B, 0XC1, 0XD0, 0X78, 0X92, 0XE0, 0XD2, 0X9A, 0X7D, 0X8D, 0X44, 0XEA,
    0XF8, 0X73, 0X05, 0XB1, 0X94, 0X00, 0X12, 0X64, 0X41, 0X45, 0X7D, 0X38, 0X84, 0X17, 0XE1, 0X57,

    0X20, 0X95, 0XB0, 0X34, 0X8C, 0X2F, 0XD1, 0XB1, 0XC2, 0XD9, 0XC0, 0X90, 0XCB, 0XFF, 0X24, 0XBB,
    0X90, 0XD0, 0XD3, 0XF3, 0XF8, 0XF2, 0X3F, 0XB9, 0X54, 0X0C, 0X5F, 0X07, 0X09, 0XA8, 0X27, 0X54,

    0X8A, 0X95, 0X8B, 0X59, 0X44, 0X78, 0X44, 0X66, 0XAE, 0X9D, 0X0E, 0X0C, 0X6E, 0X39, 0X00, 0XD8,
    0X27, 0X18, 0X2C, 0XCB, 0XDC, 0XA4, 0X56, 0X04, 0X1A, 0X50, 0XFD, 0X03, 0X97, 0X63, 0XC2, 0X45,

    0XDA, 0XE0, 0X3E, 0X81, 0X7A, 0XF7, 0X10, 0XCC, 0XA7, 0XDD, 0XC1, 0X3C, 0X00, 0X00, 0X3A, 0X69,
    0X20, 0XBE, 0X63, 0X18, 0X5A, 0X73, 0X4E, 0X19, 0XCB, 0XBB, 0XB3, 0X45, 0X57, 0XA8, 0X2B, 0X5C,

    0XE2, 0XF9, 0XBA, 0XE3, 0XBE, 0XAC, 0X09, 0XE9, 0X26, 0X11, 0X17, 0X82, 0X38, 0X0C, 0XEF, 0X8D,
    0X03, 0X51, 0X4D, 0X72, 0XD5, 0X31, 0X3C, 0X7A, 0X70, 0X94, 0X79, 0X33, 0X9E, 0XBC, 0X7C, 0XBE,

    0X34, 0X0C, 0X70, 0XDD, 0XEA, 0XB1, 0XA7, 0XE3, 0XC2, 0X56, 0X40, 0X97, 0XA6, 0X3F, 0XC8, 0X58,
    0X4D, 0X5F, 0X65, 0XBD, 0X7E, 0X18, 0XEE, 0XFD, 0X95, 0X9B, 0X73, 0X9E, 0X70, 0X30, 0X87, 0X10,

    0X12, 0X24, 0XB8, 0X63, 0XB4, 0X30, 0X56, 0X6C, 0X16, 0XCA, 0XB8, 0XCB, 0XF3, 0X11, 0X38, 0XA9,
    0XE8, 0X29, 0X0A, 0XC1, 0XF0, 0X96, 0X18, 0XD5, 0X80, 0X94, 0X1B, 0XC2, 0X78, 0XF6, 0X19, 0X40,

    0XC4, 0XC0, 0X1D, 0X14, 0X51, 0XBF, 0X08, 0XD9, 0X60, 0X4B, 0XF0, 0X3C, 0X96, 0X7C, 0X28, 0XD7,
    0XCC, 0X7B, 0XC1, 0X6D, 0XB6, 0XCC, 0XCF, 0X9A, 0X95, 0X57, 0XC7, 0XB4, 0XC8, 0X41, 0X04, 0X67,

    0X84, 0X03, 0XEB, 0X95, 0X10, 0XE7, 0X26, 0XF2, 0X1F, 0X37, 0X30, 0XF7, 0XF2, 0X81, 0X35, 0XC1,
    0XA4, 0X80, 0X70, 0XBB, 0XBA, 0X02, 0X33, 0XE5, 0X8F, 0XEC, 0XB9, 0X83, 0X5F, 0XC7, 0X86, 0X8C,

    0X3A, 0X1F, 0X4B, 0X87, 0X11, 0XA9, 0XE0, 0XAB, 0XB8, 0X01, 0XFE, 0X74, 0X8E, 0X63, 0X44, 0X8B,
    0X17, 0X53, 0XAB, 0X80, 0XA2, 0X58, 0XBA, 0X4C, 0X84, 0X4A, 0X14, 0X93, 0X67, 0X5E, 0X6A, 0X24,

    0XAB, 0XD3, 0XDA, 0XDB, 0X58, 0XE6, 0XEB, 0X05, 0XC0, 0X07, 0XD4, 0XF3, 0XBB, 0X34, 0X59, 0X50,
    0X62, 0XB3, 0XBB, 0X99, 0X82, 0X3D, 0X58, 0XC6, 0XEA, 0XB3, 0X49, 0X48, 0XA7, 0X0A, 0X30, 0X9E,

    0X77, 0XF0, 0XE9, 0X51, 0X31, 0XFE, 0XA2, 0XCC, 0X4E, 0X81, 0X2A, 0X18, 0X29, 0XBA, 0XAD, 0X1C,
    0XD9, 0XEE, 0X26, 0X87, 0X40, 0X56, 0X35, 0XCF, 0XA1, 0X00, 0X82, 0XD0, 0XA7, 0X1F, 0XB5, 0X0A,

    0X28, 0X4E, 0XC6, 0X09, 0X82, 0X1A, 0X3C, 0X84, 0XD8, 0XA6, 0XF1, 0X88, 0X1B, 0X8D, 0X44, 0X9A,
    0X3C, 0XB3, 0XD6, 0X46, 0X7F, 0XF0, 0X4E, 0XA2, 0X1E, 0XC0, 0XB2, 0X9F, 0X6C, 0X2E, 0X3B, 0X4D,

    0X31, 0XDD, 0XF2, 0X77, 0XF0, 0X32, 0X12, 0XC0, 0X9B, 0X36, 0XBA, 0X4F, 0XEB, 0X15, 0X4D, 0X4B,
    0X7A, 0XB6, 0X74, 0XDE, 0X93, 0X59, 0XB3, 0X2A, 0X79, 0X25, 0X4E, 0X75, 0X3D, 0XCE, 0X9E, 0XE0,

    0XA3, 0X6B, 0X83, 0X7E, 0X39, 0X58, 0X4F, 0X22, 0X2A, 0X37, 0X2F, 0X9C, 0X7F, 0XDA, 0X7C, 0X95,
    0XAF, 0X7C, 0X3E, 0X0E, 0X89, 0X9C, 0X2C, 0XCC, 0X86, 0X86, 0XDD, 0X11, 0XA9, 0X89, 0X8E, 0XED,

    0XE5, 0X00, 0XCE, 0X14, 0XE7, 0X20, 0X64, 0X4C, 0X91, 0X3F, 0XA9, 0X63, 0XAC, 0X9D, 0X29, 0X5A,
    0X6C, 0XD5, 0X80, 0XD1, 0XD7, 0X4A, 0X23, 0XCD, 0X90, 0XC5, 0X9D, 0X57, 0X61, 0XDB, 0XF7, 0XA8,

    0XB5, 0X4B, 0X5C, 0XD7, 0X05, 0X80, 0X0B, 0XE8, 0X0C, 0X04, 0XF1, 0X5A, 0X56, 0XAC, 0XE7, 0X06,
    0XA7, 0X0F, 0XA5, 0X52, 0X09, 0XEC, 0XB4, 0X0E, 0X7D, 0X78, 0X0E, 0X3E, 0X38, 0X1E, 0X0B, 0X1D,

    0XBF, 0X81, 0X34, 0X01, 0X59, 0XD2, 0X0A, 0X54, 0X3A, 0X8D, 0X90, 0X8E, 0X0D, 0X24, 0X5A, 0X6B,
    0XFE, 0XBF, 0X37, 0X59, 0XF4, 0X28, 0X6D, 0X9B, 0X81, 0X22, 0X8F, 0XDA, 0XC8, 0X7C, 0XCE, 0X87,

    0X2F, 0XFA, 0X26, 0XDB, 0X24, 0X71, 0XFB, 0X45, 0X47, 0XE7, 0XC0, 0X5F, 0XB1, 0XEE, 0X8E, 0X55,
    0XC3, 0X64, 0XE7, 0X03, 0X7E, 0X6C, 0X5A, 0X81, 0X76, 0XFD, 0X44, 0X7C, 0XB5, 0XEA, 0X8B, 0X9B,

    0XB4, 0XA4, 0XF6, 0XC0, 0XF4, 0X41, 0X94, 0XE3, 0XA4, 0XAF, 0X73, 0XD0, 0XD3, 0X74, 0X4F, 0XFC,
    0XC5, 0X77, 0XB7, 0XF4, 0X26, 0X83, 0XCF, 0XD3, 0XA2, 0X97, 0X1F, 0XC6, 0X55, 0X95, 0XA9, 0X63,

    0X2D, 0XA2, 0X05, 0X38, 0X50, 0X97, 0X98, 0XA2, 0X79, 0XE2, 0X05, 0X2B, 0X7A, 0X7A, 0X7B, 0X63,
    0X59, 0XDE, 0X6C, 0X72, 0XB1, 0XD4, 0X20, 0X87, 0XB5, 0X8F, 0X74, 0X82, 0X8A, 0X86, 0XDF, 0XB2,

    0XCC, 0X56, 0XA2, 0X5C, 0X6E, 0XFF, 0X10, 0XA1, 0X1C, 0X1E, 0XB9, 0XD6, 0X26, 0XC4, 0X72, 0XE6,
    0X83, 0X74, 0X20, 0X75, 0X30, 0X4D, 0X0C, 0X5A, 0XB5, 0XE6, 0XE6, 0X4E, 0XBC, 0XE6, 0X7C, 0X29,

    0X1D, 0XD6, 0XB9, 0X61, 0X2B, 0XFE, 0X33, 0X05, 0X17, 0XB6, 0XC7, 0XF9, 0X15, 0X2B, 0X5A, 0XBA,
    0X1B, 0X9B, 0XA8, 0XE0, 0X16, 0XDB, 0XFA, 0X1E, 0X41, 0X1B, 0X54, 0X9D, 0XD7, 0XC8, 0X6D, 0X21,

    0X60, 0X48, 0XC2, 0X19, 0X88, 0XA5, 0XA8, 0X38, 0X69, 0X54, 0XB3, 0X09, 0XB5, 0X02, 0X86, 0X74,
    0X49, 0XFE, 0XDE, 0XE1, 0X6B, 0X16, 0X2D, 0XC7, 0X47, 0XFB, 0XF4, 0X8D, 0X6D, 0X25, 0X4B, 0X81,

    0X22, 0X22, 0X2C, 0X10, 0X08, 0X93, 0X6D, 0X48, 0X33, 0X06, 0XA7, 0X7B, 0XA1, 0X8E, 0X3F, 0XA0,
    0X72, 0X45, 0X40, 0X24, 0X73, 0XCA, 0XBC, 0X6D, 0XDC, 0X25, 0XCD, 0XF8, 0XFC, 0X9E, 0X00, 0XD5,

    0X31, 0XDE, 0X22, 0XBE, 0XFB, 0XD6, 0X4E, 0X4A, 0X44, 0X22, 0XFF, 0X2E, 0XDC, 0XE2, 0X29, 0X69,
    0XBF, 0XAB, 0XB0, 0X05, 0XA0, 0X94, 0X73, 0XC6, 0X8B, 0XC6, 0X5E, 0XAE, 0XB3, 0X97, 0XF5, 0XFF,

    0X9D, 0X1F, 0X05, 0X98, 0X85, 0X9B, 0X6D, 0X7E, 0X02, 0X35, 0X90, 0X67, 0XEE, 0X85, 0X8E, 0X67,
    0XB4, 0X1C, 0X47, 0X96, 0X59, 0X80, 0X4A, 0X4A, 0X16, 0XE1, 0X28, 0X17, 0X51, 0X2F, 0X4D, 0X7F,

    0X4F, 0XE7, 0X94, 0XC2, 0XA0, 0XB5, 0X5D, 0X70, 0X04, 0X8E, 0X14, 0X26, 0XE7, 0X45, 0X7C, 0X1F,
    0X9F, 0XC9, 0XB2, 0X2F, 0XA5, 0X55, 0XF5, 0X3B, 0X38, 0XF1, 0XBE, 0XF3, 0X91, 0XC1, 0X86, 0X41,

    0X91, 0X18, 0X03, 0X8C, 0X6A, 0X04, 0XE4, 0XA7, 0X53, 0X1A, 0X7E, 0X0A, 0X4D, 0X0B, 0XAE, 0X39,
    0X3B, 0X0E, 0X04, 0XDE, 0X6B, 0X5A, 0X05, 0X78, 0X8F, 0XAF, 0XDC, 0X33, 0X1C, 0X14, 0X4A, 0X67,

    0XA5, 0X89, 0XCE, 0X71, 0X3C, 0X24, 0X3C, 0X19, 0X48, 0XF9, 0X04, 0X68, 0X64, 0XEF, 0XAA, 0X3E,
    0XD6, 0X27, 0X8E, 0XF7, 0XFD, 0XFD, 0XB9, 0X5A, 0X48, 0X94, 0X7A, 0X85, 0X4C, 0X6E, 0X04, 0XFC,

    0X85, 0XBA, 0XDB, 0XB2, 0X21, 0XDB, 0XFC, 0X15, 0XDE, 0XE1, 0XAD, 0X76, 0X72, 0XC4, 0XB1, 0X3B,
    0XE8, 0X59, 0XB3, 0XCE, 0X32, 0XD9, 0X31, 0X17, 0XB7, 0XBB, 0X16, 0X47, 0XBB, 0XEE, 0X39, 0X9C,

    0X76, 0X28, 0XBC, 0XD5, 0X86, 0XF9, 0X13, 0X2C, 0X7A, 0X7C, 0XD7, 0XDA, 0X2D, 0X71, 0XBD, 0X19,
    0XDE, 0XA5, 0X3E, 0X8F, 0X25, 0X8F, 0XB2, 0X58, 0X40, 0X3E, 0XD3, 0X37, 0X7A, 0XCF, 0X8F, 0XC1,

    0X4E, 0X95, 0XFF, 0X55, 0X0A, 0XBF, 0X62, 0XAA, 0XD4, 0XB5, 0X3F, 0X45, 0XC1, 0X9D, 0X43, 0XE9,
    0X52, 0XF2, 0X98, 0X85, 0XC9, 0X25, 0XD3, 0XE7, 0X95, 0X3E, 0X3E, 0X6D, 0XCC, 0X78, 0X80, 0X71,

    0XDA, 0X30, 0X68, 0XC0, 0XB7, 0X92, 0X66, 0X33, 0X0C, 0XC3, 0XEA, 0X67, 0X6A, 0X38, 0X68, 0X6E,
    0X18, 0XFE, 0XB7, 0X63, 0XE6, 0X47, 0XDB, 0X18, 0XB2, 0X53, 0XB7, 0XA4, 0X1E, 0X37, 0XE8, 0XE5,

    0XD8, 0XD4, 0X47, 0X62, 0X1F, 0X2B, 0X47, 0XFB, 0X40, 0X69, 0XEB, 0X12, 0X83, 0X0A, 0XB3, 0XAC,
    0X81, 0X26, 0X88, 0X15, 0X58, 0X19, 0XBB, 0X90, 0X3A, 0X36, 0X34, 0X7D, 0X49, 0XF3, 0XFE, 0XE1,

    0XDA, 0XDF, 0X99, 0X2B, 0X7A, 0X88, 0X60, 0X4C, 0XB9, 0XDE, 0X22, 0X5D, 0X43, 0X19, 0X4C, 0X8C,
    0X42, 0X88, 0X00, 0X5B, 0XD1, 0XD2, 0X7A, 0X95, 0XEC, 0XE7, 0XF3, 0XF7, 0XAC, 0X38, 0X13, 0X97,

    0X6C, 0X03, 0XC7, 0X79, 0X7B, 0X5A, 0X7C, 0X04, 0X08, 0XBF, 0X7B, 0XDD, 0X88, 0X79, 0X6A, 0X49,
    0X29, 0XA0, 0X4B, 0X0D, 0XED, 0X9A, 0X81, 0X57, 0X5C, 0XE2, 0X0B, 0XF5, 0XA9, 0XB8, 0X6D, 0XCA,

    0X2F, 0X3E, 0XAB, 0XDC, 0XD3, 0X24, 0XE8, 0X17, 0XF3, 0X12, 0XD8, 0X04, 0XBC, 0X07, 0X5D, 0XD9,
    0X50, 0XD0, 0XA7, 0X94, 0XF1, 0X11, 0X8B, 0XA2, 0XC3, 0X29, 0X33, 0X82, 0XBE, 0XFF, 0X0A, 0X30,

    0X7E, 0XD3, 0X8B, 0X86, 0X55, 0X1A, 0X06, 0XA7, 0X2E, 0X7A, 0X5C, 0X7C, 0XB7, 0XEC, 0X94, 0X3E,
    0XEF, 0XAE, 0X7C, 0XA6, 0X7D, 0XC3, 0X75, 0X89, 0XE8, 0X60, 0X13, 0X87, 0X0D, 0X14, 0XAB, 0X15,

    0XBC, 0X4E, 0XAE, 0X9A, 0X26, 0XF1, 0X3F, 0X38, 0X3E, 0XCD, 0XA3, 0X5C, 0X9C, 0XE5, 0X9A, 0X04,
    0X37, 0X5E, 0X9F, 0XEE, 0X9E, 0X85, 0XDC, 0X67, 0X45, 0X0E, 0XDF, 0XD9, 0XC8, 0X8E, 0XD5, 0X28,

    0X7B, 0XBD, 0XEF, 0XF1, 0XC3, 0XD2, 0X59, 0X79, 0X97, 0X29, 0XD7, 0X37, 0X58, 0XD2, 0X68, 0XAA,
    0X0B, 0X95, 0XE3, 0X0F, 0X0E, 0X39, 0XB7, 0X03, 0X63, 0X40, 0X73, 0X13, 0XF3, 0XCF, 0X9D, 0X81,

    0X02, 0XA5, 0X40, 0X78, 0XC9, 0X05, 0X10, 0XDE, 0X3A, 0XA8, 0X1E, 0XAC, 0XB8, 0X36, 0XD1, 0X36,
    0X1B, 0XD1, 0XC7, 0XB8, 0X84, 0XF7, 0XBA, 0XFE, 0X92, 0XFB, 0X91, 0XF7, 0XDC, 0XCA, 0XAF, 0XCC,

    0XCB, 0X36, 0X4E, 0X95, 0XBE, 0X12, 0XB3, 0XE9, 0X82, 0XB3, 0XA3, 0X21, 0X15, 0X6F, 0XF6, 0X92,
    0XB2, 0X59, 0X27, 0XF1, 0XB4, 0X6F, 0X3C, 0XF4, 0X0C, 0X3F, 0X0F, 0X7F, 0X11, 0XFF, 0X74, 0X2A,

    0X35, 0X0F, 0X59, 0XB1, 0XD6, 0X44, 0X76, 0XF4, 0X34, 0X6E, 0X7A, 0X73, 0XBC, 0X60, 0XF6, 0X44,
    0XEC, 0X1D, 0X14, 0X0F, 0X59, 0XF4, 0X93, 0XA2, 0X6B, 0XF1, 0X28, 0XC1, 0XF7, 0XA5, 0X8C, 0XBE,

    0X50, 0XB9, 0X4E, 0XFD, 0XD3, 0X94, 0X59, 0X43, 0X6A, 0X8B, 0XA1, 0X79, 0X87, 0X2D, 0X0A, 0XE0,
    0X0B, 0X53, 0X6D, 0X75, 0X85, 0X6A, 0XCD, 0X61, 0XA3, 0X15, 0X76, 0XA5, 0X51, 0XC0, 0X54, 0XE2,

    0X6A, 0X98, 0X73, 0XD5, 0XBF, 0X7D, 0XB7, 0XFF, 0X21, 0XA3, 0XD8, 0X9A, 0XF3, 0XD1, 0X32, 0XC7,
    0X65, 0XFB, 0XEB, 0XA7, 0XBD, 0X94, 0XE8, 0X45, 0X58, 0XE6, 0XCF, 0XBF, 0X55, 0X6E, 0X5B, 0X6A,

    0X1A, 0X6B, 0X05, 0X91, 0X02, 0X11, 0X91, 0XCD, 0X67, 0XEF, 0XB2, 0X8C, 0X13, 0X78, 0XF7, 0X69,
    0XE0, 0XAD, 0X4C, 0X3D, 0XEF, 0XDF, 0X1D, 0XB1, 0X2F, 0X04, 0XF6, 0XE0, 0X80, 0X61, 0XE0, 0X53,

    0X81, 0X4A, 0X9E, 0X8A, 0XA8, 0XAB, 0XB5, 0X2C, 0X9D, 0X64, 0XC4, 0X69, 0XD2, 0X13, 0XEE, 0X57,
    0X8C, 0X3D, 0X2D, 0XE5, 0XDA, 0XBB, 0X68, 0XD5, 0XC1, 0X69, 0X26, 0XDC, 0X12, 0XBB, 0X03, 0XBF,

    0X57, 0X98, 0X29, 0X20, 0X49, 0X9F, 0X5F, 0XB6, 0XAE, 0X7D, 0X38, 0XD7, 0X77, 0X1D, 0X96, 0XCE,
    0XEB, 0X31, 0X2C, 0X8E, 0X84, 0X64, 0X1E, 0X33, 0X64, 0XBC, 0XDA, 0X53, 0XE8, 0X9F, 0X2F, 0X86,

    0XF1, 0X27, 0X8F, 0X21, 0X0E, 0X34, 0X91, 0XF6, 0X52, 0X79, 0X28, 0XE3, 0X75, 0X6E, 0X91, 0X95,
    0X15, 0X59, 0X11, 0XC0, 0XBE, 0XE2, 0XD7, 0XAC, 0X36, 0X6A, 0XF9, 0XDE, 0X9A, 0X17, 0X8F, 0XA8,

    0XDE, 0X51, 0X2B, 0X9E, 0XE9, 0X01, 0X73, 0X3A, 0X0E, 0X76, 0XC6, 0X79, 0XCC, 0X6C, 0X13, 0X7F,
    0X1C, 0XE4, 0X80, 0X6D, 0X2F, 0X2C, 0X7E, 0X37, 0XAF, 0X57, 0X7D, 0XBF, 0XD8, 0XCD, 0X0C, 0XF5,

    0XC4, 0X8C, 0X78, 0XFD, 0XC3, 0X21, 0X8D, 0XCD, 0X57, 0X5F, 0XB8, 0XC9, 0XCF, 0X80, 0X4B, 0XE9,
    0X83, 0XF4, 0XC5, 0X40, 0X66, 0X52, 0X89, 0X3C, 0XB6, 0XFF, 0X7D, 0X0D, 0XD5, 0X83, 0X5A, 0X91,

    0X49, 0X26, 0X0F, 0XD0, 0XC5, 0XFC, 0XF3, 0X06, 0XE2, 0X4B, 0XF4, 0X4E, 0XC8, 0X68, 0X8B, 0XB5,
    0X47, 0XB2, 0X2F, 0XE9, 0XE9, 0X5A, 0XA3, 0X98, 0X48, 0X6E, 0XF8, 0XC2, 0XCA, 0X0F, 0X91, 0XD8,

    0X15, 0XDF, 0XF1, 0X6F, 0XD0, 0XDC, 0XCA, 0X06, 0XD9, 0X2B, 0X16, 0XB8, 0X95, 0X68, 0XF1, 0X5F,
    0X83, 0XDC, 0X62, 0X5C, 0X14, 0XB5, 0X3C, 0XAA, 0X08, 0XE5, 0X50, 0X3A, 0X9E, 0X99, 0X01, 0X8B,

    0X36, 0XE3, 0X0C, 0XB3, 0X9E, 0XD0, 0X52, 0X95, 0XF5, 0X9D, 0XB5, 0X29, 0XB0, 0XDF, 0X50, 0X3A,
    0X56, 0XBF, 0X2D, 0XB5, 0X4C, 0XB0, 0X74, 0X7D, 0XFA, 0XB3, 0X88, 0X73, 0X2E, 0X21, 0XF6, 0X4F,

    0XE8, 0XB3, 0XBE, 0X5E, 0X54, 0X83, 0X20, 0X68, 0X07, 0X2A, 0X03, 0X30, 0X50, 0X29, 0X84, 0X23,
    0X12, 0XFF, 0X35, 0X55, 0XFD, 0X1F, 0X19, 0X3C, 0X88, 0XCF, 0X35, 0XCB, 0X0B, 0X01, 0X8C, 0XCD,

    0X2B, 0XCF, 0X38, 0X9A, 0XC0, 0X46, 0X11, 0XBF, 0XC4, 0X17, 0X2F, 0X17, 0XEE, 0XDE, 0X25, 0XBC,
    0X32, 0X0D, 0X13, 0X0C, 0X7E, 0X3B, 0X24, 0X5D, 0X11, 0X80, 0XB5, 0X70, 0X65, 0XB3, 0X0F, 0X7D,

    0X82, 0X7B, 0X11, 0X4B, 0X3A, 0XF9, 0X8B, 0X07, 0XA6, 0X5D, 0X6A, 0X3A, 0XF3, 0X30, 0X1B, 0X4C,
    0X39, 0XC5, 0X00, 0X22, 0XF4, 0X94, 0XCB, 0X1A, 0X1E, 0X0F, 0X3D, 0X25, 0X2B, 0X41, 0XBB, 0X98,

    0X8E, 0X64, 0X58, 0X52, 0X32, 0X81, 0XC7, 0XDC, 0X37, 0X2D, 0X73, 0X4D, 0XFB, 0XEE, 0X91, 0X97,
    0X3A, 0XB7, 0XA8, 0X6B, 0X34, 0XBB, 0X87, 0XA2, 0X51, 0X94, 0X90, 0X5F, 0XB2, 0X90, 0X3B, 0XF8,

    0X2E, 0X3E, 0X86, 0X3F, 0X4F, 0X80, 0X58, 0XBC, 0XFB, 0X24, 0XCF, 0X4E, 0X6A, 0X4C, 0XD4, 0X25,
    0X52, 0X4B, 0X07, 0X42, 0XC4, 0X56, 0X91, 0X6F, 0X3C, 0XD0, 0X5A, 0XA1, 0X55, 0X7B, 0XC1, 0XED,

    0X74, 0XE1, 0X9E, 0XE5, 0X3C, 0XCA, 0X7B, 0X49, 0XF2, 0X72, 0XAF, 0X1B, 0XA7, 0X3A, 0X73, 0XEB,
    0XB0, 0XD2, 0XF0, 0X35, 0X2A, 0XE4, 0X55, 0XF2, 0X77, 0X50, 0XFE, 0XD7, 0XB6, 0XC7, 0X3F, 0XED,

    0XF7, 0X28, 0X60, 0X0D, 0X76, 0X92, 0XA3, 0X4B, 0X81, 0X57, 0XF0, 0XB5, 0XBC, 0X46, 0XB1, 0X26,
    0X41, 0XEE, 0X21, 0X40, 0X03, 0XC0, 0X7B, 0XC8, 0XF5, 0X01, 0XEC, 0X7B, 0X73, 0XB0, 0XB5, 0XCD,

    0X10, 0X2F, 0X19, 0X81, 0X71, 0X83, 0XBD, 0X2C, 0X5E, 0X01, 0XD3, 0XA1, 0X97, 0XCA, 0XC1, 0XD6,
    0X2F, 0X7C, 0X53, 0XF7, 0X86, 0XF7, 0XC0, 0X99, 0X66, 0X50, 0XDB, 0X3B, 0X20, 0XC9, 0X29, 0X10,

    0X6C, 0X30, 0X13, 0X72, 0X1D, 0X91, 0X4A, 0XAF, 0X65, 0XBB, 0XC5, 0X43, 0X08, 0X5E, 0XE5, 0XA5,
    0X30, 0X63, 0XEC, 0X3C, 0X4D, 0XAE, 0XBE, 0X3C, 0X2B, 0X72, 0XD6, 0X13, 0X5E, 0XB3, 0XDC, 0X6B,

    0XC2, 0X92, 0X6F, 0XE1, 0XD8, 0XAE, 0X7E, 0XA8, 0X6E, 0X5C, 0X0F, 0XEA, 0XFA, 0X41, 0X03, 0X5F,
    0XAA, 0X63, 0X2C, 0X1C, 0X7B, 0XFB, 0XD5, 0X90, 0X86, 0X3A, 0X47, 0X4E, 0XEE, 0XCF, 0XFA, 0XF5,

    0XAF, 0X36, 0X86, 0X10, 0X1A, 0X26, 0X1A, 0X36, 0X9C, 0X94, 0X9C, 0XF7, 0XBB, 0XFD, 0XE1, 0XC3,
    0X62, 0X91, 0X8D, 0X56, 0XFA, 0X9E, 0X51, 0X4C, 0X20, 0X59, 0X26, 0X41, 0X28, 0X04, 0XBF, 0X3B,

    0X65, 0X50, 0X59, 0X99, 0X88, 0X01, 0X74, 0XE6, 0X5B, 0XDB, 0X47, 0XB6, 0XC4, 0X1F, 0X7A, 0X0E,
    0XDC, 0XB0, 0XB5, 0X2F, 0XB2, 0XA1, 0X13, 0X25, 0XC0, 0XFA, 0X31, 0X71, 0X7A, 0XC5, 0X05, 0X47,

    0X8A, 0X44, 0X5E, 0XE6, 0XF1, 0XFC, 0X6F, 0X9E, 0X04, 0XE7, 0X3F, 0X0D, 0X15, 0XEC, 0XD3, 0XEE,
    0X06, 0XC1, 0X36, 0X6A, 0X92, 0X6A, 0X58, 0X43, 0X84, 0X91, 0X00, 0X71, 0X0E, 0X28, 0X30, 0X16,

    0XE1, 0X86, 0X5E, 0X95, 0X4B, 0X7C, 0X3E, 0XFD, 0X8E, 0XF9, 0X10, 0X59, 0XF5, 0X75, 0XA6, 0X6F,
    0X66, 0X75, 0X12, 0X0E, 0XAE, 0X20, 0XBE, 0XD4, 0X9A, 0XF2, 0X68, 0XDD, 0XEB, 0X6E, 0X0B, 0X45,

    0XFB, 0XDF, 0XDB, 0X7B, 0X46, 0X96, 0X4F, 0X6C, 0X06, 0X7F, 0X88, 0X4C, 0X71, 0XF8, 0X25, 0X19,
    0X8D, 0XAC, 0X03, 0XF5, 0X03, 0X35, 0X7B, 0X86, 0XC2, 0X3F, 0X28, 0X48, 0X2A, 0X15, 0X3A, 0X19,

    0X5E, 0X09, 0X18, 0X82, 0X18, 0XB6, 0X1D, 0XB3, 0X2B, 0XC6, 0X6B, 0XBE, 0X34, 0XCB, 0X98, 0XE1,
    0X2F, 0XE4, 0X73, 0X8F, 0X9F, 0X6D, 0X27, 0X49, 0XCB, 0XD7, 0XAB, 0XA7, 0X5A, 0XE3, 0XAC, 0X9D,

    0XCA, 0X1B, 0XEC, 0X3B, 0XB6, 0X31, 0X5B, 0XD2, 0X5A, 0X8E, 0X43, 0XA6, 0X74, 0X5D, 0X6E, 0XF4,
    0XC0, 0XD0, 0XBE, 0X53, 0X6D, 0X56, 0XA3, 0X6F, 0X0C, 0XA6, 0X61, 0XEB, 0X74, 0X14, 0X44, 0XB0,

    0X34, 0XE0, 0XF6, 0X83, 0X22, 0XB9, 0X93, 0XCF, 0XD8, 0X3A, 0XE1, 0X56, 0X2C, 0X72, 0X67, 0XCB,
    0X70, 0XB3, 0X0B, 0X01, 0X6A, 0X13, 0XAB, 0X62, 0X00, 0XB5, 0X78, 0XC8, 0X0A, 0XE4, 0XB5, 0X29,

    0XE9, 0X6A, 0X98, 0X49, 0XAD, 0XB7, 0X0D, 0XD4, 0XE4, 0X5C, 0X4E, 0X50, 0X5C, 0X40, 0XC1, 0X5B,
    0X19, 0X2D, 0XBF, 0XFB, 0X16, 0XF8, 0X26, 0XDC, 0X76, 0X2E, 0X6D, 0X6B, 0X5A, 0XFC, 0XDF, 0XDC,

    0X21, 0XC6, 0X1F, 0X4A, 0X20, 0XFA, 0X98, 0X52, 0X21, 0XC5, 0X80, 0X39, 0X73, 0X39, 0XC8, 0XF2,
    0XC1, 0XCA, 0XFF, 0XC0, 0X6B, 0XB9, 0X17, 0XCB, 0X27, 0XB9, 0X6C, 0X43, 0X67, 0XD1, 0X38, 0X05,

    0X1B, 0X07, 0XB7, 0X29, 0X3E, 0X24, 0X38, 0X6C, 0X86, 0XAA, 0X17, 0X89, 0XA1, 0XC2, 0X9A, 0XD9,
    0X7B, 0X9C, 0X9B, 0X9E, 0XE6, 0XE5, 0XE7, 0X85, 0X00, 0XFA, 0XE3, 0X3D, 0X0B, 0X35, 0XCD, 0XF2,

    0XAC, 0XCB, 0X07, 0XF4, 0X6A, 0X41, 0XAD, 0X04, 0X77, 0X4F, 0X03, 0XBE, 0X28, 0XC1, 0X4A, 0XEB,
    0X35, 0XD2, 0X6B, 0X43, 0XF9, 0XF7, 0X18, 0XD1, 0X20, 0XBD, 0XB4, 0XE5, 0X8A, 0XB1, 0X3B, 0X54,

    0X07, 0X61, 0X89, 0X38, 0XE5, 0XD0, 0XA3, 0XAC, 0X75, 0X4A, 0XDE, 0X19, 0X84, 0X24, 0X17, 0XC4,
    0X6D, 0XDD, 0XB7, 0X3D, 0XB7, 0XA1, 0X30, 0XC4, 0X98, 0XEB, 0X4E, 0XBA, 0X5E, 0XF7, 0X42, 0XE6,

    0X45, 0XB3, 0XF9, 0XD7, 0X22, 0X62, 0X39, 0X95, 0XFA, 0XD6, 0XEF, 0XB0, 0XD5, 0X80, 0XCC, 0X23,
    0XEE, 0X84, 0X10, 0X82, 0XF1, 0X1B, 0XBA, 0XB1, 0XFD, 0X48, 0XB0, 0X07, 0XB9, 0X04, 0X7D, 0XD5,

    0X20, 0XAD, 0XEA, 0X24, 0XE3, 0X88, 0X39, 0X84, 0XD6, 0X56, 0X82, 0XFE, 0XC6, 0X7A, 0X71, 0X68,
    0X29, 0X6C, 0X42, 0XF9, 0X0A, 0X5A, 0XAD, 0XDC, 0XE7, 0XDC, 0XDA, 0XE3, 0XA1, 0X4F, 0X76, 0XE2,

    0X73, 0XBC, 0X4F, 0XFD, 0XDB, 0X3C, 0X1A, 0XB3, 0X3F, 0XEF, 0XD3, 0X62, 0XD8, 0X61, 0XC9, 0X8B,
    0X00, 0X54, 0X09, 0X17, 0XE8, 0XF0, 0X3C, 0X46, 0XA7, 0XAF, 0X05, 0X2A, 0X23, 0XE9, 0X5B, 0X67,

    0X6E, 0X4B, 0XA3, 0XAE, 0X05, 0XEF, 0X27, 0X5C, 0XB1, 0X06, 0X5A, 0X52, 0XE5, 0XB7, 0X45, 0XD1,
    0XAE, 0X09, 0X9A, 0X80, 0XB4, 0XAD, 0X9F, 0XA7, 0X66, 0XC3, 0X2F, 0X94, 0XD3, 0X17, 0X62, 0XB0,

    0X16, 0X49, 0X29, 0X9B, 0XCE, 0XEB, 0X0C, 0XC5, 0X2F, 0X57, 0XB3, 0X92, 0X4C, 0X23, 0XF1, 0XAB,
    0XCC, 0X95, 0X8A, 0XE2, 0X9E, 0X55, 0XB0, 0X4B, 0X8F, 0X57, 0X1C, 0X54, 0X53, 0X56, 0XC2, 0X85,

    0X79, 0X01, 0X8A, 0X72, 0XB7, 0XEC, 0X74, 0XE9, 0XFD, 0X05, 0X0F, 0XD9, 0X1C, 0XCD, 0X5E, 0X8E,
    0XF9, 0X1A, 0X5A, 0X70, 0XA7, 0XEC, 0XA6, 0X23, 0X7C, 0XD0, 0X1D, 0XEC, 0X0C, 0X72, 0XC4, 0X93,

    0XB6, 0X6E, 0X32, 0XE2, 0XB7, 0X27, 0XC4, 0X7E, 0X82, 0X81, 0XED, 0X8C, 0XAB, 0XEF, 0X0E, 0XE6,
    0X0F, 0XA8, 0X7A, 0XB3, 0X1E, 0XD8, 0X05, 0X50, 0X12, 0XEA, 0XC0, 0X0F, 0XEE, 0X9A, 0X5D, 0X8F,

    0X5A, 0X9C, 0XDF, 0X3C, 0XFC, 0X35, 0X5B, 0X5F, 0X03, 0XC9, 0X09, 0X7E, 0XA1, 0XDE, 0X08, 0X06,
    0XE0, 0XF1, 0X0F, 0XFF, 0X55, 0XEC, 0X67, 0X92, 0X20, 0X39, 0X86, 0XDF, 0XFE, 0X01, 0XE5, 0XB9,

    0XEF, 0X23, 0X2B, 0X17, 0X8C, 0X0D, 0X7C, 0XEA, 0X80, 0X9B, 0X02, 0XFB, 0XBE, 0XD1, 0X54, 0X86,
    0XCB, 0X6C, 0XDC, 0X84, 0XC9, 0X5B, 0XBC, 0X1D, 0X8B, 0X17, 0X0F, 0XB8, 0X99, 0XA6, 0XC4, 0X14,

    0X23, 0X0E, 0XBE, 0XC6, 0X79, 0X16, 0X0F, 0X2B, 0XD8, 0X3D, 0XBF, 0X32, 0XE5, 0X9A, 0X14, 0X29,
    0XA5, 0XD0, 0X04, 0X64, 0X5E, 0X9E, 0X5E, 0X41, 0XC4, 0X66, 0XFF, 0X92, 0X49, 0XF5, 0X51, 0X2E,

    0X45, 0XCF, 0X08, 0X51, 0X62, 0X78, 0X1F, 0X76, 0XF8, 0X9E, 0X02, 0XE3, 0X48, 0X04, 0X0D, 0XFB,
    0X1E, 0X12, 0XEA, 0X79, 0X8E, 0X8B, 0X60, 0XD8, 0XF4, 0X2A, 0X95, 0X05, 0X43, 0X17, 0X0B, 0X97,

    0XE7, 0X2A, 0XAA, 0X9C, 0XFE, 0XF5, 0X0E, 0X24, 0X2E, 0X9D, 0X22, 0X05, 0X7E, 0X16, 0XF9, 0X82,
    0X9A, 0X0C, 0X65, 0X47, 0X87, 0X4A, 0X68, 0X10, 0X96, 0XC3, 0XC2, 0X69, 0XE3, 0X43, 0X00, 0X00,

    0X00, 0X01, 0X28, 0XEE, 0X08, 0X15, 0X0B, 0XC8, 0X00, 0X00, 0X00, 0X01, 0X21, 0XE0, 0X00, 0X20,
    0X00, 0X59, 0XBF, 0XE8, 0X94, 0XB9, 0X19, 0XCB, 0X64, 0X0F, 0X3B, 0XBE, 0XDB, 0X8B, 0XB6, 0X47,

    0XCA, 0X23, 0XDD, 0X9C, 0X63, 0X6F, 0X40, 0X55, 0XE6, 0X3F, 0X39, 0XDB, 0XC0, 0X0D, 0X33, 0X72,
    0X3F, 0X65, 0XE9, 0X0A, 0XAB, 0X62, 0XC7, 0X30, 0X84, 0X36, 0X75, 0XA3, 0X5D, 0X32, 0XD7, 0XDB,

    0X31, 0X96, 0X1B, 0XEB, 0X20, 0X98, 0X71, 0X28, 0X3F, 0X61, 0XC6, 0X32, 0X0F, 0X9B, 0X2A, 0X78,
    0XD0, 0X77, 0X41, 0X79, 0X56, 0X10, 0XB7, 0X3D, 0XF7, 0X3F, 0X56, 0X00, 0X80, 0X9A, 0X68, 0XBA,

    0X39, 0X11, 0X7A, 0X16, 0XE0, 0X2B, 0XA4, 0XFB, 0X07, 0X9A, 0XF7, 0XCC, 0X64, 0X6D, 0XDC, 0X86,
    0XFE, 0X51, 0X8B, 0X84, 0X6A, 0X93, 0X91, 0X90, 0XC1, 0XFF, 0XD0, 0XBB, 0X88, 0XC0, 0X29, 0X94,

    0X81, 0X95, 0X91, 0XAE, 0X3F, 0X00, 0X1E, 0X49, 0XF8, 0X22, 0X7B, 0XDE, 0XC6, 0X41, 0X4D, 0XA2,
    0X57, 0XBC, 0XC0, 0X68, 0X63, 0X0B, 0XFD, 0XB9, 0X8D, 0X21, 0X65, 0X2D, 0X6B, 0XB2, 0X46, 0X8A,

    0X46, 0X98, 0X41, 0XE0, 0XEB, 0X0E, 0XCA, 0X6E, 0XE7, 0X0B, 0X89, 0XE7, 0XC0, 0X7D, 0X0F, 0XBC,
    0X5A, 0XBE, 0X33, 0XDF, 0XC6, 0XD2, 0X0F, 0X21, 0XA7, 0XCE, 0X74, 0XEA, 0X61, 0XCE, 0X38, 0X94,

    0X50, 0X17, 0XFB, 0XB9, 0XD9, 0XD0, 0X00, 0XD1, 0X0C, 0XF9, 0X04, 0X72, 0XFB, 0X0D, 0X14, 0XD6,
    0XA7, 0XD1, 0X0A, 0XF4, 0XD8, 0X51, 0X4B, 0X92, 0X30, 0X9F, 0X6B, 0X3F, 0X87, 0X1A, 0XE3, 0X4A,

    0X24, 0XD7, 0XAE, 0XEF, 0X3C, 0X5B, 0XE9, 0X8E, 0XF8, 0XCA, 0X49, 0X2F, 0X76, 0X31, 0XAD, 0X6B,
    0XCE, 0XD6, 0XCE, 0X26, 0X91, 0XD7, 0X8E, 0X1D, 0X55, 0XBD, 0XA2, 0XAE, 0XFF, 0X31, 0X13, 0XBA,

    0X8A, 0XF1, 0X4B, 0X20, 0XD2, 0X03, 0XE3, 0X1D, 0X80, 0X37, 0X88, 0X54, 0X8B, 0X74, 0XD0, 0X02,
    0X96, 0X9D, 0X75, 0X99, 0X8A, 0XEF, 0X18, 0X13, 0X77, 0X1E, 0X81, 0X8D, 0XE4, 0X90, 0X12, 0X39,

    0X18, 0XB0, 0XBF, 0X76, 0XDE, 0X21, 0XB9, 0X19, 0XFB, 0X79, 0X92, 0X0A, 0XBA, 0X44, 0XBD, 0X36,
    0X3C, 0XAE, 0X80, 0X78, 0X21, 0XB9, 0X25, 0X7B, 0X21, 0XC2, 0XF1, 0X45, 0XD0, 0X02, 0X41, 0XB0,

    0XE2, 0XF6, 0X35, 0X4E, 0XE0, 0XB1, 0X70, 0XAE, 0XD9, 0XC0, 0XB1, 0XDD, 0X26, 0XB9, 0X85, 0X6C,
    0X5F, 0XFE, 0XA9, 0X57, 0XC6, 0X99, 0X0E, 0X41, 0X74, 0X15, 0X99, 0XC6, 0X05, 0X89, 0XEB, 0X22,

    0X6E, 0X15, 0X10, 0XE8, 0XD6, 0X80, 0XFF, 0X69, 0X55, 0XF1, 0XE3, 0X50, 0X1B, 0XCE, 0X8A, 0XF2,
    0X03, 0XE2, 0XDA, 0XF6, 0XB6, 0X48, 0XEB, 0X91, 0XBD, 0X1A, 0X5D, 0X4C, 0X9D, 0X92, 0X5B, 0XA2,

    0XBA, 0X64, 0XED, 0X91, 0XC7, 0X4F, 0XC7, 0X1B, 0X24, 0XE0, 0X88, 0X95, 0X1A, 0XCA, 0X7D, 0XB6,
    0XC2, 0XAF, 0XA9, 0X51, 0X7D, 0X06, 0X75, 0XEA, 0X49, 0X0F, 0XB8, 0XFC, 0X25, 0XC3, 0XD2, 0XE3,

    0X18, 0X2D, 0XAE, 0XFC, 0X29, 0X30, 0XF4, 0X13, 0X2F, 0XF1, 0X35, 0XE8, 0X4A, 0X83, 0XE7, 0X69,
    0X64, 0XD4, 0XB3, 0XED, 0X4B, 0X72, 0XB6, 0XD2, 0XAD, 0X4F, 0X3A, 0X4F, 0XD2, 0X74, 0XC1, 0X74,

    0XA2, 0X2A, 0X17, 0X5A, 0X3D, 0X39, 0XAD, 0X07, 0X07, 0X65, 0X14, 0X65, 0X8E, 0X62, 0X8A, 0X6C,
    0X82, 0XD7, 0XA1, 0X1B, 0XCB, 0XB5, 0X0D, 0X69, 0XBA, 0X26, 0X31, 0XD0, 0XFF, 0XFF, 0XFF, 0XEC,

    0XAC, 0XED, 0XC7, 0X31, 0X10, 0X4A, 0X67, 0X93, 0X7D, 0XFB, 0X28, 0XA5, 0XE6, 0X33, 0XAA, 0XCB,
    0XF1, 0X4A, 0X63, 0XC4, 0X97, 0XAC, 0X10, 0XBC, 0X46, 0XB5, 0XAF, 0X05, 0X44, 0X30, 0X9B, 0X24,

    0X5B, 0X4C, 0XA4, 0X74, 0X2C, 0XC8, 0XBA, 0X1D, 0X81, 0XC2, 0X32, 0X64, 0XCF, 0XDE, 0X8E, 0X6F,
    0X37, 0X86, 0XAA, 0X91, 0X6B, 0XAE, 0XA4, 0X2C, 0XFA, 0X07, 0XAA, 0X37, 0X00, 0XE2, 0XCF, 0XEA,

    0X42, 0X94, 0XF0, 0X0A, 0XD6, 0X36, 0X01, 0X79, 0X02, 0XAD, 0X48, 0X7B, 0X05, 0XDE, 0XC0, 0X4B,
    0X39, 0X10, 0X55, 0X20, 0X09, 0X49, 0XFF, 0XBB, 0X08, 0X87, 0XE0, 0X67, 0X9D, 0X38, 0X24, 0XC6,

    0X5C, 0XF7, 0X97, 0X6B, 0X80, 0X2D, 0X08, 0X41, 0X5B, 0X27, 0X41, 0X3A, 0X6C, 0X2A, 0XDE, 0X97,
    0X0A, 0X9D, 0X24, 0X0F, 0XE5, 0XB6, 0XC9, 0X13, 0X29, 0X20, 0XA0, 0XD8, 0X26, 0XBE, 0X65, 0X75,

    0X66, 0XBB, 0XE7, 0X8A, 0X0D, 0X4B, 0X88, 0X4F, 0XAB, 0XDB, 0X21, 0X02, 0X4B, 0X98, 0X32, 0X8B,
    0XF1, 0X79, 0XE6, 0X11, 0XD9, 0XBF, 0X0A, 0X74, 0XC1, 0X97, 0X11, 0X27, 0X35, 0XE5, 0XFD, 0X44,

    0XC4, 0XD7, 0XC1, 0XDF, 0X75, 0X73, 0X70, 0XF7, 0XCF, 0XD0, 0XB2, 0X56, 0X76, 0X4D, 0XDE, 0X7C,
    0X19, 0XFD, 0X97, 0XEE, 0XE2, 0X5A, 0X9A, 0X4B, 0X22, 0XD2, 0XCD, 0X21, 0X47, 0X69, 0XF4, 0X68,

    0X53, 0X1F, 0X4A, 0X0A, 0X91, 0X91, 0XDF, 0XC3, 0XB6, 0X9E, 0XDF, 0XEE, 0XFA, 0X86, 0X4D, 0X40,
    0XCB, 0X47, 0X66, 0X80, 0X17, 0XD0, 0XED, 0X74, 0X50, 0XFB, 0XA4, 0X1C, 0X79, 0X65, 0X69, 0XB2,

    0X53, 0X1D, 0X1E, 0X28, 0X5F, 0XB5, 0XF5, 0X6B, 0X9C, 0XCA, 0X4A, 0X7F, 0X72, 0X5D, 0X70, 0XF6,
    0X59, 0XE4, 0X67, 0XB5, 0XE7, 0X2A, 0XF3, 0XBC, 0X97, 0X92, 0XCE, 0X1B, 0X35, 0XE6, 0X50, 0XBD,

    0X17, 0X3A, 0X3E, 0X5C, 0X96, 0XF3, 0XC0, 0X00, 0X00, 0X00, 0X01, 0X28, 0XEA, 0X82, 0X05, 0X42,
    0XB2, 0X00, 0X00, 0X00, 0X01, 0X21, 0XE0, 0X00, 0X40, 0X00, 0X94, 0X6F, 0XE6, 0X15, 0X55, 0X6D,

    0X60, 0XAE, 0X6E, 0XD7, 0X1D, 0X16, 0XB3, 0X33, 0XD5, 0XC4, 0X23, 0X15, 0X78, 0X8B, 0X29, 0X5A,
    0XD1, 0XC1, 0XAB, 0X24, 0XA5, 0X26, 0XA9, 0X96, 0X5F, 0XC7, 0X31, 0X99, 0X3D, 0XA9, 0XFA, 0X85,

    0XFE, 0XF4, 0XFC, 0XC0, 0XE2, 0X5D, 0XA8, 0X72, 0X40, 0X72, 0X34, 0X0D, 0XA4, 0X5A, 0X99, 0X44,
    0XAB, 0X09, 0X03, 0X3E, 0XA7, 0XAD, 0X81, 0XC8, 0X79, 0XD5, 0X23, 0X91, 0X00, 0XEC, 0X00, 0X47,

    0X5E, 0X16, 0XFB, 0X55, 0X01, 0X45, 0XFF, 0X80, 0XC4, 0XA8, 0XED, 0XFD, 0X35, 0X8A, 0XAA, 0XA8,
    0X96, 0XFD, 0XDB, 0XE8, 0X19, 0XF3, 0X58, 0X73, 0X99, 0XBE, 0X56, 0X6D, 0X4E, 0XF8, 0XAD, 0X40,

    0X2A, 0X95, 0XF5, 0XD3, 0X57, 0X8F, 0X84, 0X79, 0X10, 0XE7, 0XC2, 0XA0, 0XE6, 0XAA, 0X86, 0X5F,
    0X0D, 0XBA, 0X7C, 0XCB, 0XD4, 0X11, 0X09, 0X48, 0X5B, 0XE6, 0X8C, 0XC0, 0X31, 0X66, 0XC1, 0XE6,

    0X2A, 0X70, 0XDC, 0X45, 0XFA, 0X8E, 0X3F, 0X1F, 0XF8, 0X97, 0X74, 0XD1, 0XC1, 0X14, 0XC6, 0X36,
    0X16, 0XA3, 0XDE, 0XB4, 0X6D, 0XF5, 0X43, 0X2E, 0X72, 0XCE, 0XA3, 0X0C, 0X7A, 0X50, 0X5B, 0X44,

    0X07, 0X7A, 0X0E, 0X91, 0X09, 0XF1, 0X83, 0XEC, 0XD0, 0X2B, 0X86, 0X4C, 0X03, 0X14, 0X24, 0XD3,
    0X12, 0X50, 0X2D, 0XE0, 0X95, 0X78, 0X91, 0X88, 0X22, 0X39, 0X49, 0XBF, 0X91, 0X63, 0X76, 0XDD,

    0X28, 0X61, 0XCD, 0XD5, 0X3B, 0XFE, 0X6A, 0X60, 0X5C, 0X2A, 0X41, 0XF9, 0X7B, 0XDC, 0XD3, 0XE6,
    0X4D, 0X85, 0X31, 0XD1, 0X48, 0XD1, 0XF4, 0XE8, 0XED, 0X30, 0XAC, 0XC9, 0XE4, 0XAC, 0XB8, 0X3B,

    0X18, 0X9C, 0XEE, 0XDF, 0X0F, 0X1A, 0X10, 0XFD, 0X21, 0XAC, 0XD4, 0XF3, 0XB3, 0X4B, 0X8C, 0X67,
    0XA2, 0XE0, 0XAD, 0XAE, 0XE5, 0XE7, 0XCF, 0X95, 0X8A, 0X15, 0X0F, 0X94, 0XB8, 0X04, 0XAB, 0X83,

    0X1F, 0X5C, 0X8A, 0XAA, 0XC4, 0XFC, 0X0B, 0X47, 0XFA, 0X28, 0X5F, 0X7E, 0XAE, 0XD1, 0X2C, 0X92,
    0XE2, 0X43, 0X89, 0X75, 0XCB, 0XA2, 0X57, 0X21, 0XC4, 0XD7, 0XB1, 0XAE, 0X74, 0X4F, 0XCE, 0X12,

    0XDD, 0X79, 0XD2, 0X69, 0X15, 0X93, 0X4C, 0X4D, 0X11, 0XEA, 0XB2, 0X77, 0X58, 0X67, 0X20, 0X86,
    0X4A, 0X8B, 0X91, 0X2D, 0XC6, 0XD7, 0X77, 0X1D, 0X3E, 0X54, 0X2D, 0X38, 0XFB, 0X13, 0X6E, 0XDF,

    0X87, 0XF2, 0X08, 0X76, 0XFF, 0XCA, 0X6E, 0X9E, 0XDB, 0X72, 0X8F, 0X2C, 0XE7, 0X8C, 0X70, 0X44,
    0X9F, 0X67, 0XDE, 0XD3, 0X56, 0X79, 0XEE, 0XCA, 0X0C, 0X1F, 0X54, 0X25, 0X9E, 0X7A, 0X7E, 0X9B,

    0X54, 0X58, 0X80, 0XEE, 0X78, 0X45, 0X10, 0XA1, 0X30, 0X4B, 0X85, 0XB3, 0X88, 0X09, 0XFF, 0X5D,
    0XEF, 0XA2, 0X89, 0XA5, 0X05, 0XC8, 0XD9, 0XC5, 0X1F, 0XD4, 0X68, 0X96, 0X6D, 0X91, 0XBB, 0XC4,

    0X76, 0X45, 0X64, 0XB7, 0X26, 0XF9, 0XEE, 0X89, 0X52, 0XEA, 0X6D, 0XA6, 0XB4, 0XD2, 0XFD, 0XE4,
    0X7C, 0X7A, 0XA3, 0XC3, 0XC2, 0X4D, 0X2B, 0X6B, 0X19, 0X0C, 0X80, 0XEF, 0X85, 0X6F, 0X26, 0XB0,

    0XB0, 0XE7, 0XB4, 0XF7, 0XD7, 0X12, 0X5F, 0XE7, 0X2C, 0X71, 0XA6, 0XEE, 0X6F, 0XF7, 0XD0, 0XF9,
    0X0E, 0XE5, 0XDC, 0X1B, 0X72, 0X97, 0X1F, 0XE3, 0X40, 0X2E, 0XB8, 0X2E, 0X6F, 0X80, 0X4D, 0XE8,

    0XCC, 0XFD, 0X78, 0X43, 0X41, 0XAD, 0X30, 0XFC, 0X71, 0X3E, 0XBB, 0XC8, 0X35, 0X3A, 0X8E, 0X36,
    0XBE, 0X7F, 0X1D, 0X0C, 0X91, 0X85, 0X54, 0X7A, 0X13, 0XC0, 0X15, 0XC7, 0XBF, 0X7A, 0XB1, 0X5C,

    0X87, 0XE4, 0XE3, 0X20, 0X27, 0X20, 0X99, 0XC6, 0XEA, 0XBF, 0XEA, 0XC5, 0X6D, 0X49, 0XFF, 0XD5,
    0XBF, 0XCD, 0X0E, 0X29, 0X96, 0X04, 0X8A, 0X65, 0XCE, 0X13, 0XF4, 0X21, 0X02, 0X4A, 0X4D, 0X60,

    0X23, 0X32, 0X1A, 0XB2, 0XAE, 0X91, 0XE5, 0X94, 0X85, 0X10, 0X27, 0XE9, 0X83, 0XE6, 0XCE, 0XC0,
    0X92, 0X7A, 0X93, 0XC1, 0XEF, 0XB7, 0X3F, 0X58, 0XD3, 0X77, 0X61, 0X02, 0X20, 0X43, 0XE6, 0X5C,

    0X01, 0X1B, 0XE6, 0X4A, 0X6B, 0X6C, 0XC2, 0XFC, 0X5E, 0X67, 0X97, 0XE8, 0X51, 0X0C, 0X5B, 0X77,
    0X2C, 0X95, 0XAC, 0XF1, 0X21, 0X80, 0X5E, 0XED, 0XAD, 0XB2, 0XBB, 0XA3, 0X69, 0X50, 0XFB, 0X7E,

    0X74, 0XBC, 0XDA, 0X45, 0XAA, 0X0E, 0XFB, 0XD2, 0X18, 0X05, 0X9C, 0XEA, 0X6F, 0X6F, 0X62, 0X9A,
    0X8B, 0X02, 0X61, 0XE7, 0X48, 0X63, 0X8B, 0X6F, 0XEC, 0XA7, 0X3E, 0XE8, 0X3E, 0X48, 0X0B, 0X8E,

    0X65, 0XBB, 0X95, 0X4F, 0XDC, 0X3B, 0X8B, 0X76, 0X93, 0X1B, 0X4E, 0X3E, 0X29, 0X80, 0X64, 0X5C,
    0X9D, 0XA6, 0X07, 0X58, 0XB8, 0X91, 0X13, 0XCB, 0XFE, 0XB4, 0XBE, 0XE5, 0X92, 0X2C, 0XF5, 0X1A,

    0X00, 0X19, 0X28, 0X44, 0XBE, 0X7A, 0X9A, 0X5D, 0X41, 0X59, 0XB4, 0X44, 0X46, 0XEC, 0X00, 0X00,
    0XB5, 0X10, 0XF2, 0XAF, 0X88, 0XAD, 0X0E, 0X8D, 0X5D, 0XAD, 0X73, 0X71, 0X03, 0X78, 0X98, 0X8C,

    0XC2, 0X56, 0X0F, 0XA6, 0X76, 0XA2, 0X76, 0XE3, 0X56, 0X87, 0XEC, 0X96, 0XB1, 0X14, 0XD8, 0X79,
    0X0A, 0XCA, 0X6A, 0X2F, 0XFC, 0X04, 0X15, 0X94, 0X97, 0X33, 0X0C, 0XCF, 0X10, 0X39, 0X7D, 0XF0,

    0XFD, 0X75, 0XD8, 0X78, 0XFA, 0X66, 0X70, 0X5C, 0XC6, 0XB9, 0X36, 0XDD, 0X98, 0X3D, 0X28, 0XB7,
    0X86, 0XE3, 0X8C, 0XDE, 0XEC, 0X45, 0XA9, 0X66, 0XFE, 0X81, 0XF5, 0X8A, 0XC1, 0X95, 0X51, 0XA9,

    0X42, 0X34, 0XB6, 0X25, 0XB9, 0X52, 0XB5, 0XD8, 0X45, 0X3C, 0XB0, 0XC3, 0X1B, 0X58, 0X35, 0XCD,
    0X00, 0X00, 0X00, 0X01, 0X28, 0XEA, 0X40, 0X81, 0X50, 0X9C, 0X80, 0X00, 0X00, 0X00, 0X01, 0X01,

    0XA8, 0X00, 0X18, 0X00, 0X0A, 0X91, 0XBF, 0XF9, 0XF6, 0X77, 0X50, 0XCA, 0XB4, 0X85, 0X6C, 0X1E,
    0XEB, 0X08, 0XE4, 0X87, 0XDC, 0X8C, 0X55, 0XFD, 0X52, 0X47, 0X9F, 0XD1, 0X17, 0XCC, 0X92, 0X27,

    0X0C, 0X01, 0X70, 0X19, 0XB9, 0X4B, 0X27, 0X69, 0X90, 0X8F, 0X02, 0XBC, 0X00, 0X51, 0X1C, 0X9A,
    0X3B, 0XD6, 0X3F, 0X57, 0XB2, 0XEB, 0X7A, 0XBE, 0X13, 0X15, 0XE4, 0X1D, 0X1A, 0X39, 0X23, 0XE3,

    0X92, 0XDD, 0X0D, 0X32, 0X62, 0XB1, 0X66, 0XF1, 0XD4, 0X79, 0X18, 0X6B, 0XBB, 0X28, 0XC7, 0X96,
    0X00, 0X94, 0X7D, 0X7E, 0X45, 0XE3, 0X85, 0XF1, 0X56, 0X56, 0X3F, 0X64, 0XF0, 0XB5, 0X96, 0X05,

    0XAA, 0X7E, 0X0C, 0X76, 0X59, 0X8A, 0XEA, 0X6F, 0XAE, 0XA0, 0XCB, 0XC1, 0X05, 0X07, 0X64, 0X7A,
    0X0C, 0X6C, 0X51, 0XB4, 0XFF, 0X98, 0X3C, 0XD8, 0XBB, 0X70, 0X01, 0XFA, 0X2B, 0X6E, 0X90, 0XA5,

    0X4C, 0XF4, 0X31, 0X2B, 0X94, 0XB2, 0X2C, 0X5E, 0X29, 0X65, 0X54, 0X5F, 0X54, 0X89, 0XBD, 0XA3,
    0X0B, 0XFC, 0XDB, 0X52, 0X2E, 0XDB, 0X4E, 0XF1, 0XC2, 0XA0, 0X58, 0X10, 0XC1, 0X4D, 0XCE, 0XEB,

    0X1A, 0X92, 0X91, 0XB3, 0XD0, 0XCB, 0XE4, 0X52, 0X30, 0XE8, 0X7D, 0XBB, 0X90, 0XD2, 0XE9, 0X6F,
    0XB2, 0XAC, 0X4B, 0X12, 0X8A, 0X7E, 0X48, 0X92, 0X2F, 0X2A, 0X63, 0X3A, 0XCC, 0X82, 0X32, 0XA9,

    0XBD, 0XAA, 0X38, 0X4C, 0XC7, 0X49, 0X3A, 0X4A, 0X8C, 0XF1, 0X02, 0XDF, 0XC0, 0XC5, 0X05, 0X50,
    0XBD, 0X8F, 0X05, 0X17, 0XA9, 0X18, 0XD5, 0XBB, 0XC1, 0X9C, 0XFC, 0X49, 0X46, 0X24, 0XFC, 0X51,

    0X9B, 0XBA, 0X8D, 0X34, 0X00, 0X2E, 0X91, 0X0D, 0X52, 0X80, 0X98, 0XE4, 0X72, 0X6D, 0XBA, 0X73,
    0X36, 0X1C, 0X13, 0X32, 0X65, 0XD4, 0XAB, 0X1B, 0X90, 0XC8, 0XD0, 0X31, 0X32, 0XF3, 0X71, 0XCD,

    0X2E, 0X07, 0X8A, 0X68, 0XA0, 0X47, 0X7A, 0X51, 0X3E, 0X5A, 0XE0, 0X8D, 0X5B, 0X87, 0X56, 0X2D,
    0X79, 0XC4, 0X1F, 0X05, 0XB6, 0XDA, 0X30, 0X0B, 0XEB, 0X43, 0X11, 0X97, 0X7D, 0X29, 0X7D, 0X9E,

    0XFA, 0XD1, 0XB2, 0X06, 0X30, 0XAF, 0X6D, 0X1D, 0X6D, 0XA7, 0X22, 0X63, 0X8B, 0X6B, 0X6A, 0XC6,
    0X38, 0X0B, 0X10, 0X7F, 0X60, 0XE5, 0XE0, 0XA9, 0XEF, 0X9C, 0X1D, 0X80, 0X00, 0X00, 0X00, 0X01,

    0X28, 0XEA, 0X82, 0X05, 0X42, 0X32, 0X00, 0X00, 0X00, 0X01, 0X21, 0XE0, 0X00, 0X60, 0X00, 0XD4,
    0X6F, 0XE7, 0X10, 0X00, 0X65, 0X34, 0XC1, 0XCF, 0X88, 0X9D, 0XC9, 0X9B, 0X97, 0X46, 0XF9, 0X39,

    0XA7, 0X15, 0X9C, 0XB0, 0X04, 0XA2, 0X67, 0XB2, 0X4D, 0X6C, 0XB9, 0X62, 0X9D, 0X38, 0XDF, 0X87,
    0X0D, 0XF7, 0X1F, 0XDF, 0X11, 0XDF, 0XCD, 0XBB, 0XA4, 0XBD, 0X6C, 0X53, 0X49, 0XAB, 0X12, 0XB8,

    0XC1, 0X8E, 0XC8, 0X44, 0X95, 0XED, 0X29, 0XD7, 0X5B, 0X66, 0X1C, 0X69, 0XD5, 0X08, 0XB6, 0X4A,
    0XEF, 0X3B, 0X1B, 0X22, 0X47, 0XAB, 0X8D, 0X7B, 0XC7, 0X33, 0X09, 0X20, 0X3F, 0X72, 0XB1, 0X24,

    0XA4, 0X97, 0X43, 0XD4, 0X55, 0X4A, 0X48, 0X74, 0X81, 0XC7, 0X32, 0X7E, 0XBF, 0X2E, 0X8F, 0XD1,
    0XE8, 0XDD, 0X51, 0X30, 0XED, 0X33, 0XE1, 0X81, 0XE8, 0XAE, 0XA3, 0XC0, 0X48, 0X05, 0X16, 0X41,

    0X61, 0X10, 0X31, 0X49, 0XBE, 0X0A, 0X74, 0XBC, 0XCA, 0XF6, 0X14, 0X4B, 0X00, 0XAB, 0XBE, 0X0B,
    0XC6, 0X9C, 0X5D, 0XDD, 0XC3, 0X0D, 0XA6, 0X0D, 0X01, 0X07, 0X51, 0X0D, 0XD2, 0X5A, 0XB4, 0XD1,

    0XDF, 0XD6, 0X76, 0X8B, 0X96, 0X35, 0X8B, 0X64, 0X56, 0X30, 0X98, 0XFB, 0X82, 0X20, 0XFF, 0X7D,
    0X23, 0XE6, 0XF8, 0XEC, 0X9B, 0X90, 0X53, 0X75, 0X33, 0XFB, 0X79, 0X45, 0X5D, 0X80, 0XD0, 0XB5,

    0X13, 0X65, 0XD5, 0X35, 0XD1, 0X57, 0XAA, 0X16, 0X1F, 0X1A, 0XC8, 0X8C, 0X26, 0XA4, 0X74, 0X01,
    0X26, 0X41, 0XC6, 0X77, 0X46, 0X90, 0X74, 0X0C, 0XAB, 0X81, 0X67, 0X93, 0X97, 0XA9, 0X43, 0X1B,

    0X3A, 0X0E, 0X03, 0X16, 0X89, 0XF0, 0X81, 0X38, 0XB6, 0X8D, 0XED, 0XFD, 0X9C, 0X95, 0XC9, 0XA5,
    0X63, 0X02, 0X4B, 0XCC, 0X14, 0XB6, 0XF3, 0X4E, 0X17, 0X10, 0XD9, 0X5F, 0X5F, 0X4D, 0X1A, 0XC3,

    0X09, 0X77, 0X38, 0X67, 0XB4, 0X13, 0XBD, 0X8A, 0X63, 0X99, 0X70, 0X41, 0X62, 0XD9, 0X59, 0X04,
    0X2F, 0XC5, 0X00, 0XBC, 0XF4, 0X9A, 0X5C, 0XC6, 0XC1, 0XCA, 0XF6, 0X57, 0X30, 0XEF, 0XD2, 0X82,

    0XCB, 0XDB, 0X0E, 0X27, 0XD8, 0XAC, 0X86, 0XB7, 0X5E, 0XE4, 0XE2, 0X3A, 0X93, 0X8C, 0XB9, 0X79,
    0XF1, 0X7A, 0X3F, 0X22, 0X8F, 0X41, 0X34, 0X62, 0X5E, 0X2F, 0XD7, 0X59, 0X8B, 0X97, 0X01, 0XB5,

    0X4C, 0X35, 0X96, 0XA0, 0XCA, 0XA6, 0X92, 0X65, 0XA5, 0XE4, 0X25, 0XB1, 0XEC, 0X30, 0XD3, 0X50,
    0X6D, 0X1F, 0X1F, 0X71, 0XCB, 0X0F, 0X11, 0X13, 0X93, 0X15, 0XAB, 0X43, 0X08, 0XDA, 0X79, 0XB6,

    0XAF, 0X1C, 0X0D, 0X36, 0X63, 0XD6, 0X9A, 0XF3, 0XCA, 0X46, 0X43, 0X96, 0X2E, 0X9D, 0XCB, 0XDA,
    0X0F, 0XBF, 0X2B, 0XE2, 0X0F, 0X82, 0X81, 0X5B, 0X8B, 0XBC, 0X2A, 0X0F, 0X69, 0X31, 0XAB, 0X85,

    0XF1, 0XC9, 0X16, 0XC8, 0XC2, 0XF0, 0X2A, 0X15, 0X48, 0XF4, 0XDE, 0XF7, 0X9B, 0XE2, 0X2F, 0X96,
    0XF7, 0X53, 0X0D, 0XA5, 0X18, 0X5B, 0X8A, 0XD9, 0X16, 0XCD, 0XE8, 0X5E, 0XEF, 0XF1, 0X79, 0X51,

    0XE4, 0X89, 0X4C, 0XEB, 0XD6, 0X1B, 0XB3, 0X1F, 0X25, 0X08, 0XAA, 0X19, 0X5F, 0XDF, 0X81, 0X4E,
    0X55, 0XCD, 0X1B, 0X03, 0X59, 0X5C, 0X46, 0X3F, 0X6E, 0XC7, 0X2E, 0X2A, 0X94, 0X0C, 0XBB, 0X50,

    0X91, 0X0A, 0X3A, 0X82, 0XD6, 0X40, 0XEE, 0X08, 0XCC, 0X2E, 0X63, 0XE7, 0X26, 0XF0, 0X96, 0X48,
    0X1E, 0XF1, 0XC4, 0X77, 0X28, 0X51, 0XD8, 0X3A, 0XE4, 0XCF, 0X1F, 0XAC, 0X93, 0X77, 0XEC, 0X11,

    0X65, 0X87, 0XA7, 0X99, 0XF6, 0X8E, 0X0A, 0X93, 0X08, 0XA2, 0X36, 0XF9, 0X4D, 0X45, 0X12, 0X40,
    0X6F, 0XCD, 0XF1, 0XA8, 0X40, 0XB9, 0XA1, 0X50, 0XA2, 0X8D, 0X2A, 0XE1, 0XC1, 0X32, 0X4F, 0X5C,

    0X8A, 0X9F, 0XCA, 0XD5, 0X1A, 0XB6, 0XF4, 0XEA, 0XBE, 0X18, 0XFE, 0XEE, 0X54, 0X1C, 0XB8, 0X17,
    0X3D, 0X81, 0X7B, 0X28, 0X7A, 0X46, 0X39, 0X8B, 0X5D, 0XF6, 0X52, 0XDE, 0XBC, 0X33, 0XF8, 0X6F,

    0XA0, 0X8B, 0X4A, 0X47, 0X23, 0X6E, 0X6A, 0X75, 0XB7, 0X68, 0XB7, 0X37, 0XF9, 0XC1, 0X57, 0XE4,
    0X51, 0XEC, 0XE2, 0X90, 0XE1, 0X27, 0X94, 0X5E, 0X5E, 0XEA, 0X2F, 0X66, 0X24, 0XB6, 0XC0, 0XD9,

    0XF2, 0X23, 0XE8, 0X48, 0X7A, 0XCD, 0X98, 0X44, 0XA3, 0XB0, 0XA4, 0X36, 0X71, 0X82, 0XF0, 0X3D,
    0XB2, 0XB0, 0X7B, 0X76, 0XE4, 0XF3, 0X18, 0XEC, 0XE8, 0X30, 0XB6, 0X80, 0X5A, 0X54, 0XFA, 0X97,

    0XE9, 0XC7, 0X19, 0XAF, 0XFC, 0X27, 0XB8, 0XB3, 0XE0, 0X84, 0XCE, 0XBA, 0X63, 0X36, 0XD9, 0XEE,
    0X56, 0XE5, 0X06, 0X29, 0X04, 0X3F, 0XBB, 0X0E, 0XB3, 0X07, 0XC2, 0X18, 0X6E, 0XFF, 0X95, 0XB1,

    0X2B, 0X65, 0XFA, 0XC7, 0X96, 0XFE, 0XB9, 0X1D, 0X11, 0X60, 0X0B, 0X7C, 0XAE, 0X69, 0XFD, 0XB4,
    0X12, 0X1F, 0X66, 0XAE, 0X51, 0X61, 0X80, 0X00, 0X00, 0X00, 0X01, 0X28, 0XEA, 0X40, 0X81, 0X51,

    0XF2, 0X00, 0X00, 0X00, 0X01, 0X01, 0XA8, 0X00, 0X20, 0X00, 0X1A, 0X91, 0XBF, 0XF9, 0X91, 0XFA,
    0XDC, 0X77, 0XE7, 0XBD, 0X66, 0XFE, 0X95, 0X7D, 0X78, 0X99, 0X41, 0X74, 0X55, 0XE1, 0XB7, 0X68,

    0XF3, 0X9C, 0XCB, 0X55, 0X5D, 0X1B, 0XF8, 0XEE, 0XF5, 0X51, 0X2A, 0XD4, 0XB5, 0XB4, 0X2B, 0X5A,
    0X6D, 0X21, 0XF1, 0XBF, 0X19, 0XB7, 0X87, 0X0D, 0X61, 0X5C, 0X4A, 0XA3, 0X3D, 0X28, 0XD6, 0X0D,

    0X4E, 0X95, 0X34, 0X25, 0X17, 0XA6, 0XC3, 0X32, 0X45, 0XF8, 0X8E, 0X67, 0XC4, 0X8A, 0XB4, 0X90,
    0X05, 0X84, 0X3A, 0XAA, 0X8C, 0X84, 0X5D, 0X3F, 0XC3, 0XD1, 0X78, 0XF9, 0X13, 0XBF, 0X28, 0X93,

    0XBE, 0X55, 0XCB, 0X50, 0XEA, 0XDE, 0X0A, 0XD3, 0X56, 0XF2, 0X0A, 0XA0, 0X1F, 0X92, 0X7E, 0X25,
    0XEF, 0XBE, 0X1D, 0X7F, 0X24, 0XF1, 0XA3, 0XB0, 0XD1, 0XF6, 0X2A, 0X05, 0X97, 0X4F, 0X5C, 0XBD,

    0XED, 0X4E, 0XFA, 0XE6, 0X9E, 0XB7, 0X01, 0X8E, 0X3F, 0X76, 0X91, 0X6E, 0X02, 0XF8, 0X3E, 0X9A,
    0XC2, 0XD1, 0XA8, 0X09, 0XD7, 0XF0, 0X66, 0X8C, 0XA6, 0XA3, 0XC1, 0XBA, 0X63, 0X61, 0XF4, 0XE7,

    0X32, 0XB7, 0X20, 0XBA, 0X7E, 0XE9, 0XB5, 0X5C, 0X1E, 0XAB, 0XC6, 0XD8, 0X0A, 0XCC, 0XF4, 0XD4,
    0XFE, 0X87, 0X32, 0XCC, 0X9E, 0X6F, 0X19, 0XA3, 0XAB, 0XB1, 0XF0, 0XD6, 0X2A, 0X1D, 0XF4, 0X66,

    0X4A, 0X68, 0X77, 0X9C, 0X73, 0XD4, 0X57, 0X36, 0X8A, 0X1F, 0X05, 0XD8, 0X4E, 0XFA, 0X03, 0XEA,
    0XE8, 0XE6, 0X1E, 0X02, 0X58, 0X0F, 0X55, 0X69, 0X16, 0X6B, 0XDB, 0X53, 0X86, 0X5B, 0X2F, 0XD4,

    0X3B, 0X4A, 0X5A, 0X01, 0X59, 0X10, 0X13, 0X1D, 0X3A, 0X59, 0XB5, 0X13, 0X37, 0XAE, 0XBA, 0X1B,
    0XE5, 0X52, 0XEA, 0X64, 0X8A, 0X8D, 0X7B, 0X6E, 0XF0, 0X2B, 0X12, 0XFE, 0X1B, 0X95, 0X48, 0XD0,

    0XF0, 0XF1, 0X43, 0XFB, 0XC7, 0X5D, 0XE4, 0X10, 0X7D, 0X49, 0XD2, 0XB0, 0X93, 0X89, 0X7F, 0X34,
    0X50, 0X0A, 0XF9, 0X43, 0X7E, 0XFB, 0X05, 0X8F, 0XDC, 0X7D, 0X4C, 0X7D, 0X82, 0X4A, 0X3F, 0X10,

    0XFB, 0X7E, 0X49, 0X44, 0X00, 0X00, 0X00, 0X01, 0X28, 0XEA, 0X82, 0X05, 0X46, 0XC8, 0X00, 0X00,
    0X00, 0X01, 0X21, 0XE0, 0X00, 0X80, 0X01, 0X14, 0X6F, 0XF6, 0X32, 0XA9, 0X52, 0X0A, 0X7F, 0XDD,

    0X2B, 0X88, 0X75, 0XF9, 0X14, 0X8F, 0X97, 0X14, 0X17, 0X8E, 0X7A, 0XA9, 0X80, 0X5F, 0XC2, 0XD9,
    0X50, 0X03, 0XF1, 0X7D, 0X65, 0XF9, 0XF6, 0X3B, 0X5A, 0XF4, 0XD8, 0X7A, 0XE3, 0X49, 0XA7, 0XCB,

    0X2F, 0X0C, 0XF7, 0X2B, 0XAD, 0XDA, 0X7F, 0X78, 0X40, 0X4F, 0XE9, 0X0D, 0XE0, 0X06, 0X30, 0XF1,
    0X99, 0XDB, 0X99, 0X37, 0X4E, 0XD8, 0X0D, 0X93, 0XA7, 0X30, 0X0A, 0XA2, 0X63, 0XD8, 0X8F, 0XA6,

    0X6C, 0X63, 0XF0, 0X01, 0XEC, 0XF5, 0XC2, 0X16, 0X37, 0XCF, 0XFC, 0X96, 0X42, 0X5F, 0X83, 0X25,
    0X42, 0X26, 0XC3, 0X0C, 0X47, 0XCE, 0XE4, 0X23, 0X5D, 0XC2, 0X56, 0X3A, 0X61, 0XAE, 0XE3, 0XFC,

    0X5B, 0XE1, 0XA4, 0X19, 0X12, 0X12, 0XBF, 0X63, 0X1D, 0X91, 0X33, 0X48, 0X74, 0X93, 0XF8, 0XF1,
    0XA7, 0X95, 0XE2, 0X89, 0X95, 0X42, 0XDF, 0XCB, 0XBB, 0XDE, 0X0F, 0X8E, 0X52, 0XD9, 0X91, 0X19,

    0X60, 0X8E, 0XD9, 0X39, 0XF1, 0XEC, 0XBB, 0X24, 0X01, 0X42, 0X09, 0X0E, 0XA1, 0X56, 0X5A, 0X88,
    0X45, 0X4B, 0X71, 0X58, 0X32, 0X80, 0X0A, 0X7D, 0XB4, 0X1A, 0X20, 0XD5, 0X1F, 0XC2, 0X43, 0X20,

    0XBD, 0XBA, 0X45, 0XD1, 0X93, 0XB5, 0XF8, 0X54, 0XDA, 0X1E, 0XAF, 0X0A, 0X79, 0X00, 0XC7, 0XB4,
    0XD5, 0X27, 0X25, 0X77, 0XFB, 0X9F, 0X43, 0X97, 0XE7, 0XDB, 0X70, 0X16, 0XAB, 0X3E, 0XC1, 0X72,

    0X8C, 0X41, 0X92, 0X2A, 0X6B, 0X96, 0XCA, 0XF1, 0X37, 0X47, 0XC9, 0X83, 0X05, 0X7D, 0X48, 0XC8,
    0X2E, 0X6F, 0X9E, 0X43, 0XF6, 0X90, 0XAD, 0XF1, 0XCE, 0XD6, 0X2B, 0X8C, 0X10, 0XC9, 0X74, 0XE4,

    0XA6, 0X5D, 0XCE, 0X62, 0X40, 0X9B, 0X44, 0X81, 0XA0, 0X75, 0X62, 0XCD, 0X56, 0X88, 0X90, 0XFB,
    0XBA, 0X35, 0X82, 0X52, 0XBA, 0XC4, 0X5B, 0XE8, 0X45, 0X58, 0X79, 0XFC, 0XDD, 0X64, 0X61, 0X70,

    0X36, 0X7F, 0X05, 0XAC, 0X00, 0XA1, 0X11, 0X07, 0XFF, 0X98, 0X11, 0XB4, 0X28, 0X73, 0X01, 0X65,
    0X20, 0XD0, 0X84, 0XE4, 0X91, 0XEA, 0X4D, 0X56, 0XA4, 0X10, 0X54, 0X17, 0X5A, 0X71, 0X19, 0X46,

    0X70, 0X27, 0X91, 0XD5, 0XBA, 0XD8, 0X03, 0X1B, 0X0E, 0XB2, 0XF8, 0X9B, 0XFA, 0XB2, 0XE4, 0XA8,
    0X8B, 0X7D, 0X59, 0XD1, 0XF2, 0X57, 0XC8, 0X04, 0X64, 0XCA, 0XFB, 0X57, 0X57, 0XFC, 0X65, 0X90,

    0X98, 0XF7, 0X35, 0XBB, 0X9B, 0X4C, 0XA0, 0X1D, 0X25, 0XDC, 0X28, 0XCA, 0X91, 0XF9, 0X45, 0X9C,
    0X34, 0X12, 0X9E, 0X0C, 0XB8, 0X46, 0XA2, 0XD5, 0XAF, 0XB4, 0X18, 0XA7, 0X36, 0X6F, 0XDA, 0XDD,

    0XAE, 0X3E, 0XA8, 0X16, 0X8B, 0X92, 0XFB, 0XDA, 0X94, 0X3C, 0XAB, 0X37, 0X45, 0XD6, 0X2D, 0XB1,
    0XAB, 0XF8, 0X8F, 0XD6, 0X6F, 0XD5, 0X3F, 0X73, 0XBF, 0X4D, 0XAC, 0X2C, 0XE8, 0X31, 0XD3, 0XA1,

    0X75, 0X30, 0XBC, 0XEA, 0XDA, 0X07, 0XDA, 0XEE, 0XF9, 0XF7, 0XC9, 0XB1, 0X09, 0XE5, 0XC1, 0X1A,
    0X40, 0X76, 0X32, 0X84, 0X45, 0X38, 0XC6, 0XBD, 0X83, 0X70, 0X32, 0X6A, 0X4B, 0XB9, 0X2A, 0X67,

    0X83, 0X16, 0X14, 0X29, 0XC1, 0X94, 0XAF, 0X59, 0XEF, 0XD2, 0XEC, 0XFF, 0X2E, 0X06, 0X53, 0X55,
    0X39, 0X47, 0XFD, 0X79, 0XCC, 0X0E, 0X21, 0XC1, 0X53, 0X84, 0X60, 0XC1, 0XD8, 0XC0, 0X1E, 0X6D,

    0X02, 0X50, 0X59, 0X2C, 0XDD, 0X66, 0X16, 0X73, 0X2A, 0X7D, 0X63, 0X7D, 0X05, 0XA4, 0X91, 0X7A,
    0XBA, 0X75, 0X72, 0X0C, 0X2E, 0XA6, 0XD3, 0XDA, 0X95, 0X26, 0X71, 0XC9, 0X38, 0X50, 0X8C, 0X45,

    0X4E, 0X19, 0X3E, 0X75, 0XE5, 0X2B, 0X3F, 0X87, 0X0F, 0X22, 0XEB, 0X9B, 0XB1, 0X3F, 0XB7, 0X09,
    0X30, 0XFF, 0X8D, 0XCE, 0XA4, 0X01, 0X11, 0X56, 0X25, 0XD9, 0X96, 0X04, 0XB0, 0X75, 0X92, 0X15,

    0X77, 0XBE, 0XE7, 0XB0, 0XE3, 0X50, 0X7D, 0X04, 0X62, 0XC7, 0X3D, 0X2F, 0X77, 0X2E, 0XBC, 0XBF,
    0X1E, 0XEF, 0X95, 0XA8, 0X6C, 0X72, 0X51, 0XD0, 0X74, 0X03, 0X5F, 0X73, 0XE0, 0X00, 0X00, 0X00,

    0X01, 0X28, 0XEA, 0X40, 0X81, 0X51, 0X72, 0X00, 0X00, 0X00, 0X01, 0X01, 0XA8, 0X00, 0X28, 0X00,
    0X2A, 0X91, 0XBF, 0XFD, 0XD5, 0XE4, 0X2D, 0X87, 0X16, 0X43, 0XCF, 0X52, 0X73, 0X99, 0X5F, 0X12,

    0XC3, 0X97, 0XEB, 0X74, 0XB3, 0X05, 0X21, 0X26, 0XD7, 0X50, 0X4D, 0X3C, 0XB7, 0X4A, 0X00, 0XB7,
    0X7B, 0X59, 0X3B, 0X3E, 0XE7, 0XCB, 0X89, 0X2C, 0X98, 0X13, 0X48, 0XE7, 0XB4, 0XBC, 0XC3, 0X2A,

    0XCF, 0XFB, 0XD8, 0X3D, 0XA2, 0XB0, 0XCE, 0XF4, 0X58, 0X43, 0X4A, 0X9E, 0XA1, 0X76, 0X94, 0X9F,
    0XD5, 0X8F, 0X04, 0XF7, 0XD4, 0X2C, 0X26, 0X77, 0X5B, 0X9A, 0X5C, 0X10, 0X7D, 0X1F, 0X41, 0X08,

    0X3E, 0X9B, 0XDE, 0X1A, 0X82, 0X0B, 0X8F, 0X49, 0X25, 0X58, 0X3D, 0X31, 0X7A, 0X16, 0X9A, 0X4F,
    0X13, 0X95, 0XB0, 0XDD, 0XB5, 0XF7, 0X45, 0XE7, 0X40, 0XD2, 0X42, 0XEE, 0XC0, 0XB7, 0XE7, 0X64,

    0X99, 0X3F, 0XC4, 0X89, 0XD2, 0X3C, 0X6F, 0XE0, 0X62, 0X71, 0X0F, 0X66, 0X6B, 0XC1, 0X2F, 0X93,
    0XFF, 0XBE, 0XF6, 0X7E, 0X29, 0X21, 0X9C, 0X11, 0X98, 0X4F, 0X78, 0XD4, 0X66, 0X5F, 0X1C, 0X7B,

    0XC4, 0X22, 0XB5, 0XD0, 0X56, 0X43, 0X51, 0XFF, 0X6C, 0XA3, 0X12, 0XA9, 0X3C, 0X91, 0X26, 0X05,
    0X9D, 0X6D, 0X58, 0X0F, 0XFC, 0X88, 0XF2, 0X17, 0X91, 0X94, 0XEA, 0XAF, 0X04, 0X7A, 0X87, 0XFF,

    0X47, 0X28, 0XF9, 0X7B, 0X38, 0XCA, 0XBE, 0X4A, 0XBF, 0X1A, 0XAD, 0X43, 0X68, 0XC7, 0X6E, 0XC3,
    0X4D, 0X15, 0X32, 0X64, 0XD8, 0XF2, 0XEB, 0XC2, 0X26, 0XB5, 0X70, 0XFB, 0XA0, 0X2A, 0X63, 0X50,

    0XF5, 0X84, 0XA7, 0XE5, 0XBC, 0XC3, 0X4E, 0XA9, 0XD0, 0XFB, 0X07, 0X40, 0XEB, 0X36, 0XD0, 0XC5,
    0XD0, 0X2B, 0X35, 0XFD, 0X32, 0XCE, 0X79, 0X0E, 0X58, 0XC5, 0X8F, 0XB2, 0X9C, 0XDB, 0X7E, 0XB9,

    0XF6, 0XAE, 0X32, 0XC9, 0X0A, 0X58, 0XDE, 0XD4, 0X9A, 0X8F, 0XA2, 0X00, 0X8A, 0XEF, 0X2A, 0XD0,
    0X61, 0X7C, 0X73, 0X94, 0X96, 0X9B, 0X4D, 0XC2, 0X48, 0X6F, 0X5A, 0XE4, 0XC1, 0X49, 0XC0, 0X00,

    0X00, 0X00, 0X01, 0X28, 0XEE, 0X08, 0X15, 0X13, 0X20, 0X00, 0X00, 0X00, 0X01, 0X21, 0XB8, 0X00,
    0X28, 0X00, 0X52, 0XFF, 0XB4, 0X48, 0XD0, 0XDC, 0XA2, 0X0B, 0X3D, 0XFD, 0X8A, 0X24, 0X4E, 0X06,

    0X7F, 0XB5, 0XF7, 0X98, 0XE3, 0XF6, 0X01, 0XB3, 0X8A, 0X91, 0X0C, 0XC5, 0X5D, 0X63, 0XB8, 0XAE,
    0XC5, 0X5C, 0XF1, 0X5F, 0XB1, 0X2D, 0X07, 0X6D, 0X58, 0X30, 0XDB, 0X01, 0XED, 0X82, 0X0C, 0X80,

    0XEE, 0X0A, 0X3B, 0XE5, 0X09, 0X0E, 0XB0, 0XB7, 0X3D, 0X62, 0X9B, 0X99, 0X22, 0X74, 0X2C, 0XBF,
    0X00, 0X34, 0X31, 0X3E, 0X87, 0XF8, 0X4F, 0X27, 0XDD, 0X10, 0XC2, 0X55, 0X2F, 0XF0, 0X0D, 0X45,

    0X4A, 0XFC, 0XC8, 0X09, 0X6D, 0XDE, 0X87, 0X54, 0X41, 0X27, 0XFF, 0XBC, 0X2C, 0XA9, 0XD0, 0XF4,
    0X33, 0XE4, 0X6E, 0XD1, 0X03, 0X30, 0XF3, 0X7B, 0X04, 0X13, 0X75, 0XFD, 0X53, 0XC8, 0XC2, 0XB1,

    0X6B, 0X08, 0X50, 0XF4, 0X58, 0X4E, 0XE1, 0XD3, 0XEA, 0X5A, 0XDA, 0XDF, 0X80, 0X10, 0X6E, 0X3F,
    0XF4, 0X5F, 0XE0, 0XF3, 0XC1, 0XCB, 0XA7, 0XFE, 0X6A, 0XFE, 0XD1, 0X31, 0X74, 0X7F, 0XF3, 0XAB,

    0XB2, 0X6F, 0X85, 0X21, 0X57, 0X8F, 0X1D, 0X37, 0X3D, 0X76, 0X37, 0X4C, 0X3E, 0X63, 0X79, 0X66,
    0XA4, 0X1C, 0X93, 0X0A, 0XC1, 0X36, 0X8C, 0XA6, 0XE7, 0XAC, 0X01, 0XC5, 0X7F, 0XBC, 0XE4, 0X54,

    0X96, 0XC8, 0X11, 0X20, 0X7A, 0XFC, 0X30, 0XEA, 0XF2, 0X2C, 0XC9, 0XC1, 0X83, 0X31, 0X27, 0X00,
    0X50, 0X6A, 0X61, 0XA9, 0X7A, 0X1C, 0XAA, 0X4A, 0X78, 0X45, 0XFD, 0X56, 0X54, 0XCE, 0XDF, 0XDC,

    0X75, 0X9A, 0X4A, 0X63, 0XB6, 0XC8, 0X58, 0X62, 0X9C, 0X16, 0XA0, 0X5C, 0X06, 0XDD, 0X5E, 0XCF,
    0XB0, 0XBA, 0X62, 0X2F, 0XB9, 0X7D, 0XB3, 0X7A, 0X5E, 0X76, 0X84, 0XBC, 0XEE, 0X9C, 0X01, 0X01,

    0X20, 0XCD, 0XAB, 0XB8, 0X12, 0X58, 0X87, 0X04, 0X98, 0X91, 0X90, 0X4F, 0X28, 0XBD, 0XB5, 0XDE,
    0X1B, 0X9C, 0X0E, 0XA6, 0X5F, 0XAB, 0X09, 0XAC, 0XD6, 0XE1, 0XD6, 0XDD, 0X8F, 0X3A, 0X52, 0XDE,

    0XBB, 0X24, 0X0D, 0XDA, 0XE6, 0XA6, 0X2A, 0X61, 0XD3, 0XE0, 0XAE, 0X58, 0XDC, 0XC4, 0X59, 0X28,
    0XC5, 0X9F, 0XE3, 0XDD, 0X6B, 0X81, 0XE3, 0X27, 0X48, 0X0C, 0XAF, 0XAF, 0X70, 0XE9, 0X64, 0X9C,
};
#endif

/* Define the expected results for the Start Code lists */
typedef struct STFDMA_SCResult_s
{
    int     Type    :   2;  /* STFDMA_SC_ENTRY */
    int     Tag     :   8;
    int     Addr;
    U32     Res1;
    U32     Res0;

} STFDMA_SCResult_t;

static STFDMA_SCResult_t PESasPES[] =
{
    {1, 0, 0X010, 0X00000000, 0X00000000},
    {1, 0, 0X040, 0X00000001, 0XE2224444},
    {0, 0, 0X00F, 0X00, 0},
    {0, 0, 0X018, 0X01, 0},
    {0, 0, 0X040, 0X00, 0},
    {0, 0, 0X065, 0X58, 0},
    {0, 0, 0X071, 0X00, 0},
    {0, 0, 0X0A2, 0X00, 0},
    {0, 0, 0X0D3, 0X00, 0},
    {0, 0, 0X0F3, 0XB0, 0},
    {1, 0, 0X181, 0X00000001, 0XE2224444},
    {0, 0, 0X113, 0XBB, 0},
    {0, 0, 0X133, 0XB1, 0},
    {0, 0, 0X137, 0XB2, 0},
    {0, 0, 0X13C, 0XB3, 0},
    {0, 0, 0X155, 0XB4, 0},
    {0, 0, 0X15A, 0XB5, 0},
    {0, 0, 0X163, 0X01, 0},
    {0, 0, 0X182, 0X00, 0},
};

static STFDMA_SCResult_t PESasES[] =
{
    {0, 0, 0X00F, 0X00, 0},
    {0, 0, 0X013, 0XBC, 0},
    {0, 0, 0X028, 0X01, 0},
    {0, 0, 0X053, 0XFF, 0},
    {0, 0, 0X085, 0X58, 0},
    {0, 0, 0X093, 0XBC, 0},
    {0, 0, 0X0D3, 0XFF, 0},
    {0, 0, 0X113, 0XDD, 0},
    {0, 0, 0X123, 0X00, 0},
    {0, 0, 0X143, 0XB0, 0},
    {0, 0, 0X163, 0XBB, 0},
    {0, 0, 0X183, 0XB1, 0},
    {0, 0, 0X187, 0XB2, 0},
    {0, 0, 0X18C, 0XB3, 0},
    {0, 0, 0X1A5, 0XB4, 0},
    {0, 0, 0X1AA, 0XB5, 0},
    {0, 0, 0X1B3, 0X01, 0},
    {0, 0, 0X1D4, 0XFF, 0},
};

static STFDMA_SCResult_t ESasPES[] =
{
    {0, 0, 0X00F, 0X00, 0},
    {0, 0, 0X018, 0X01, 0},
    {0, 0, 0X040, 0X00, 0},
    {0, 0, 0X065, 0X58, 0},
    {0, 0, 0X071, 0X00, 0},
    {0, 0, 0X0A2, 0X00, 0},
    {0, 0, 0X0D3, 0X00, 0},
    {0, 0, 0X0F3, 0XB0, 0},
    {0, 0, 0X113, 0XBB, 0},
    {0, 0, 0X133, 0XB1, 0},
    {0, 0, 0X137, 0XB2, 0},
    {0, 0, 0X13C, 0XB3, 0},
    {0, 0, 0X155, 0XB4, 0},
    {0, 0, 0X15A, 0XB5, 0},
    {0, 0, 0X163, 0X01, 0},
    {0, 0, 0X182, 0X00, 0},
};

static STFDMA_SCResult_t ESasES[] =
{
    {0, 0, 0X00F, 0X00, 0},
    {0, 0, 0X018, 0X01, 0},
    {0, 0, 0X040, 0X00, 0},
    {0, 0, 0X065, 0X58, 0},
    {0, 0, 0X071, 0X00, 0},
    {0, 0, 0X0A2, 0X00, 0},
    {0, 0, 0X0D3, 0X00, 0},
    {0, 0, 0X0F3, 0XB0, 0},
    {0, 0, 0X113, 0XBB, 0},
    {0, 0, 0X133, 0XB1, 0},
    {0, 0, 0X137, 0XB2, 0},
    {0, 0, 0X13C, 0XB3, 0},
    {0, 0, 0X155, 0XB4, 0},
    {0, 0, 0X15A, 0XB5, 0},
    {0, 0, 0X163, 0X01, 0},
    {0, 0, 0X182, 0X00, 0},
};

#if defined (ST_7100) || defined (ST_7109) || defined (ST_7200)
static STFDMA_SCResult_t H264asES[] =
{
    {0, 0, 0X0004, 0X027, 0},
    {0, 0, 0X0012, 0X028, 0},
    {0, 0, 0X001C, 0X125, 0},
    {0, 0, 0X1062, 0X028, 0},
    {0, 0, 0X106C, 0X121, 0},
    {0, 0, 0X134B, 0X028, 0},
    {0, 0, 0X1355, 0X121, 0},
    {0, 0, 0X1654, 0X028, 0},
    {0, 0, 0X165F, 0X101, 0},
    {0, 0, 0X17A0, 0X028, 0},
    {0, 0, 0X17AA, 0X121, 0},
    {0, 0, 0X1A3B, 0X028, 0},
    {0, 0, 0X1A45, 0X101, 0},
    {0, 0, 0X1B68, 0X028, 0},
    {0, 0, 0X1B72, 0X121, 0},
    {0, 0, 0X1DA1, 0X028, 0},
    {0, 0, 0X1DAB, 0X101, 0},
    {0, 0, 0X1EC3, 0X028, 0},
    {0, 0, 0X1ECD, 0X121, 0},
};
#endif

#if !defined (ST_7710) && !defined (STFDMA_NO_PACED_TESTS)
static U16 SPDIFData[2*SPDIF_BURST_SIZE -4] =
{
    0X0000, 0X8000,
    0X0001, 0X8001,
    0X0002, 0X8002,
    0X0003, 0X8003,
    0X0004, 0X8004,
    0X0005, 0X8005,
    0X0006, 0X8006,
    0X0007, 0X8007,
    0X0008, 0X8008,
    0X0009, 0X8009,
    0X000A, 0X800A,
    0X000B, 0X800B,
    0X000C, 0X800C,
    0X000D, 0X800D,
    0X000E, 0X800E,
    0X000F, 0X800F,

    0X0010, 0X8010,
    0X0011, 0X8011,
    0X0012, 0X8012,
    0X0013, 0X8013,
    0X0014, 0X8014,
    0X0015, 0X8015,
    0X0016, 0X8016,
    0X0017, 0X8017,
    0X0018, 0X8018,
    0X0019, 0X8019,
    0X001A, 0X801A,
    0X001B, 0X801B,
    0X001C, 0X801C,
    0X001D, 0X801D,
    0X001E, 0X801E,
    0X001F, 0X801F,

    0X0020, 0X8020,
    0X0021, 0X8021,
    0X0022, 0X8022,
    0X0023, 0X8023,
    0X0024, 0X8024,
    0X0025, 0X8025,
    0X0026, 0X8026,
    0X0027, 0X8027,
    0X0028, 0X8028,
    0X0029, 0X8029,
    0X002A, 0X802A,
    0X002B, 0X802B,
    0X002C, 0X802C,
    0X002D, 0X802D,
    0X002E, 0X802E,
    0X002F, 0X802F,

    0X0030, 0X8030,
    0X0031, 0X8031,
    0X0032, 0X8032,
    0X0033, 0X8033,
    0X0034, 0X8034,
    0X0035, 0X8035,
    0X0036, 0X8036,
    0X0037, 0X8037,
    0X0038, 0X8038,
    0X0039, 0X8039,
    0X003A, 0X803A,
    0X003B, 0X803B,
    0X003C, 0X803C,
    0X003D, 0X803D,
    0X003E, 0X803E,
    0X003F, 0X803F,

    0X0040, 0X8040,
    0X0041, 0X8041,
    0X0042, 0X8042,
    0X0043, 0X8043,
    0X0044, 0X8044,
    0X0045, 0X8045,
    0X0046, 0X8046,
    0X0047, 0X8047,
    0X0048, 0X8048,
    0X0049, 0X8049,
    0X004A, 0X804A,
    0X004B, 0X804B,
    0X004C, 0X804C,
    0X004D, 0X804D,
    0X004E, 0X804E,
    0X004F, 0X804F,

    0X0050, 0X8050,
    0X0051, 0X8051,
    0X0052, 0X8052,
    0X0053, 0X8053,
    0X0054, 0X8054,
    0X0055, 0X8055,
    0X0056, 0X8056,
    0X0057, 0X8057,
    0X0058, 0X8058,
    0X0059, 0X8059,
    0X005A, 0X805A,
    0X005B, 0X805B,
    0X005C, 0X805C,
    0X005D, 0X805D,
    0X005E, 0X805E,
    0X005F, 0X805F,

    0X0060, 0X8060,
    0X0061, 0X8061,
    0X0062, 0X8062,
    0X0063, 0X8063,
    0X0064, 0X8064,
    0X0065, 0X8065,
    0X0066, 0X8066,
    0X0067, 0X8067,
    0X0068, 0X8068,
    0X0069, 0X8069,
    0X006A, 0X806A,
    0X006B, 0X806B,
    0X006C, 0X806C,
    0X006D, 0X806D,
    0X006E, 0X806E,
    0X006F, 0X806F,

    0X0070, 0X8070,
    0X0071, 0X8071,
    0X0072, 0X8072,
    0X0073, 0X8073,
    0X0074, 0X8074,
    0X0075, 0X8075,
    0X0076, 0X8076,
    0X0077, 0X8077,
    0X0078, 0X8078,
    0X0079, 0X8079,
    0X007A, 0X807A,
    0X007B, 0X807B,
    0X007C, 0X807C,
    0X007D, 0X807D,
};

static U32 CDFIFOData[2*SPDIF_BURST_SIZE] =
{
    0XA123000E, 0XB1230000,
    0XC123000E, 0XD1230000,
    0X0000000E, 0X80000000,
    0X0001000C, 0X80010000,

    0X0002000C, 0X80020002,
    0X0003000E, 0X80030002,
    0X0004000E, 0X80040002,
    0X0005000C, 0X80050002,

    0X0006000E, 0X80060000,
    0X0007000C, 0X80070002,
    0X0008000E, 0X80080002,
    0X0009000C, 0X80090002,

    0X000A000C, 0X800A0002,
    0X000B000C, 0X800B0000,
    0X000C000E, 0X800C0002,
    0X000D000C, 0X800D0002,

    0X000E000E, 0X800E0000,
    0X000F000E, 0X800F0000,
    0X0010000C, 0X80100002,
    0X0011000C, 0X80110002,

    0X0012000C, 0X80120002,
    0X0013000E, 0X80130002,
    0X0014000C, 0X80140000,
    0X0015000C, 0X80150002,

    0X0016000E, 0X80160000,
    0X0017000C, 0X80170002,
    0X0018000C, 0X80180000,
    0X0019000C, 0X80190002,

    0X001A000C, 0X801A0002,
    0X001B000C, 0X801B0000,
    0X001C000C, 0X801C0000,
    0X001D000C, 0X801D0002,

    0X001E000C, 0X801E0002,
    0X001F000C, 0X801F0000,
    0X0020000C, 0X80200000,
    0X0021000E, 0X80210000,

    0X0022000C, 0X80220000,
    0X0023000C, 0X80230000,
    0X0024000C, 0X80240000,
    0X0025000C, 0X80250000,
    0X0026000C, 0X80260000,
    0X0027000C, 0X80270000,
    0X0028000C, 0X80280000,
    0X0029000C, 0X80290000,
    0X002A000C, 0X802A0000,
    0X002B000C, 0X802B0000,
    0X002C000C, 0X802C0000,
    0X002D000C, 0X802D0000,
    0X002E000C, 0X802E0000,
    0X002F000C, 0X802F0000,

    0X0030000C, 0X80300000,
    0X0031000C, 0X80310000,
    0X0032000C, 0X80320000,
    0X0033000C, 0X80330000,
    0X0034000C, 0X80340000,
    0X0035000C, 0X80350000,
    0X0036000C, 0X80360000,
    0X0037000C, 0X80370000,
    0X0038000C, 0X80380000,
    0X0039000C, 0X80390000,
    0X003A000C, 0X803A0000,
    0X003B000C, 0X803B0000,
    0X003C000C, 0X803C0000,
    0X003D000C, 0X803D0000,
    0X003E000C, 0X803E0000,
    0X003F000C, 0X803F0000,

    0X0040000C, 0X80400000,
    0X0041000C, 0X80410000,
    0X0042000C, 0X80420000,
    0X0043000C, 0X80430000,
    0X0044000C, 0X80440000,
    0X0045000C, 0X80450000,
    0X0046000C, 0X80460000,
    0X0047000C, 0X80470000,
    0X0048000C, 0X80480000,
    0X0049000C, 0X80490000,
    0X004A000C, 0X804A0000,
    0X004B000C, 0X804B0000,
    0X004C000C, 0X804C0000,
    0X004D000C, 0X804D0000,
    0X004E000C, 0X804E0000,
    0X004F000C, 0X804F0000,

    0X0050000C, 0X80500000,
    0X0051000C, 0X80510000,
    0X0052000C, 0X80520000,
    0X0053000C, 0X80530000,
    0X0054000C, 0X80540000,
    0X0055000C, 0X80550000,
    0X0056000C, 0X80560000,
    0X0057000C, 0X80570000,
    0X0058000C, 0X80580000,
    0X0059000C, 0X80590000,
    0X005A000C, 0X805A0000,
    0X005B000C, 0X805B0000,
    0X005C000C, 0X805C0000,
    0X005D000C, 0X805D0000,
    0X005E000C, 0X805E0000,
    0X005F000C, 0X805F0000,

    0X0060000C, 0X80600000,
    0X0061000C, 0X80610000,
    0X0062000C, 0X80620000,
    0X0063000C, 0X80630000,
    0X0064000C, 0X80640000,
    0X0065000C, 0X80650000,
    0X0066000C, 0X80660000,
    0X0067000C, 0X80670000,
    0X0068000C, 0X80680000,
    0X0069000C, 0X80690000,
    0X006A000C, 0X806A0000,
    0X006B000C, 0X806B0000,
    0X006C000C, 0X806C0000,
    0X006D000C, 0X806D0000,
    0X006E000C, 0X806E0000,
    0X006F000C, 0X806F0000,

    0X0070000C, 0X80700000,
    0X0071000C, 0X80710000,
    0X0072000C, 0X80720000,
    0X0073000C, 0X80730000,
    0X0074000C, 0X80740000,
    0X0075000C, 0X80750000,
    0X0076000C, 0X80760000,
    0X0077000C, 0X80770000,
    0X0078000C, 0X80780000,
    0X0079000C, 0X80790000,
    0X007A000C, 0X807A0000,
    0X007B000C, 0X807B0000,
    0X007C000C, 0X807C0000,
    0X007D000C, 0X807D0000,
};
#endif

#endif

/* Macros ----------------------------------------------------------------- */

#define MIN(x,y)   (((x)<(y))?(x):(y))

#if defined(DEBUG)
void DebugBufferStuff(int);
void DebugPoll(int Count);
void DebugActive(void);
int  DebugDump(U8 *Master, U8 *Result, U32 Size);
int  DebugDump32(U32 *Master, U32 *Result, U32 Size);
void DebugSCList(U32 BaseES, STFDMA_SCEntry_t *List, U32 Size);
void DebugBufferStuff(int idx);
void DebugBufferGrab(int idx);
void DebugNodeGrab(int idx);
#endif

#if !defined(ST_5517)
static int SCCompare(U32 BaseES, STFDMA_SCResult_t *List1, STFDMA_SCEntry_t *List2, U32 Size);
#endif

/* Functions -------------------------------------------------------------- */

/****************************************************************************
Name         : Callback
Description  : Callback function for general functional test usage
Parameters   : As defined by the stfdma API for callback functions.
Return Value :
****************************************************************************/
static void Callback (U32 TransferId, U32 CallbackReason, U32 *CurrentNode_p,
                      U32 NodeBytesRemaining, BOOL Error, void* ApplicationData_p,
                      STOS_Clock_t  InterruptTime)
{
    BOOL ApplicationDataOk = FALSE;
    STFDMA_Node_t *Node_p;

    /* Check bytes remaining has a sensible value */
#if defined (ARCHITECTURE_ST40)
#if defined (ST_OS21)
    Node_p = (STFDMA_Node_t *) ST40_NOCACHE_NOTRANSLATE(CurrentNode_p);
#else
    Node_p = (STFDMA_Node_t*)fdmatst_GetNodeVirtualAddressFromPhysical((dma_addr_t)CurrentNode_p);
#endif
#else
    Node_p = (STFDMA_Node_t *) CurrentNode_p;
#endif
    if (NodeBytesRemaining > Node_p->NumberBytes)
    {
        VERBOSE_PRINT_DATA("Callback: *** ERROR: NodeBytesRemaining has illegal value (%d)\n",NodeBytesRemaining);
    }

    if ((TransferId == GeneralTransferId) ||
        (TransferId == F209TransferIds[0]) ||
        (TransferId == F209TransferIds[1]) ||
        (TransferId == F209TransferIds[2]) ||
        (TransferId == F209TransferIds[3]) ||
        (TransferId == F209TransferIds[4]) ||
        (TransferId == F209TransferIds[5]) ||
        (TransferId == F102TransferIds[0]) ||
        (TransferId == F102TransferIds[1]) ||
        (TransferId == F102TransferIds[2]) ||
        (TransferId == F102TransferIds[3]) ||
        (TransferId == F102TransferIds[4]) ||
        (TransferId == F102TransferIds[5]) ||
        (TransferId == F211TransferIds[0]) ||
        (TransferId == F211TransferIds[1]) ||
        (TransferId == F212TransferIds[0]) ||
        (TransferId == F212TransferIds[1]) ||
        (TransferId == F212TransferIds[2]) ||
        (TransferId == F212TransferIds[3]) ||
        (TransferId == F212TransferIds[4]) ||
        (TransferId == F212TransferIds[5]) ||
        (TransferId == PES1TransferId)  ||
        (TransferId == PES2TransferId)  ||
        (TransferId == F221TransferId)  ||
        (TransferId == SPDIFTransferId) ||
        (TransferId == F319TransferId)

#if !defined (ST_5517)
        || (TransferId == NonblockingMultipleDreqTestTransferId1)
        || (TransferId == NonblockingMultipleDreqTestTransferId2)
#endif
        )

    {
        /* Expected reasons for callback...*/
        switch (CallbackReason)
        {
        case STFDMA_NOTIFY_TRANSFER_ABORTED:
            VERBOSE_PRINT("Callback: Transfer aborted.\n");
            VERBOSE_PRINT_DATA("Callback: CurrentNode_p: 0x%x\n",CurrentNode_p);
            VERBOSE_PRINT_DATA("Callback: NodeBytesRemaining: %d\n",NodeBytesRemaining);
            if ((TransferId != PES1TransferId) &&
                (TransferId != PES2TransferId) &&
                (TransferId != F221TransferId) &&
                (TransferId != SPDIFTransferId))
            {
                STOS_SemaphoreSignal(pAbortSemap);
            }
            break;

        case STFDMA_NOTIFY_TRANSFER_COMPLETE:
            VERBOSE_PRINT("Callback: Transfer complete.\n");
            VERBOSE_PRINT_DATA("Callback: CurrentNode_p: 0x%x\n",CurrentNode_p);
            VERBOSE_PRINT_DATA("Callback: NodeBytesRemaining: %d\n",NodeBytesRemaining);
            if (FALSE == g_Test319)
            {
                STOS_SemaphoreSignal(pTransferCompleteSemap);
            }
            else  /* Expect error for F319 and only signal if error obtained */
            {
                if (Error)
                {
                    VERBOSE_PRINT("Callback: Error flag set.\n");
                    STOS_SemaphoreSignal(pTransferCompleteSemap);
                }
            }
            break;

        case STFDMA_NOTIFY_NODE_COMPLETE_DMA_PAUSED:
            VERBOSE_PRINT("Callback: Node complete and paused.\n");
            VERBOSE_PRINT_DATA("Callback: CurrentNode_p: 0x%x\n",CurrentNode_p);
            VERBOSE_PRINT_DATA("Callback: NodeBytesRemaining: %d\n",NodeBytesRemaining);
            if (/*(TransferId != PES1TransferId) &&
                (TransferId != PES2TransferId) &&*/
                (TransferId != SPDIFTransferId) &&
                (TransferId != F221TransferId))
            {
                STOS_SemaphoreSignal(pPausedSemap);
            }
            break;

        case STFDMA_NOTIFY_NODE_COMPLETE_DMA_CONTINUING:
            VERBOSE_PRINT("Callback: Node complete and transfer continues.\n");
            VERBOSE_PRINT_DATA("Callback: CurrentNode_p: 0x%x\n",CurrentNode_p);
            VERBOSE_PRINT_DATA("Callback: NodeBytesRemaining: %d\n",NodeBytesRemaining);
            if ((TransferId != PES1TransferId) &&
                (TransferId != PES2TransferId) &&
                (TransferId != F221TransferId) &&
                (TransferId != SPDIFTransferId) &&
                (TransferId != F319TransferId))
            {
                STOS_SemaphoreSignal(pNodeCompleteSemap);
            }
            else
            {
                STTBX_Print(("Callback: *** ERROR: Wasn't expecting this callback.\n"));
                fdmatst_SetSuccessState(FALSE);
            }
            break;

        default :
            STTBX_Print(("Callback: *** ERROR: Unexpected callback reason.\n"));
            VERBOSE_PRINT_DATA("Callback: CurrentNode_p: 0x%x\n",CurrentNode_p);
            fdmatst_SetSuccessState(FALSE);
            break;
        }

    }
    else /* Unknown transferId, something wrong....*/
    {
        STTBX_Print(("Callback: *** ERROR: Unrecognised TransferId %08X\n", TransferId));
        fdmatst_SetSuccessState(FALSE);
    }

    /* Display messgae if error set and not expected....*/
    if ((Error) && (FALSE == g_Test319))
    {
        STTBX_Print(("Callback: *** ERROR: Error flag set.\n"));
        fdmatst_SetSuccessState(FALSE);
    }

    /* Check return data pointer is as test expects.... */
    if (ApplicationData_p != NULL)
    {
        ApplicationDataOk = FALSE;

        /* Check test expects data */
        if (TransferId == F211TransferIds[0])
        {
            if (ApplicationData_p == F211AppDataA_p)
            {
                ApplicationDataOk = TRUE;
            }
        }
        else if (TransferId == F211TransferIds[1])
        {
            if (ApplicationData_p == F211AppDataB_p)
            {
                ApplicationDataOk = TRUE;
            }
        }
        else  /* Test case not expecting data...so error */
        {
            ApplicationDataOk = FALSE;
            STTBX_Print(("Callback: ***ERROR: ApplicationData_p wrong: TransferId 0x%x, F211Transfer1Id 0x%x, F211Transfer2Id 0x%x, ApplicationData_p: 0x%x, AppData1: 0x%x, AppData2: 0x%x\n",
                         TransferId,F211TransferIds[0], F211TransferIds[1], (U32)ApplicationData_p, (U32)F211AppDataA_p, (U32)F211AppDataB_p));
        }

        /* Summarise the above testing */
        if (ApplicationDataOk == TRUE)
        {
            VERBOSE_PRINT_DATA("Callback: ApplicationData_p as expected: 0x%x\n",ApplicationData_p);
        }
        else
        {
            STTBX_Print(("Callback: ***ERROR: ApplicationData_p unexpectedly set.\n"));
            fdmatst_SetSuccessState(FALSE);
        }
    }
}

/****************************************************************************
Name         : TransferTask
Description  : Starts a transfer of the specified type on the given channel
Parameters   : TransferTaskParams_t  (see above)
Return Value :
****************************************************************************/
#if defined (ST_OSLINUX)
static int  TransferTask(void *TaskParams_p)
#else
static void TransferTask(void *TaskParams_p)
#endif
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferId_t         TransferId = 0;
    STFDMA_Node_t               *Node_p;
    STFDMA_ChannelId_t          ChannelId = 0xaa;
    TransferTaskParams_t        *TransferTaskParams_p;

    STOS_TaskEnter(TaskParams_p);

    VERBOSE_PRINT("TransferTask running...\n");

    TransferTaskParams_p = (TransferTaskParams_t *)TaskParams_p;

    if (TransferTaskParams_p->Circular == FALSE)
    {
        /* Setup node for 1D transfer */
        VERBOSE_PRINT("Setup 1D transfer.\n");

        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE, &Node_p);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }
    else
    {
        /* 1D endless transfer */
        VERBOSE_PRINT("Setup circular transfer.\n");
        ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, FALSE, &Node_p);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    /* Setup channel usage */
    if (TransferTaskParams_p->LockChannel == FALSE)
    {
        ChannelId = STFDMA_USE_ANY_CHANNEL;
    }
    else
    {
        /* Lock a channel */
        VERBOSE_PRINT("Calling STFDMA_LockChannel, expect NO_ERROR.\n");
        ErrorCode = STFDMA_LockChannel(&ChannelId, STFDMA_1);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        VERBOSE_PRINT_DATA("ChannelId = %d.\n",ChannelId);
    }


    /* Start the transfer */
    if (TransferTaskParams_p->Blocking == FALSE)
    {
        VERBOSE_PRINT("Setup non-blocking transfer.\n");
        TransferParams.BlockingTimeout = 0;
        TransferParams.CallbackFunction = Callback;
    }
    else
    {
        VERBOSE_PRINT("Setup blocking transfer.\n");
        TransferParams.BlockingTimeout = 10000;
        TransferParams.CallbackFunction = NULL;
    }

    TransferParams.ChannelId = ChannelId;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;

    VERBOSE_PRINT("Calling StartTransfer. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Unlock the channel if necessary */
    if (TransferTaskParams_p->LockChannel == TRUE)
    {
        VERBOSE_PRINT_DATA("Calling STFDMA_UnlockChannel for channel %d, expect NO_ERROR.\n",ChannelId);
        ErrorCode = STFDMA_UnlockChannel(ChannelId, STFDMA_1);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    /* Signal test thread of completion */
    STOS_SemaphoreSignal(pTestContinue);

    /*
    To coordinate the termination of the 3 tasks all of which have higher priority than the single thread
    (running test f101) trying to terminate them.
    */

    STOS_SemaphoreWait(pTaskContinue1);
    if (((TransferTaskParams_t *)TaskParams_p)->TestID == 0xF10101)
        STOS_TaskExit(TaskParams_p);
    else
    {
        STOS_SemaphoreWait(pTaskContinue2);
        if (((TransferTaskParams_t *)TaskParams_p)->TestID == 0xF10102)
            STOS_TaskExit(TaskParams_p);
        else
        {
            STOS_SemaphoreWait(pTaskContinue3);
            STOS_TaskExit(TaskParams_p);
        }
    }

#if defined (ST_OSLINUX)
    return ST_NO_ERROR;
#endif
}

/****************************************************************************
Name         : IsCircularTransferRunning
Description  : Utility to check if circular transfer is running
Parameters   :
Return Value :
****************************************************************************/
/*static BOOL IsCircularTransferRunning(STFDMA_TransferId_t TransferId)*/
BOOL IsCircularTransferRunning(STFDMA_TransferId_t TransferId)
{
    STFDMA_TransferStatus_t     TransferStatusA, TransferStatusB;
    U32                          i=0;
    ST_ErrorCode_t              ErrorCode;

    /* GetTransferStatus, expect no errors */
    VERBOSE_PRINT("Repeatedly calling STFDMA_GetTransferStatus and checking current NodeAddress..\n");

    /* Get transfer status snapshot */
    ErrorCode = STFDMA_GetTransferStatus(TransferId, &TransferStatusA);
    if (ErrorCode != ST_NO_ERROR)
    {
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    /* Repeatedly get transfer status for node address comparison */
    for (i=0; (i < TRANSFER_RUNNING_COUNT_MAX); i++)
    {
        /* Get another transfer status snapshot */
        STFDMA_GetTransferStatus(TransferId, &TransferStatusB);
        if (ErrorCode != ST_NO_ERROR)
        {
            fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        }

        /* Compare addresses */
        if (TransferStatusA.NodeAddress != TransferStatusB.NodeAddress ||\
            TransferStatusA.NodeBytesRemaining != TransferStatusB.NodeBytesRemaining)
        {
            /* Address differ therefore transfer is running */
            break;
        }
    }

    /* Assess if transfer is running.
     * If Count is same as MAX NodeAddress never change therefore transfer is not running.
     */
    if (i == TRANSFER_RUNNING_COUNT_MAX)
    {
        VERBOSE_PRINT("*** ERROR: Circular transfer NOT running\n");
        return FALSE;
    }
    else
    {
        VERBOSE_PRINT("Circular transfer is running.\n");
        return TRUE;
    }
}

/****************************************************************************
Name         : CaseF101
Description  : Tests multiple threads to access free channels .
               Performs transfers to completion from three threads, two
               of which attempt channel locking for added test coverage.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF101(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    TransferTaskParams_t        TransferTask1Params,TransferTask2Params,TransferTask3Params;

    STTBX_Print(("Checking multi-thread multi-transfer usage...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Wait for transfers to complete */
    VERBOSE_PRINT("Launching tasks and then waiting for all 3 transfers to complete.\n");

    /* Launch transfer tasks */
    TransferTask1Params.Blocking = TRUE;
    TransferTask1Params.LockChannel = TRUE;
    TransferTask1Params.Paced = FALSE;
    TransferTask1Params.Circular = FALSE;
    TransferTask1Params.TestID = 0xF10101;

    TransferTask2Params.Blocking = TRUE;
    TransferTask2Params.LockChannel = TRUE;
    TransferTask2Params.Paced = FALSE;
    TransferTask2Params.Circular = FALSE;
    TransferTask2Params.TestID = 0xF10102;

    TransferTask3Params.Blocking = TRUE;
    TransferTask3Params.LockChannel = TRUE;
    TransferTask3Params.Paced = FALSE;
    TransferTask3Params.Circular = FALSE;
    TransferTask3Params.TestID = 0xF10103;

    STOS_TaskCreate((void(*)(void *))TransferTask,
                    (void *)&TransferTask1Params,
                    system_partition,
                    (size_t)TASK_STACK_SIZE,
                    (void **)&TransferTask1Stack,
                    system_partition,
                    &pTransferTask1,
                    TransferTask1Descriptor,
                    MAX_USER_PRIORITY,
                    "TransferTask 1",
                    (task_flags_t)0);

    STOS_TaskCreate((void(*)(void *))TransferTask,
                    (void *)&TransferTask2Params,
                    system_partition,
                    (size_t)TASK_STACK_SIZE,
                    (void **)&TransferTask2Stack,
                    system_partition,
                    &pTransferTask2,
                    TransferTask2Descriptor,
                    MAX_USER_PRIORITY,
                    "TransferTask 2",
                    (task_flags_t)0);

    STOS_TaskCreate((void(*)(void *))TransferTask,
                    (void *)&TransferTask3Params,
                    system_partition,
                    (size_t)TASK_STACK_SIZE,
                    (void **)&TransferTask3Stack,
                    system_partition,
                    &pTransferTask3,
                    TransferTask3Descriptor,
                    MAX_USER_PRIORITY,
                    "TransferTask 3",
                    (task_flags_t)0);

    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    VERBOSE_PRINT("Wait for task 1 completion\n");
    if (STOS_SemaphoreWait(pTestContinue) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get transfer complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    VERBOSE_PRINT("Wait for task 2 completion\n");
    if (STOS_SemaphoreWait(pTestContinue) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get transfer complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    VERBOSE_PRINT("Wait for task 3 completion\n");
    if (STOS_SemaphoreWait(pTestContinue) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get transfer complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    if (fdmatst_IsTestSuccessful())
    {
        VERBOSE_PRINT("Transfers completed successfully.\n");
    }

    STOS_SemaphoreSignal(pTaskContinue1);
    STOS_SemaphoreSignal(pTaskContinue1);
    STOS_SemaphoreSignal(pTaskContinue1);
    STOS_TaskWait(&pTransferTask1, (STOS_Clock_t *)TIMEOUT_INFINITY);

    STOS_SemaphoreSignal(pTaskContinue2);
    STOS_SemaphoreSignal(pTaskContinue2);
    STOS_TaskWait(&pTransferTask2, (STOS_Clock_t *)TIMEOUT_INFINITY);

    STOS_SemaphoreSignal(pTaskContinue3);
    STOS_TaskWait(&pTransferTask3, (STOS_Clock_t *)TIMEOUT_INFINITY);

    STOS_TaskDelete(pTransferTask1, system_partition, (void *)TransferTask1Stack, system_partition);
    STOS_TaskDelete(pTransferTask2, system_partition, (void *)TransferTask2Stack, system_partition);
    STOS_TaskDelete(pTransferTask3, system_partition, (void *)TransferTask3Stack, system_partition);

    /* Clean up */
    VERBOSE_PRINT("Task complete, clean memory space.\n");
    fdmatst_DeallocateNodes();

    /* Kill driver */
    VERBOSE_PRINT("Calling STFDMA_Term, exepct NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
}

/****************************************************************************
Name         : CaseF102
Description  : Test channel locking mechansim to allow exclusive access to channel
               by locking a channel, start a transfer on all remaining channels,
               attempting to start a transfer on any channel once more which
               should fail. Then starting a transfer on the locked channel which
               should succeed.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF102(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p;
    STFDMA_ChannelId_t          ChannelId = 0xaa;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferId_t         TransferId = 0;
    U32                         i = 0;

    STTBX_Print(("Checking exclusive access to locked channel...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Acquire a channel */
    VERBOSE_PRINT("Calling STFDMA_LockChannel, expect NO_ERROR.\n");
    ErrorCode = STFDMA_LockChannel(&ChannelId, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT_DATA("ChannelId = %d.\n",ChannelId);

    /* 1D endless transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, TRUE, TRUE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start transfers on other free channels.
     *  Note: Same transfer is sent to several channels. Data consistancy not an
     *        issue in this test.
     */
    VERBOSE_PRINT("Loading all free channels.\n");

    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    for (i = 0; i < NUM_CHANNELS - 1; i++)
    {
        VERBOSE_PRINT("Call STFDMA_StartTransfer, expect NO_ERROR.\n");
        ErrorCode = STFDMA_StartTransfer(&TransferParams, &F102TransferIds[i]);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    VERBOSE_PRINT("Only locked channel now free. Try to start transfer on any channel.\n");
    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect NO_FREE_CHANNELS.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_NO_FREE_CHANNELS);

    VERBOSE_PRINT("Try to start transfer on the locked channel.\n");
    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect NO_ERROR.\n");
    TransferParams.ChannelId = ChannelId;
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F102TransferIds[i]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Kill driver */
    VERBOSE_PRINT("Calling STFDMA_Term, Forced, expect NO_ERROR after all transfers abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Deallocate node memory */
    VERBOSE_PRINT("Cleaning memory space.\n");
    fdmatst_DeallocateNodes();

    /* Reset transfer ids */
    for (i = 0; i < F102_TRANSFER_COUNT; i++)
    {
        F102TransferIds[i] = 0;
    }
}

/****************************************************************************
Name         : CaseF103
Description  : Tests linked list transfers without CPU intervention
Parameters   :
Return Value :
****************************************************************************/
static void CaseF103(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node1_p;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferId_t         TransferId = 0;
    U32                         i = 0;
    U32                         DataError = 0;

    STTBX_Print(("Checking linked list transfer without CPU intervention...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setting up linked list of nodes.\n");

    VERBOSE_PRINT("Node 1...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node1_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node1_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node1_p->Next_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("List comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at         0x%x\n",Node1_p);
    VERBOSE_PRINT_DATA("  Node1->Next_p == 0x%x\n",Node1_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 at         0x%x\n",Node1_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2->Next_p == 0x%x\n",Node1_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 at         0x%x\n",Node1_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3->Next_p == 0x%x\n",Node1_p->Next_p->Next_p->Next_p);

    TransferParams.BlockingTimeout = 10000; /* 10secs */
    TransferParams.CallbackFunction = NULL;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node1_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node1_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a blocking transfer expect NO_ERROR.\n");

    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Checking data transfered correctly.\n");
    DataError = fdmatst_CheckData(&Node1_p, "F103");
    if (DataError != 0)
    {
        VERBOSE_PRINT("*** ERROR: Data not transfered correctly.\n");
        fdmatst_SetSuccessState(FALSE);
        for (i=0; DataError !=0; i++)
        {
            /* Inform which node in list did transfer correctly */
            if (DataError & 0x01)
            {
                VERBOSE_PRINT_DATA("-> Node %d wrong.\n",i);
            }
            DataError >>= 1;
        }
    }
    else
    {
        VERBOSE_PRINT("-> Data transfered correctly.\n");
    }

    /* Term, forced. Expect no error */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : CaseF107
Description  : Tests application notification of end of node reached and
               transfer is continuing
Parameters   :
Return Value :
****************************************************************************/
static void CaseF107(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;

    STTBX_Print(("Checking application notification of end of node, transfer continues..\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* setup nodes with end of node notify, not pause */
    VERBOSE_PRINT("Setting up linked list of nodes.\n");
    VERBOSE_PRINT("Node 1...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   TRUE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&Node_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&Node_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&Node_p->Next_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("List comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at         0x%x\n",Node_p);
    VERBOSE_PRINT_DATA("  Node1->Next_p == 0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 at         0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2->Next_p == 0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 at         0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3->Next_p == 0x%x\n",Node_p->Next_p->Next_p->Next_p);

    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a non-blocking transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* wait for node complete signal */
    VERBOSE_PRINT("Waiting for node complete signal.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pNodeCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get node complete within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Waiting for transfer complete signal.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get list complete within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    /* Term, forced. Expect no error */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : CaseF109
Description  : Tests each transfer capable of blocking until transfer
               complete or blocking timeout reached
Parameters   :
Return Value :
****************************************************************************/
static void CaseF109(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferId_t         TransferId = 0;
    U32                         DataError = 0;
    U32                         i = 0;

    STTBX_Print(("Checking blocking transfer run to completion or until timeout...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* setup nodes with end of node notify, not pause */
    VERBOSE_PRINT("Setting up linked list of nodes.\n");
    VERBOSE_PRINT("Node 1...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p->Next_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("List comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at         0x%x\n",Node_p);
    VERBOSE_PRINT_DATA("  Node1->Next_p == 0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 at         0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2->Next_p == 0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 at         0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3->Next_p == 0x%x\n",Node_p->Next_p->Next_p->Next_p);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 10000; /* 10secs */
    TransferParams.CallbackFunction = NULL;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a blocking transfer expect NO_ERROR.\n");

    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* check data */
    VERBOSE_PRINT("Checking data transfered correctly.\n");
    DataError = fdmatst_CheckData(&Node_p, "F109");
    if (DataError != 0)
    {
        VERBOSE_PRINT("*** ERROR: Data not transfered correctly.\n");
        fdmatst_SetSuccessState(FALSE);
        for (i=0; DataError !=0; i++)
        {
            /* Inform which node in list did transfer correctly */
            if (DataError && 0x01)
            {
                VERBOSE_PRINT_DATA("-> Node %d wrong.\n",i);
            }
            DataError >>= 1;
        }
    }
    else
    {
        VERBOSE_PRINT("-> Data transfered correctly.\n");
    }

    /* Clean up */
    VERBOSE_PRINT("Clean up memory usage.\n");
    fdmatst_DeallocateNodes();

    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, TRUE, TRUE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel with short timeout */
    TransferParams.BlockingTimeout = 1;  /* 1ms Short timeout */
    TransferParams.CallbackFunction = NULL;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a blocking transfer expect BLOCKING_TIMEOUT.\n");

    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_BLOCKING_TIMEOUT);

    /* terminate driver */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}

#if !defined (ST_5517) && !defined(ST_OSLINUX)
/****************************************************************************
Name         : CaseF110Task
Description  : Check blocking transfer with no timeout is released on error
Parameters   :
Return Value :
****************************************************************************/
void CaseF110Task(void* params)
{
    STOS_TaskDelay(fdmatst_GetClocksPerSec() * 1 * DELAY_MODIFIER);

    /* Re-enable the interrupts in the int mask */
    STSYS_WriteRegDev32LE(INTERRUPT_MASK_REG, 0xFFFFFFFF);
}

/****************************************************************************
Name         : CaseF110
Description  : Check blocking transfer with no timeout is released on error
Parameters   :
Return Value :
****************************************************************************/
static void CaseF110(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferId_t         TransferId = 0;

    STTBX_Print(("Checking blocking release on error...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* setup nodes with end of node notify, not pause */
    VERBOSE_PRINT("Setting up linked list of nodes.\n");
    VERBOSE_PRINT("Node 1...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   TRUE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p->Next_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Adjusting default node configuration....");
    VERBOSE_PRINT_DATA("Reducing the nodes NumberBytes and Length to %d\n",SMALL_NUMBER_BYTES);
    Node_p->NumberBytes = SMALL_NUMBER_BYTES;
    Node_p->Length = SMALL_NUMBER_BYTES;
    Node_p->Next_p->NumberBytes = SMALL_NUMBER_BYTES;
    Node_p->Next_p->Length = SMALL_NUMBER_BYTES;
    Node_p->Next_p->Next_p->NumberBytes = SMALL_NUMBER_BYTES;
    Node_p->Next_p->Next_p->Length = SMALL_NUMBER_BYTES;

    VERBOSE_PRINT("List comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at         0x%x\n",Node_p);
    VERBOSE_PRINT_DATA("  Node1->Next_p == 0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 at         0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2->Next_p == 0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 at         0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3->Next_p == 0x%x\n",Node_p->Next_p->Next_p->Next_p);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0; /* Infinite */
    TransferParams.CallbackFunction = NULL;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;

    /* StartTransfer unlocks interrupts so disable the FDMA interrupts by writing directly to the int mask */
    STSYS_WriteRegDev32LE(INTERRUPT_MASK_REG, 0x00000000);

    STOS_TaskCreate(CaseF110Task,
                    (void *)NULL,
                    system_partition,
                    (int)TASK_STACK_SIZE,
                    (void **)&CaseF110TaskStack,
                    system_partition,
                    &pCaseF110Task,
                    CaseF110TaskDescriptor,
                    (int)10,
                    "CaseF110Task",
                    (task_flags_t)0);

    if (pCaseF110Task == NULL)
    {
        STTBX_Report(( STTBX_REPORT_LEVEL_ERROR, "Failed to start test case F110 thread" ));
    }

    VERBOSE_PRINT("Call STFDMA_StartTransfer for a blocking transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_TRANSFER_FAILED);

    /* Clean up */
    VERBOSE_PRINT("Clean up memory usage.\n");
    fdmatst_DeallocateNodes();

    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, TRUE, TRUE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel with short timeout */
    TransferParams.BlockingTimeout = 1;  /* 1ms Short timeout */
    TransferParams.CallbackFunction = NULL;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a blocking transfer expect BLOCKING_TIMEOUT.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_BLOCKING_TIMEOUT);

    /* terminate driver */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    STOS_TaskWait(&pCaseF110Task, (STOS_Clock_t *)TIMEOUT_INFINITY);
    STOS_TaskDelete(pCaseF110Task, system_partition, (void *)CaseF110TaskStack, system_partition);

    /* Clean up */
    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}
#endif

/****************************************************************************
Name         : CaseF112
Description  : Tests if the application is capable of tracking transfer
               progress while transfer in various states of running and
               paused
Parameters   :
Return Value :
****************************************************************************/
static void CaseF112(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferStatus_t     TransferStatus;
    U32                         i = 0;

    STTBX_Print(("Checking ability to track transfer progress...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* setup nodes with end of node notify, not pause */
    VERBOSE_PRINT("Setting up linked list of nodes.\n");
    VERBOSE_PRINT("Node 1...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   TRUE, TRUE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   TRUE, TRUE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   TRUE, TRUE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &Node_p->Next_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a non-blocking transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Wait for pause indicator twice since we know there are three node in list.
     *  Last node should give transfer complete indication
     */
    for (i=0; i<2;i++)
    {
        VERBOSE_PRINT_DATA("Wait for node %d pause indication\n",i+1);
        WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
        if (STOS_SemaphoreWaitTimeOut(pPausedSemap, &WaitTime) != 0)
        {
            /* semaphore timed out....no notification provided..error */
            VERBOSE_PRINT("*** ERROR: Did not get pause inidcator within time allowed.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        /* Obtain transfer status */
        VERBOSE_PRINT("Calling STFDMA_GetTransferStatus, expect NO_ERROR\n");
        ErrorCode = STFDMA_GetTransferStatus(GeneralTransferId, &TransferStatus);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        if (TransferStatus.Paused != TRUE)
        {
            VERBOSE_PRINT("*** ERROR: Expected paused flag to be set.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        VERBOSE_PRINT("Calling STFDMA_ResumeTransfer, expect NO_ERROR\n");
        ErrorCode = STFDMA_ResumeTransfer(GeneralTransferId);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    /* Expect transfer complete inidicator form the last node */
    VERBOSE_PRINT("Wait for transfer complete indication\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get list complete inidcator within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    /* Obtain transfer status */
    VERBOSE_PRINT("Calling STFDMA_GetTransferStatus, expect INVALID_TRANSFER_ID\n");
    ErrorCode = STFDMA_GetTransferStatus(GeneralTransferId, &TransferStatus);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_INVALID_TRANSFER_ID);

    /* Clean up */
    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();

    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, TRUE, TRUE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a non-blocking, endless transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Check transfer is in progress */
    VERBOSE_PRINT("Calling STFDMA_GetTransferStatus, expect NO_ERROR\n");
    ErrorCode = STFDMA_GetTransferStatus(GeneralTransferId, &TransferStatus);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("TransferStatus :  \n");
    VERBOSE_PRINT_DATA("  CurrentNode      = %x\n",TransferStatus.NodeAddress);
    VERBOSE_PRINT_DATA("  Paused status    = %x\n",TransferStatus.Paused);
    VERBOSE_PRINT_DATA("  Bytes transfered = %d\n",TransferStatus.NodeBytesRemaining);

    VERBOSE_PRINT("Check if circular transfer is running using STFDMA_GetTransferStatus\n");
    if (IsCircularTransferRunning(GeneralTransferId) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
    }

    /* terminate driver */
    VERBOSE_PRINT("Calling STFDMA_Term, forced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : F201ToF208TransferTests
Description  : Worker function for test F201 to F208
Parameters   : Value identifying the test to execute
Return Value :
****************************************************************************/
static void F201ToF208TransferTests(int TestCase)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;
    U32                         DataError = 0;

    /* Action depends on test ident */
    switch (TestCase)
    {
    case F201 :
        STTBX_Print(("Checking non-paced 2D to 2D transfer with src/dest negative stride...\n\n"));
        break;
    case F202 :
        STTBX_Print(("Checking non-paced 2D to 2D transfer with -ve src stride and +ve dest stride...\n\n"));
        break;
    case F203 :
        STTBX_Print(("Checking non-paced 2D to 2D transfer with +ve src and dest stride...\n\n"));
        break;
    case F204 :
        STTBX_Print(("Checking non-paced 1D to 1D transfer...\n\n"));
        break;
    case F205 :
        STTBX_Print(("Checking non-paced 1D to 2D transfer with +ve dest stride...\n\n"));
        break;
    case F206 :
        STTBX_Print(("Checking non-paced 2D to 1D transfer with +ve src stride...\n\n"));
        break;
    case F207 :
        STTBX_Print(("Checking non-paced 0D to 1D transfer...\n\n"));
        break;
    case F208 :
        STTBX_Print(("Checking non-paced 0D to 2D transfer with +ve dest stride...\n\n"));
        break;
    default :
        STTBX_Print(("*** ERROR: Invalid test case Id given\n"));
    }

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setting up node.\n");
    /* Action depends on test ident */
    switch (TestCase)
    {
    case F201 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_2D, FDMATST_Y_DEC, FALSE,
                                       FDMATST_DIM_2D, FDMATST_Y_DEC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE, &Node_p);
        break;
    case F202 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_2D, FDMATST_Y_DEC, FALSE,
                                       FDMATST_DIM_2D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE, &Node_p);
        break;
    case F203 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_2D, FDMATST_Y_INC, FALSE,
                                       FDMATST_DIM_2D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE, &Node_p);
        break;
    case F204 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE,&Node_p);
        break;
    case F205 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FDMATST_DIM_2D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE,&Node_p);
        break;
    case F206 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_2D, FDMATST_Y_INC, FALSE,
                                       FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE,&Node_p);

        break;
    case F207 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_STATIC, TRUE,
                                       FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE,  &Node_p);
        break;
    case F208 :
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_STATIC, FALSE,
                                       FDMATST_DIM_2D, FDMATST_Y_INC, TRUE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE,&Node_p);
        break;
    default :
        VERBOSE_PRINT("*** ERROR: Invalid test case Id given\n");
    }

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a non-blocking transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Waiting for transfer to complete.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get transfer complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }
        /* Action depends on test ident */
    switch (TestCase)
    {
    case F201 :
        DataError = fdmatst_CheckData(&Node_p, "F201");
        break;
    case F202 :
        DataError = fdmatst_CheckData(&Node_p, "F202");
        break;
    case F203 :
        DataError = fdmatst_CheckData(&Node_p, "F203");
        break;
    case F204 :
        DataError = fdmatst_CheckData(&Node_p, "F204");
        break;
    case F205 :
        DataError = fdmatst_CheckData(&Node_p, "F205");
        break;
    case F206 :
        DataError = fdmatst_CheckData(&Node_p, "F206");
        break;
    case F207 :
        DataError = fdmatst_CheckData(&Node_p, "F207");
        break;
    case F208 :
        DataError = fdmatst_CheckData(&Node_p, "F208");
        break;
    default :
        VERBOSE_PRINT("*** ERROR: Invalid test case Id given\n");
    }
    if (DataError != 0)
    {
        VERBOSE_PRINT_DATA("*** ERROR: Data check failed. DataError 0x%x.\n",DataError);
        fdmatst_SetSuccessState(FALSE);
    }

    /* terminate driver */
    VERBOSE_PRINT("Calling STFDMA_Term, forced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : F209ToF210TransferTests
Description  : Worker function for F209 and F210
Parameters   : BOOL F209 : TRUE - test F209 is executed
                         : FALSE - test F210 is executed
Return Value :
****************************************************************************/
static void F209ToF210TransferTests(int TestCase)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p[6];
    STFDMA_TransferParams_t     TransferParams;
    U32                         NodeCreation = 0;
    U32                         i = 0;
    U32                         DataError = 0;
    int                         ChannelCount = 6;

#if defined (ST_5188)
    ChannelCount = 3;
#endif

    if (TestCase == F209)
    {
        STTBX_Print(("Checking heavy transfer load with one callback task manager..\n\n"));
    }
    else
    {
        STTBX_Print(("Checking heavy transfer load with six callback task managers..\n\n"));
    }


    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();

    if (TestCase == F209)
    {
        InitParams.NumberCallbackTasks = 1;      /* one callback task manager */
    }
    else
    {
        InitParams.NumberCallbackTasks = 6;      /* 6 callback task managers */
    }
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setting up 6 2D to 2D nodes.\n");

    /* Create 6 nodes of the same transfer type */
    for (i = 0; i< ChannelCount; i++)
    {
        /* Clear out TransferId array */
        F209TransferIds[i] = 0;

        /* Create new node */
        ErrorCode = fdmatst_CreateNode(FDMATST_DIM_2D, FDMATST_Y_INC, TRUE,
                                       FDMATST_DIM_2D, FDMATST_Y_INC, TRUE,
                                       FALSE, FALSE,
                                       STFDMA_REQUEST_SIGNAL_NONE,&Node_p[i]);

        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        if (ErrorCode != ST_NO_ERROR)
        {
            NodeCreation |= (1 << i);
        }
    }

    if (ErrorCode == ST_NO_ERROR)
    {
        /* Start the transfer on any channel */
        TransferParams.BlockingTimeout = 0;
        TransferParams.CallbackFunction = Callback;
        TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
        TransferParams.ApplicationData_p = NULL;
        TransferParams.FDMABlock = STFDMA_1;
        VERBOSE_PRINT("Call STFDMA_StartTransfer for 6 non-blocking transfers expect NO_ERROR.\n");

        for (i=0; i<ChannelCount;i++)
        {
            fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[i]);
            TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[i]);
            ErrorCode = STFDMA_StartTransfer(&TransferParams, &F209TransferIds[i]);
            fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        }

        VERBOSE_PRINT("Waiting for all 6 transfers to complete.\n");
        for (i=0; i<ChannelCount; i++)
        {
            WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
            if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
            {
                /* semaphore timed out....no notification provided..error */
                VERBOSE_PRINT("*** ERROR: Did not get transfer complete notification within time allowed.\n");
                fdmatst_SetSuccessState(FALSE);
            }
        }

        for (i=0; i<ChannelCount; i++)
        {
            VERBOSE_PRINT_DATA("Checking the data for transfer %d.\n",i);
            if (TestCase == F209)
            {
                DataError = fdmatst_CheckData(&Node_p[i], "F209");
            }
            else
            {
                DataError = fdmatst_CheckData(&Node_p[i], "F210");
            }
            if (DataError != 0)
            {
                VERBOSE_PRINT_DATA("*** ERROR: Data check failed. DataError 0x%x\n",DataError);
                fdmatst_SetSuccessState(FALSE);
            }
        }
    }

    /* terminate driver */
    VERBOSE_PRINT("Calling STFDMA_Term, forced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    if (NodeCreation == 0)
    {
        VERBOSE_PRINT("Clean up memory.\n");

        for (i=0; i<ChannelCount; i++)
        {
            /* Clean up nodes that were created */
            if ((NodeCreation && (1 << i)) == 0)
            {
                fdmatst_DeallocateNodes();
            }

            F209TransferIds[i] = 0;
        }
    }
}


/****************************************************************************
Name         : CaseF211
Description  : Tests that application data is supplied with callback in non
               blocking transfer
Parameters   :
Return Value :
****************************************************************************/
static void CaseF211(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *ListA_p = NULL;
    STFDMA_Node_t               *ListB_p = NULL;
    STFDMA_TransferParams_t     TransferParams;
    U32                         i = 0;

    STTBX_Print(("Checking application data is passed back correctly by callback...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Setup two linked lists */
    VERBOSE_PRINT("Setting up first list of nodes.\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&ListA_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&ListA_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&ListA_p->Next_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("ListA comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at         0x%x\n",ListA_p);
    VERBOSE_PRINT_DATA("  Node1->Next_p == 0x%x\n",ListA_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 at         0x%x\n",ListA_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2->Next_p == 0x%x\n",ListA_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 at         0x%x\n",ListA_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3->Next_p == 0x%x\n",ListA_p->Next_p->Next_p->Next_p);

    VERBOSE_PRINT("Setting up second list of nodes.\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &ListB_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE, &ListB_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,
                                   &ListB_p->Next_p->Next_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("ListB comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at         0x%x\n",ListB_p);
    VERBOSE_PRINT_DATA("  Node1->Next_p == 0x%x\n",ListB_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 at         0x%x\n",ListB_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2->Next_p == 0x%x\n",ListB_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 at         0x%x\n",ListB_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3->Next_p == 0x%x\n",ListB_p->Next_p->Next_p->Next_p);

    /* Start the first transfer */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(ListA_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(ListA_p);
    TransferParams.ApplicationData_p = ListA_p;    /* Send first Node of ListA in list as data to return */
    TransferParams.FDMABlock = STFDMA_1;
    F211AppDataA_p = TransferParams.ApplicationData_p; /* Pass up for global checking in callback */
    VERBOSE_PRINT_DATA("Call STFDMA_StartTransfer for a non-blocking transfer, application data == 0x%x, expect NO_ERROR.\n",
                       F211AppDataA_p);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F211TransferIds[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the second transfer */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(ListB_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(ListB_p);
    TransferParams.ApplicationData_p = ListB_p;    /* Send first Node of ListA in list as data to return */
    TransferParams.FDMABlock = STFDMA_1;
    F211AppDataB_p = TransferParams.ApplicationData_p; /* Pass up for global checking in callback */
    VERBOSE_PRINT_DATA("Call STFDMA_StartTransfer for a non-blocking transfer, application data == 0x%x, expect NO_ERROR.\n",
                       F211AppDataB_p);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F211TransferIds[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Wait for both transfers to complete */
    VERBOSE_PRINT("Waiting for first transfer complete signal.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        STTBX_Print(("*** ERROR: Did not get first list complete within time allowed.\n"));
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Waiting for second transfer complete signal.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        STTBX_Print(("*** ERROR: Did not get list complete within time allowed.\n"));
        fdmatst_SetSuccessState(FALSE);
    }

    /* Term, forced. Expect no error */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();

    for (i = 0; i < F211_TRANSFER_COUNT; i++)
    {
        F211TransferIds[i] = 0;
    }
}

/****************************************************************************
Name         : CaseF212
Description  : Tests that multiple simultaneous can be performed
Parameters   :
Return Value :
****************************************************************************/
static void CaseF212(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p[6];
    U32                         i = 0;

    STTBX_Print(("Checking multiple simultaneous non-paced transfers....\n"));

    /* First check a transfer can run to completion while a circular in progress..*/

        /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setup first tranfser nodes for two 1d to 1d non-paced, circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for endless, non-blocking transfer. Expect no error.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Checking if circular transfer is running\n");
    if (IsCircularTransferRunning(F212TransferIds[0]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Setup second transfer node for a single 1d to 1d non-paced transfer.\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[1]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[1]);
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for non-blocking transfer. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);


    VERBOSE_PRINT("Wait until completion....\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        VERBOSE_PRINT("*** ERROR: Did not get complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    /* GetTransferStatus, expect no errors */
    VERBOSE_PRINT("Checking if circular transfer is STILL running\n");
    if (IsCircularTransferRunning(F212TransferIds[0]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Now check multiple transfer circular can progress..*/

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setup 6 tranfser nodes for two 1d to 1d non-paced, circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[2]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if !defined (ST_5188)
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[3]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[4]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_NONE, &Node_p[5]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
#endif

    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer six times for endless, non-blocking transfer. Expect no error.\n");

    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[1]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[1]);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[2]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[2]);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[2]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if !defined (ST_5188)
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[3]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[3]);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[3]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[4]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[4]);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[4]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[5]);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[5]);
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F212TransferIds[5]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
#endif

    VERBOSE_PRINT("Checking if all circular transfers are running\n");
    if (IsCircularTransferRunning(F212TransferIds[0]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
        STTBX_Print(("***ERROR: Transfer 0 halted!\n"));
    }

    if (IsCircularTransferRunning(F212TransferIds[1]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
        STTBX_Print(("***ERROR: Transfer 1 halted!\n"));
    }

    if (IsCircularTransferRunning(F212TransferIds[2]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
        STTBX_Print(("***ERROR: Transfer 2 halted!\n"));
    }

#if !defined (ST_5188)
    if (IsCircularTransferRunning(F212TransferIds[3]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
        STTBX_Print(("***ERROR: Transfer 3 halted!\n"));
    }

    if (IsCircularTransferRunning(F212TransferIds[4]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
        STTBX_Print(("***ERROR: Transfer 4 halted!\n"));
    }

    if (IsCircularTransferRunning(F212TransferIds[5]) == FALSE)
    {
        fdmatst_SetSuccessState(FALSE);
        STTBX_Print(("***ERROR: Transfer 5 halted!\n"));
    }
#endif

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer ids */
    for (i = 0; i < F212_TRANSFER_COUNT; i++)
    {
        F212TransferIds[i] = 0;
    }
}

#if !defined(ST_5517)  /* FDMA 2 ONLY */

/* Theses tests are only valid of FDMA 2 */

/****************************************************************************
Name         : PESTransfer
Description  : Perform a single node PES/ES transfer and check the results.
Parameters   : PESData    : Process as PES or ES
               Input      : Input data
               sizeof(PESData)  : Size of input data
               Output     : Validated correct outputSTFDMA_DEVICE_ES_RANGE_0
               OutputSize : Size of output data
               SCEntries  : Number of generated SC entries
               Offset     : Initial offset in the ES buffer
Return Value :
****************************************************************************/
static void PESTransfer(int idx)
{
    ST_ErrorCode_t                   ErrorCode = ST_NO_ERROR;
    STFDMA_TransferGenericParams_t   TransferParams;
    STFDMA_InitParams_t              InitParams;
    STFDMA_GenericNode_t            *Node_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    U8                              *Buff_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    STFDMA_ContextId_t               Context[6];
    STFDMA_SCState_t                 State;

    STFDMA_SCEntry_t                *SCListEnd;
    U32                              Size;
    BOOL                             Overflow;
    void                            *ReadPtr;
    void                            *WritePtr;

    S32                              BuffSize;
    U32                              First;
    U32                              Second;

    U32                              ESBuffSize = 1024;

    static struct
    {
        BOOL  PESData;
        U8   *Input;
        U32   InputSize;
        U8   *Output;
        U32   OutputSize;
        U32   SCEntries;
        U32   Offset;
        int   HoldBack;
        char *Desc;
    }
    TestDefine[] =
    {
        {TRUE,  PESData, sizeof(PESData), ESData,  sizeof(PESData)-PES_HEADER_SIZE,  PES_SC_ENTRIES, 0, 6, "PES transfer of PES data"},
        {TRUE,  ESData,  sizeof(ESData),  ESData,  sizeof(ESData),  ES_SC_ENTRIES_2, 512+4, 4, "PES transfer of ES data"},
        {FALSE, PESData, sizeof(PESData), PESData, sizeof(PESData), ES_SC_ENTRIES,   516,   4, "ES transfer of PES data"},
        {FALSE, ESData,  sizeof(ESData),  ESData,  sizeof(ESData),  ES_SC_ENTRIES_2, 768,   4, "ES transfer of ES data"},
    };

    BOOL  PESData;
    U8   *Input;
    U32   InputSize;
    U8   *Output;
    U32   OutputSize;
    U32   SCEntries;
    U32   Offset;
    int   HoldBack;    /* The number of byte buffered in FDMA */

    STTBX_Print(("%s....\n", TestDefine[idx].Desc));

    /* Configure the test */

    PESData     = TestDefine[idx].PESData;
    Input       = TestDefine[idx].Input;
    InputSize   = TestDefine[idx].InputSize;
    Output      = TestDefine[idx].Output;
    OutputSize  = TestDefine[idx].OutputSize;
    SCEntries   = TestDefine[idx].SCEntries;
    Offset      = TestDefine[idx].Offset;
    HoldBack    = TestDefine[idx].HoldBack;

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_PES_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = FDMA_PES_BASE_ADDRESS;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_PES;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_PES);
#endif

    /* Allocate a Context */
    VERBOSE_PRINT("Allocate a Context, expect NO_ERROR\n");
    ErrorCode = STFDMA_AllocateContext(&Context[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Setup first tranfser nodes for Linear transfer\n");
    ErrorCode = fdmatst_CreatePESNode(Input, InputSize, Context[0], &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_CreateESBuffer(ESBuffSize, &Buff_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Configure the  Context, expect NO_ERROR\n");
#if defined (ST_OSLINUX)
    ErrorCode = STFDMA_ContextSetESBuffer(Context[0], (void*)fdmatst_GetBufferPhysicalAddressFromVirtual(Buff_p[0]), ESBuffSize);
#else
    ErrorCode = STFDMA_ContextSetESBuffer(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]), ESBuffSize);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    ErrorCode = STFDMA_ContextSetESReadPtr(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]+Offset));
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    ErrorCode = STFDMA_ContextSetESWritePtr(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]+Offset));
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX)
    ErrorCode = STFDMA_ContextSetSCList(Context[0], (void*)SCListPhysicalAddr, sizeof(SCList[0]));
#else
    ErrorCode = STFDMA_ContextSetSCList(Context[0], PERIPH_ADDR_TRANSLATE(SCList[0]), sizeof(SCList[0]));
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* PES start codes */
    State.RangeStart     = 0XBC;
    State.RangeEnd       = 0XFF;
    State.RangeEnabled   = PESData;
    State.PTSEnabled     = TRUE;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_PES_RANGE_0);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Picture start codes */
    State.RangeStart     = 0XB0;
    State.RangeEnd       = 0X00;
    State.OneShotEnabled = FALSE;
    State.RangeEnabled   = TRUE;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_ES_RANGE_0);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Slice start codes */
    State.RangeStart     = 0X01;
    State.RangeEnd       = 0XAF;
    State.OneShotEnabled = TRUE;
    State.RangeEnabled   = TRUE;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_ES_RANGE_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Start the PES Tranfer, expect NO_ERROR\n");
    TransferParams.ChannelId         = STFDMA_USE_ANY_CHANNEL;
    TransferParams.Pool              = STFDMA_PES_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    TransferParams.BlockingTimeout   = 0;
    TransferParams.CallbackFunction  = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock         = STFDMA_PES;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for endless, non-blocking transfer. Expect no error.\n");
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &PES1TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Wait until completion....\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        VERBOSE_PRINT("*** ERROR: Did not get complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Check the results\n");

    /* Verify ES buffer */
    ErrorCode = STFDMA_ContextGetESReadPtr(Context[0], &ReadPtr);
    ReadPtr = (void*)ST40_NOCACHE_NOTRANSLATE(ReadPtr);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    if (ReadPtr != Buff_p[0]+Offset)
    {
        VERBOSE_PRINT("*** ERROR: ES buffer read pointer has moved.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    ErrorCode = STFDMA_ContextGetESWritePtr(Context[0], &WritePtr, NULL);
    WritePtr = (void*)ST40_NOCACHE_NOTRANSLATE(WritePtr);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    BuffSize = ((U32)WritePtr - (U32)ReadPtr);
    if (BuffSize < 0) BuffSize += ESBuffSize;

    if (BuffSize != (OutputSize - HoldBack))
    {
        STTBX_Print(("*** ERROR: ES buffer write pointer is incorrect. [%d:%d]\n", BuffSize, OutputSize - HoldBack));
        fdmatst_SetSuccessState(FALSE);
    }

    BuffSize = MIN(BuffSize, (OutputSize - HoldBack));
    First    = MIN((ESBuffSize-Offset), BuffSize);
    Second   = BuffSize - First;

    if (memcmp(Output, Buff_p[0] + Offset, First))
    {
        STTBX_Print(("*** ERROR: ES buffer dump is incorrect. (0) %08X %d %d %d\n", (U32)Output, First, Second, OutputSize));
        fdmatst_SetSuccessState(FALSE);
    }

    if (memcmp(Output+First, Buff_p[0], Second))
    {
        STTBX_Print(("*** ERROR: ES buffer dump is incorrect. (1) %08X %d %d %d\n", (U32)Output, First, Second, OutputSize));
        fdmatst_SetSuccessState(FALSE);
    }

    /* Verify start code list */
    ErrorCode = STFDMA_ContextGetSCList(Context[0], &SCListEnd, &Size, &Overflow);
    SCListEnd = (STFDMA_SCEntry_t*)ST40_NOCACHE_NOTRANSLATE(SCListEnd);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    if ((SCList[0] +SCEntries) != SCListEnd)
    {
        STTBX_Print(("*** ERROR: SC List write pointer is incorrect. %08X[%08X]\n", (U32)SCListEnd, (U32)(SCList[0] +SCEntries)));
#if defined(DEBUG)
        DebugSCList((U32)(Buff_p[0] + Offset), SCList[0], SCListEnd - SCList[0]);
#endif
        fdmatst_SetSuccessState(FALSE);
    }

    if (Size != (SC_LIST_MAX-SCEntries)*sizeof(SCListEnd[0]))
    {
        STTBX_Print(("*** ERROR: SC List remaining size is wrong. %d[%d]\n", Size, (SC_LIST_MAX-SCEntries)*sizeof(SCListEnd[0])));
        fdmatst_SetSuccessState(FALSE);
    }

    if (Overflow)
    {
        VERBOSE_PRINT("*** ERROR: Unexpected SC List overflow.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_PES);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer id */
    PES1TransferId = 0;
}

/****************************************************************************
Name         : PESMultiTransfer
Description  : Perform a Multiple PES/ES transfer and check the results.
Parameters   :
Return Value :
****************************************************************************/
static void PESMultiTransfer(BOOL PESData, U8 *Input, U32 InputSize, U8 *Output, U32 OutputSize, U32 SCEntries, int HoldBack, STFDMA_SCResult_t *SCResult)
{
    ST_ErrorCode_t                   ErrorCode = ST_NO_ERROR;
    STFDMA_TransferGenericParams_t   TransferParams;
    STFDMA_InitParams_t              InitParams;
    STFDMA_GenericNode_t            *Node_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    U8                              *Buff_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    STFDMA_ContextId_t               Context[6];
    STFDMA_SCState_t                 State;

    STFDMA_SCEntry_t                *SCListEnd;
    U32                              Size;
    BOOL                             Overflow;
    void                            *ReadPtr;
    void                            *WritePtr;

    int                              ESBufferSize = 1024;
    int i;

    /* First check a transfer can run to completion while a circular in progress..*/

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_PES_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = FDMA_PES_BASE_ADDRESS;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_PES;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_PES);
#endif

    /* Allocate a Context */
    VERBOSE_PRINT("Allocate a Context, expect NO_ERROR\n");
    ErrorCode = STFDMA_AllocateContext(&Context[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = STFDMA_AllocateContext(&Context[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Setup tranfser nodes for Linear transfer\n");

    ErrorCode = fdmatst_CreatePESNode(Input+128, InputSize-128, Context[0], &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_7109)  || defined (ST_7200) || defined (ST_5162) 
    ErrorCode = fdmatst_CreatePESNode(Input+128, InputSize-128, Context[1], &Node_p[0]);
#else
    ErrorCode = fdmatst_CreatePESNode(Input+256, InputSize-256, Context[1], &Node_p[0]);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_7109) || defined (ST_7200)  || defined (ST_5162)
    ErrorCode = fdmatst_CreatePESNode(Input,     128,           Context[1], &Node_p[0]);
#else
    ErrorCode = fdmatst_CreatePESNode(Input,     256,           Context[1], &Node_p[0]);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_CreatePESNode(Input,     128,           Context[0], &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_CreateESBuffer(ESBufferSize, &Buff_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_CreateESBuffer(ESBufferSize, &Buff_p[1]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Configure the  Context, expect NO_ERROR\n");

    for (i = 0; (i < 2); i++)
    {
#if defined (ST_OSLINUX)
        ErrorCode = STFDMA_ContextSetESBuffer(Context[i], (void*)fdmatst_GetBufferPhysicalAddressFromVirtual(Buff_p[i]), ESBufferSize);
#else
        ErrorCode = STFDMA_ContextSetESBuffer(Context[i], PERIPH_ADDR_TRANSLATE(Buff_p[i]), ESBufferSize);
#endif
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);


#if defined (ST_OSLINUX)
        ErrorCode = STFDMA_ContextSetSCList(Context[i], (void*)SCListPhysicalAddr + (i * sizeof(SCList[0])), sizeof(SCList[0]));
#else
        ErrorCode = STFDMA_ContextSetSCList(Context[i], PERIPH_ADDR_TRANSLATE(SCList[i]), sizeof(SCList[0]));
#endif
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* PES start codes */
        State.RangeEnabled   = PESData;
        State.PTSEnabled     = TRUE;
        State.OneShotEnabled = FALSE;
        State.RangeStart     = 0XBC;
        State.RangeEnd       = 0XFF;
        ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_PES_RANGE_0);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* Picture start codes */
        State.RangeEnabled   = TRUE;
        State.RangeStart     = 0XB0;
        State.RangeEnd       = 0X00;
        ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_ES_RANGE_0);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* Slice start codes */
        State.RangeEnabled   = TRUE;
        State.OneShotEnabled = TRUE;
        State.RangeStart     = 0X01;
        State.RangeEnd       = 0XAF;

        ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_ES_RANGE_1);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    VERBOSE_PRINT("Start the PES Tranfer, expect NO_ERROR\n");
    TransferParams.ChannelId         = STFDMA_USE_ANY_CHANNEL;
    TransferParams.Pool              = STFDMA_PES_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    TransferParams.BlockingTimeout   = 0;
    TransferParams.CallbackFunction  = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_PES;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for endless, non-blocking transfer. Expect no error.\n");
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &PES1TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Wait until completion....\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        VERBOSE_PRINT("*** ERROR: Did not get complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Check the results\n");

    for (i = 0; (i < 2); i++)
    {
        /* Verify ES buffer */
        ErrorCode = STFDMA_ContextGetESReadPtr(Context[i], &ReadPtr);
        ReadPtr = (void*)ST40_NOCACHE_NOTRANSLATE(ReadPtr);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        if (ReadPtr != Buff_p[i])
        {
            VERBOSE_PRINT("*** ERROR: ES buffer read pointer has moved.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        ErrorCode = STFDMA_ContextGetESWritePtr(Context[i], &WritePtr, NULL);
        WritePtr = (void*)ST40_NOCACHE_NOTRANSLATE(WritePtr);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        if (((U32)WritePtr - (U32)ReadPtr) != (OutputSize - HoldBack))
        {
            VERBOSE_PRINT("*** ERROR: ES buffer write pointer is incorrect.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        if (memcmp(Output, Buff_p[i], (OutputSize - HoldBack)))
        {
            VERBOSE_PRINT("*** ERROR: ES buffer dump is incorrect.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        /* Verify start code list */
        ErrorCode = STFDMA_ContextGetSCList(Context[i], &SCListEnd, &Size, &Overflow);
        SCListEnd = (STFDMA_SCEntry_t*)ST40_NOCACHE_NOTRANSLATE(SCListEnd);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        if ((SCList[i] +SCEntries) != SCListEnd)
        {
            STTBX_Print(("*** ERROR: SC List write pointer is incorrect. %d[%d]\n", SCListEnd-SCList[i], SCEntries));
            fdmatst_SetSuccessState(FALSE);
        }

        if (Size != (SC_LIST_MAX-SCEntries)*sizeof(*SCListEnd))
        {
            VERBOSE_PRINT("*** ERROR: SC List remaining size is wrong.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        if (SCCompare((U32)Buff_p[i], SCResult, SCList[i], SCListEnd - SCList[i]))
        {
            VERBOSE_PRINT("*** ERROR: SC List entry is wrong.\n");
#if defined(DEBUG)
            DebugSCList((U32)Buff_p[i], SCList[i], SCListEnd - SCList[i]);
#endif
            fdmatst_SetSuccessState(FALSE);
        }

        if (Overflow)
        {
            VERBOSE_PRINT("*** ERROR: Unexpected SC List overflow.\n");
            fdmatst_SetSuccessState(FALSE);
        }
    }

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_PES);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer id */
    PES1TransferId = 0;
}

/****************************************************************************
Name         : CaseF218
Description  : Tests successive transfers using the same Context.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF218(int arg)
{
    STTBX_Print(("Checking for multiple interleaved transfers...\n\n"));
    VERBOSE_PRINT("1) ...\n");
    PESMultiTransfer(TRUE,  PESData, sizeof(PESData), ESData,  sizeof(PESData)-PES_HEADER_SIZE,  PES_SC_ENTRIES, 6, PESasPES);
    VERBOSE_PRINT("2) ...\n");
    PESMultiTransfer(TRUE,  ESData,  sizeof(ESData),  ESData,  sizeof(ESData),  ES_SC_ENTRIES_2, 4, ESasPES);
    VERBOSE_PRINT("3) ...\n");
    PESMultiTransfer(FALSE, PESData, sizeof(PESData), PESData, sizeof(PESData), ES_SC_ENTRIES,   4, PESasES);
    VERBOSE_PRINT("4) ...\n");
    PESMultiTransfer(FALSE, ESData,  sizeof(ESData),  ESData,  sizeof(ESData),  ES_SC_ENTRIES_2, 4, ESasES);
}

/****************************************************************************
Name         : CaseF221
Description  : Tests ES Buffer overflow and SC List Overflow.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF221(int arg)
{
    ST_ErrorCode_t                   ErrorCode = ST_NO_ERROR;
    STFDMA_TransferGenericParams_t   TransferParams;
    STFDMA_InitParams_t              InitParams;
    STFDMA_GenericNode_t            *Node_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    U8                              *Buff_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    STFDMA_ContextId_t               Context[6];
    STFDMA_SCState_t                 State;

    STFDMA_SCEntry_t                *SCListEnd;
    U32                              Size;
    BOOL                             Overflow;
    void                            *ReadPtr;
    void                            *WritePtr;

    S32                              BuffSize;
    U32                              First;
    U32                              Second;

    U32                              OutputSize = sizeof(PESData) -PES_HEADER_SIZE;
    U32                              ESBuffSize = (OutputSize -32)&~31;
    int                              HoldBack = 6;       /* The number of byte buffered in FDMA */

    STTBX_Print(("Checking for the reporting of overflow conditions...\n\n"));

    /* First check a transfer can run to completion while a circular in progress..*/

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_PES_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = FDMA_PES_BASE_ADDRESS;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_PES;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_PES);
#endif

    /* Allocate a Context */
    VERBOSE_PRINT("Allocate a Context, expect NO_ERROR\n");
    ErrorCode = STFDMA_AllocateContext(&Context[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Setup first tranfser nodes for Linear transfer\n");
    ErrorCode = fdmatst_CreatePESNode(PESData, sizeof(PESData), Context[0], &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    ErrorCode = fdmatst_CreateESBuffer(ESBuffSize, &Buff_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Configure the  Context, expect NO_ERROR\n");
#if defined (ST_OSLINUX)
    ErrorCode = STFDMA_ContextSetESBuffer(Context[0], (void*)fdmatst_GetBufferPhysicalAddressFromVirtual(Buff_p[0]), ESBuffSize);
#else
    ErrorCode = STFDMA_ContextSetESBuffer(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]), ESBuffSize);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX)
    ErrorCode = STFDMA_ContextSetSCList(Context[0], (void*)SCListPhysicalAddr, 4 * sizeof(SCList[0][0]));
#else
    ErrorCode = STFDMA_ContextSetSCList(Context[0], PERIPH_ADDR_TRANSLATE(SCList[0]), 4*sizeof(SCList[0][0]));
#endif

    memset(SCList[0], 0, sizeof(SCList[0]));

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    State.RangeEnabled   = TRUE;
    State.PTSEnabled     = TRUE;
    State.OneShotEnabled = FALSE;

    /* PES start codes */
    State.RangeStart     = 0XBC;
    State.RangeEnd       = 0XFF;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_PES_RANGE_0);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Picture start codes */
    State.RangeStart     = 0XB0;
    State.RangeEnd       = 0X00;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_ES_RANGE_0);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Slice start codes */
    State.RangeStart     = 0X01;
    State.RangeEnd       = 0XAF;
    State.OneShotEnabled = TRUE;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_ES_RANGE_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);


    VERBOSE_PRINT("Start the PES Tranfer, expect NO_ERROR\n");
    TransferParams.ChannelId         = STFDMA_USE_ANY_CHANNEL;
    TransferParams.Pool              = STFDMA_PES_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    TransferParams.BlockingTimeout   = 0;
    TransferParams.CallbackFunction  = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_PES;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for endless, non-blocking transfer. Expect no error.\n");
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &F221TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Wait until completion....\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        VERBOSE_PRINT("*** ERROR: Did not get complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Check the results\n");

    /* Verify ES buffer */
    ErrorCode = STFDMA_ContextGetESReadPtr(Context[0], &ReadPtr);
    ReadPtr = (void*)ST40_NOCACHE_NOTRANSLATE(ReadPtr);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    if (ReadPtr != Buff_p[0])
    {
        VERBOSE_PRINT("*** ERROR: ES buffer read pointer has moved.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    Overflow = FALSE;
    ErrorCode = STFDMA_ContextGetESWritePtr(Context[0], &WritePtr, &Overflow);
    WritePtr = (void*)ST40_NOCACHE_NOTRANSLATE(WritePtr);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if 0 /* ES Buffer overflow reporting is not supported */
    if (!Overflow)
    {
        VERBOSE_PRINT("*** ERROR: ES buffer overflow not reported.\n");
        fdmatst_SetSuccessState(FALSE);
    }
#endif

    BuffSize = ((U32)WritePtr - (U32)ReadPtr);
    if (BuffSize < 0) BuffSize += ESBuffSize;

    if (BuffSize != (OutputSize - HoldBack - ESBuffSize))
    {
        VERBOSE_PRINT("*** ERROR: ES buffer write pointer is incorrect.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    Second = (OutputSize - HoldBack - ESBuffSize);
    First  = ESBuffSize - Second;

    if (memcmp(ESData +Second, Buff_p[0] +Second, First))
    {
        VERBOSE_PRINT("*** ERROR: ES buffer dump is incorrect.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    if (memcmp(ESData +ESBuffSize, Buff_p[0], Second))
    {
        VERBOSE_PRINT("*** ERROR: ES buffer dump is incorrect.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    /* Verify start code list */
    Overflow = FALSE;
    ErrorCode = STFDMA_ContextGetSCList(Context[0], &SCListEnd, &Size, &Overflow);
    SCListEnd = (STFDMA_SCEntry_t*)ST40_NOCACHE_NOTRANSLATE(SCListEnd);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    if ((SCList[0] +4) != SCListEnd)
    {
        VERBOSE_PRINT("*** ERROR: SC List write pointer is incorrect.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    if (Size != 0)
    {
        VERBOSE_PRINT("*** ERROR: SC List remaining size is wrong.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    if (!Overflow)
    {
        VERBOSE_PRINT("*** ERROR: Expected SC List overflow.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    if (SCList[0][4].SC.Addr != (void*)0)
    {
        VERBOSE_PRINT("*** ERROR: FDMA has run off the end of the list.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_PES);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer id */
    F221TransferId = 0;
}

/* No SPDIF on 7710 */
#if !defined (ST_7710) && !defined (STFDMA_NO_PACED_TESTS)
/****************************************************************************
Name         : SPDIFTransfer
Description  : Perform a single node SPDIF transfer and check the results.
Parameters   :
Return Value :
****************************************************************************/
static void SPDIFTransfer(U8 *Input, U32 InputSize, U8 *Output, U32 OutputSize, BOOL BurstEnd, BOOL InvalidNode)
{
    ST_ErrorCode_t                   ErrorCode = ST_NO_ERROR;
    STFDMA_TransferGenericParams_t   TransferParams;
    STFDMA_InitParams_t              InitParams;
    STFDMA_GenericNode_t            *Node_p = NULL;
    U8                              *CDFIFO;
    U8                              *CDFIFO2;
    U32                              PadChannel0;
    U32                              PadChannel1;
    int                              i;

    /* First check a transfer can run to completion while a circular in progress..*/

        /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setup first tranfser nodes for Linear transfer\n");
    if (InvalidNode)
    {
        /* Put an invalid node on the end of the list */
        ErrorCode = fdmatst_CreateSPDIFNode(Input, InputSize, &CDFIFO2, BurstEnd, FALSE, &Node_p);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    }

    ErrorCode = fdmatst_CreateSPDIFNode(Input, InputSize, &CDFIFO, BurstEnd, TRUE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Set the CDFIFO to write an increment mode */
    stfdma_ReqSetWrite(FDMA_TEST_ACTIVE_DREQ);
    stfdma_ReqSetIncrement(FDMA_TEST_ACTIVE_DREQ, TRUE);

    VERBOSE_PRINT("Init and Start pace request signal generator\n");

    fdmatst_InitPaceRequestGenerator((STFDMA_Node_t*)Node_p, 10 /*DEFAULT_RATE*/);
    fdmatst_StartPaceRequestGenerator();

    VERBOSE_PRINT("Start the SPDIF Transfer, expect NO_ERROR\n");

    TransferParams.ChannelId         = STFDMA_USE_ANY_CHANNEL;
    TransferParams.Pool              = STFDMA_SPDIF_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.BlockingTimeout   = 0;
    TransferParams.CallbackFunction  = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for endless, non-blocking transfer. Expect no error.\n");
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &SPDIFTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Wait until completion....\n");
    WaitTime = (STOS_time_plus(time_now(),(20 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        VERBOSE_PRINT("*** ERROR: Did not get complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Terminating pace request signal generator\n");
    fdmatst_TermPaceRequestGenerator();

    VERBOSE_PRINT("Check the results\n");

    /* Check the output */
    if (memcmp(Output, CDFIFO, OutputSize))
    {
        VERBOSE_PRINT("*** ERROR: SPDIF output is incorrect.\n");
        fdmatst_SetSuccessState(FALSE);
#if defined(DEBUG)
        DebugDump32((U32*)Output, (U32*)CDFIFO, OutputSize);
#endif
    }

    if (BurstEnd || (Node_p->Gen.Next_p == NULL))
    {
        PadChannel0 = 0X0000000F;
        PadChannel1 = 0X0000000F;
    }
    else
    {
        PadChannel0 = 0;
        PadChannel1 = 0;
    }

    /* Check the stuffing at the end of the buffer */
    for (i = OutputSize/(2*sizeof(U32)); (i < SPDIF_BURST_SIZE); i++)
    {
        if ((((U32*)CDFIFO)[2*i+0] != (((U32*)Output)[2*i+0]&PadChannel0)) ||
            (((U32*)CDFIFO)[2*i+1] != (((U32*)Output)[2*i+1]&PadChannel1)))
        {
            STTBX_Print(("*** ERROR: SPDIF padding is incorrect. [%i] %08X<%08X> %08X<%08X>\n",
                    i, ((U32*)CDFIFO)[2*i+0], ((U32*)Output)[2*i+0]&PadChannel0,
                       ((U32*)CDFIFO)[2*i+1], ((U32*)Output)[2*i+1]&PadChannel1));
            fdmatst_SetSuccessState(FALSE);
            i = SPDIF_BURST_SIZE+1;
        }
    }

    /* Check for overrun */
    if ((((U32*)CDFIFO)[2*SPDIF_BURST_SIZE +0] != 0) ||
        (((U32*)CDFIFO)[2*SPDIF_BURST_SIZE +1] != 0))
    {
        VERBOSE_PRINT("*** ERROR: SPDIF buffer overrun.\n");
#if defined(DEBUG)
        DebugDump32((U32*)Output, ((U32*)CDFIFO)+2*SPDIF_BURST_SIZE, 2*2*sizeof(U32));
#endif
        fdmatst_SetSuccessState(FALSE);
    }

    /* Check output from Invalid node */
    if (InvalidNode)
    {
        CDFIFO2 -= OutputSize;
        for (i = OutputSize/(2*sizeof(U32)); (i < SPDIF_BURST_SIZE); i++)
        {
            if ((((U32*)CDFIFO2)[2*i+0] != (((U32*)Output)[2*i+0]&0X0000000F)) ||
                (((U32*)CDFIFO2)[2*i+1] != (((U32*)Output)[2*i+1]&0X0000000F)))
            {
                STTBX_Print(("*** ERROR: Output on invalid node is incorrect. [%i] %08X<%08X> %08X<%08X>\n",
                        i, ((U32*)CDFIFO2)[2*i+0], ((U32*)Output)[2*i+0]&0X0000000F,
                           ((U32*)CDFIFO2)[2*i+1], ((U32*)Output)[2*i+1]&0X0000000F));
#if defined(DEBUG)
                DebugDump32((U32*)Output, (U32*)CDFIFO2, SPDIF_BURST_SIZE*2*sizeof(U32));
#endif
                fdmatst_SetSuccessState(FALSE);
                i = SPDIF_BURST_SIZE+1;
            }
        }
    }

    /* Set the CDFIFO to back to read and no increment mode */
    stfdma_ReqSetRead(FDMA_TEST_ACTIVE_DREQ);
    stfdma_ReqSetIncrement(FDMA_TEST_ACTIVE_DREQ, FALSE);

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer id */
    SPDIFTransferId = 0;
}

/****************************************************************************
Name         : CaseF230
Description  : Tests SPDIF Transfers.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF230(int arg)
{
    STTBX_Print(("Checking for simple SPDIF Transfers (not end of burst) ...\n\n"));

    SPDIFTransfer((U8*)SPDIFData, 16*2*sizeof(U16), (U8*)CDFIFOData, (16+2)*2*sizeof(U32), FALSE, FALSE);
}

/****************************************************************************
Name         : CaseF231
Description  : Tests SPDIF Transfers.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF231(int arg)
{
    STTBX_Print(("Checking for end of burst SPDIF Transfers (Incomplete burst) ...\n\n"));

    SPDIFTransfer((U8*)SPDIFData, 16*2*sizeof(U16), (U8*)CDFIFOData, (16+2)*2*sizeof(U32), TRUE, FALSE);
}

/****************************************************************************
Name         : CaseF232
Description  : Tests SPDIF Transfers. One full audio frame.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF232(int arg)
{
    STTBX_Print(("Checking for SPDIF Transfers (Complete burst) ...\n\n"));

    SPDIFTransfer((U8*)SPDIFData, sizeof(SPDIFData), (U8*)CDFIFOData,  sizeof(CDFIFOData), TRUE, FALSE);
}

/****************************************************************************
Name         : CaseF233
Description  : Tests SPDIF Transfers with invalid node.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF233(int arg)
{
    STTBX_Print(("Checking for SPDIF Transfers (Invalid Node) ...\n\n"));

    SPDIFTransfer((U8*)SPDIFData, sizeof(SPDIFData), (U8*)CDFIFOData,  sizeof(CDFIFOData), TRUE, TRUE);
}

/****************************************************************************
Name         : CaseF234
Description  : Tests SPDIF Transfers with invalid node.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF234(int arg)
{
    STTBX_Print(("Checking for SPDIF Transfers (Invalid Node) ...\n\n"));

    SPDIFTransfer((U8*)SPDIFData, 16*2*sizeof(U16), (U8*)CDFIFOData,  (16+2)*2*sizeof(U32), FALSE, TRUE);
}

/****************************************************************************
Name         : CaseF235
Description  : Tests SPDIF Transfers with invalid node.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF235(int arg)
{
    STTBX_Print(("Checking for SPDIF Transfers (Invalid Node) ...\n\n"));

    SPDIFTransfer((U8*)SPDIFData, sizeof(SPDIFData), (U8*)CDFIFOData,  sizeof(CDFIFOData), FALSE, TRUE);
}
#endif /* !defined (ST_7710) */
#endif /* FDMA 2 ONLY */

#if defined (ST_7100) || defined (ST_7109) || defined (ST_7200)
/****************************************************************************
Name         : H264Transfer
Description  : Perform a single node PES/ES transfer and check the results.
Parameters   : PESData    : Process as PES or ES
               Input      : Input data
               sizeof(PESData)  : Size of input data
               Output     : Validated correct outputSTFDMA_DEVICE_ES_RANGE_0
               OutputSize : Size of output data
               SCEntries  : Number of generated SC entries
               Offset     : Initial offset in the ES buffer
Return Value :
****************************************************************************/
static void H264Transfer(int idx)
{
    ST_ErrorCode_t                   ErrorCode = ST_NO_ERROR;
    STFDMA_TransferGenericParams_t   TransferParams;
    STFDMA_InitParams_t              InitParams;
    STFDMA_GenericNode_t            *Node_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    U8                              *Buff_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    STFDMA_ContextId_t               Context[6];
    STFDMA_SCState_t                 State;

    STFDMA_SCEntry_t                *SCListEnd;
    U32                              Size;
    BOOL                             Overflow;
    void                            *ReadPtr;
    void                            *WritePtr;

    S32                              BuffSize;
    U32                              First;
    U32                              Second;

    U32                              ESBuffSize = 8192;
    static struct
    {
        BOOL  PESData;
        U8   *Input;
        U32   InputSize;
        U8   *Output;
        U32   OutputSize;
        U32   SCEntries;
        U32   Offset;
        int   HoldBack;
        char *Desc;
    }
    TestDefine[] =
    {
        {FALSE, H264ESData,  sizeof(H264ESData),  H264ESData,  sizeof(H264ESData),  H264_ES_SC_ENTRIES, 0, 4, "ES transfer of H264 ES data"},
    };

    BOOL  PESData;
    U8   *Input;
    U32   InputSize;
    U8   *Output;
    U32   OutputSize;
    int   HoldBack;    /* The number of byte buffered in FDMA */

    U32   SCEntries;
    U32   Offset;

    STTBX_Print(("%s....\n", TestDefine[idx].Desc));

    /* Configure the test */

    PESData    = TestDefine[idx].PESData;
    Input      = TestDefine[idx].Input;
    InputSize  = TestDefine[idx].InputSize;
    Output     = TestDefine[idx].Output;
    OutputSize = TestDefine[idx].OutputSize;
    HoldBack   = TestDefine[idx].HoldBack;
    SCEntries  = TestDefine[idx].SCEntries;
    Offset     = TestDefine[idx].Offset;

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_PES_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = FDMA_PES_BASE_ADDRESS;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_PES;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_PES);
#endif

    /* Allocate a Context */
    VERBOSE_PRINT("Allocate a Context, expect NO_ERROR\n");
    ErrorCode = STFDMA_AllocateContext(&Context[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Setup first tranfser nodes for Linear transfer\n");
    ErrorCode = fdmatst_CreatePESNode(Input, InputSize, Context[0], &Node_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_7109) || defined (ST_7200) || defined (ST_5525)
    Node_p[0]->ContextNode.Secure   = 0;
#endif

    ErrorCode = fdmatst_CreateESBuffer(ESBuffSize, &Buff_p[0]);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Configure the  Context, expect NO_ERROR\n");
#if defined (ST_OSLINUX)
    ErrorCode = STFDMA_ContextSetESBuffer(Context[0], (void*)fdmatst_GetBufferPhysicalAddressFromVirtual(Buff_p[0]), ESBuffSize);
#else
    ErrorCode = STFDMA_ContextSetESBuffer(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]), ESBuffSize);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    ErrorCode = STFDMA_ContextSetESReadPtr(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]+Offset));
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    ErrorCode = STFDMA_ContextSetESWritePtr(Context[0], PERIPH_ADDR_TRANSLATE(Buff_p[0]+Offset));
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX)
    ErrorCode = STFDMA_ContextSetSCList(Context[0], (void*)SCListPhysicalAddr, sizeof(SCList[0]));
#else
    ErrorCode = STFDMA_ContextSetSCList(Context[0], PERIPH_ADDR_TRANSLATE(SCList[0]), sizeof(SCList[0]));
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* PES start codes */
    State.RangeStart     = 0XBC;
    State.RangeEnd       = 0XFF;
    State.PTSEnabled     = TRUE;
    State.RangeEnabled   = PESData;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_PES_RANGE_0);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Picture start codes */
    State.RangeStart     = 0X01;
/*    State.RangeEnd       = 0XBB;*/
    State.RangeEnd       = 0XAF;
    State.OneShotEnabled = FALSE;
    State.RangeEnabled   = TRUE;
    ErrorCode = STFDMA_ContextSetSCState(Context[0], &State, STFDMA_DEVICE_H264_RANGE_0);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Start the PES Tranfer, expect NO_ERROR\n");
    TransferParams.ChannelId         = STFDMA_USE_ANY_CHANNEL;
    TransferParams.Pool              = STFDMA_PES_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    TransferParams.BlockingTimeout   = 0;
    TransferParams.CallbackFunction  = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_PES;
    VERBOSE_PRINT("Calling STFDMA_StartTransfer for endless, non-blocking transfer. Expect no error.\n");
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &PES1TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Wait until completion....\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        VERBOSE_PRINT("*** ERROR: Did not get complete notification within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Check the results\n");
    /* Verify ES buffer */
    ErrorCode = STFDMA_ContextGetESReadPtr(Context[0], &ReadPtr);
    ReadPtr = (void*)ST40_NOCACHE_NOTRANSLATE(ReadPtr);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    if (ReadPtr != Buff_p[0]+Offset)
    {
        VERBOSE_PRINT("*** ERROR: ES buffer read pointer has moved.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    ErrorCode = STFDMA_ContextGetESWritePtr(Context[0], &WritePtr, NULL);
    WritePtr = (void*)ST40_NOCACHE_NOTRANSLATE(WritePtr);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    BuffSize = ((U32)WritePtr - (U32)ReadPtr);
    if (BuffSize < 0) BuffSize += ESBuffSize;

    if (BuffSize != (OutputSize - HoldBack))
    {
        STTBX_Print(("*** ERROR: ES buffer write pointer is incorrect. [%d:%d]\n", BuffSize, OutputSize - HoldBack));
        fdmatst_SetSuccessState(FALSE);
    }

    BuffSize = MIN(BuffSize, (OutputSize - HoldBack));
    First    = MIN((ESBuffSize-Offset), BuffSize);
    Second   = BuffSize - First;

    if (memcmp(Output, Buff_p[0] +Offset, First))
    {
        STTBX_Print(("*** ERROR: ES buffer PES output is incorrect. (0) %08X %d %d %d\n", (U32)Output, First, Second, OutputSize));
        fdmatst_SetSuccessState(FALSE);
    }

    if (memcmp(Output+First, Buff_p[0], Second))
    {
        STTBX_Print(("*** ERROR: ES buffer PES output is incorrect. (1) %08X %d %d %d\n", (U32)Output, First, Second, OutputSize));
        fdmatst_SetSuccessState(FALSE);
    }

    /* Verify start code list */
    ErrorCode = STFDMA_ContextGetSCList(Context[0], &SCListEnd, &Size, &Overflow);
    SCListEnd = (STFDMA_SCEntry_t*)ST40_NOCACHE_NOTRANSLATE(SCListEnd);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    if ((SCList[0] +SCEntries) != SCListEnd)
    {
        STTBX_Print(("*** ERROR: SC List write pointer is incorrect. %08X[%08X]\n", (U32)SCListEnd, (U32)(SCList[0] +SCEntries)));
#if defined(DEBUG)
        DebugSCList((U32)(Buff_p[0] + Offset), SCList[0], SCListEnd - SCList[0]);
#endif
        fdmatst_SetSuccessState(FALSE);
    }

    if (Size != (SC_LIST_MAX-SCEntries)*sizeof(SCListEnd[0]))
    {
        STTBX_Print(("*** ERROR: SC List remaining size is wrong. %d[%d]\n", Size, (SC_LIST_MAX-SCEntries)*sizeof(SCListEnd[0])));
        fdmatst_SetSuccessState(FALSE);
    }

    if (SCCompare((U32)Buff_p[0], H264asES, SCList[0], SCListEnd - SCList[0]))
    {
        VERBOSE_PRINT("*** ERROR: SC List entry is wrong.\n");
#if defined(DEBUG)
        DebugSCList((U32)Buff_p[0], SCList[0], SCListEnd - SCList[0]);
#endif
        fdmatst_SetSuccessState(FALSE);
    }

    if (Overflow)
    {
        VERBOSE_PRINT("*** ERROR: Unexpected SC List overflow.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_PES);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer id */
    PES1TransferId = 0;
}
#endif

#if defined (ST_7200)
/****************************************************************************
Name         : MultiPESTransfer
Description  :
Parameters   :
Return Value :
****************************************************************************/
static void MultiPESTransfer(int idx)
{
    int i;

    ST_ErrorCode_t                  ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t             InitParams;
    STFDMA_TransferGenericParams_t  TransferParams;
    STFDMA_ChannelId_t              PESChannel[2];
    STFDMA_SCState_t                State;
    STFDMA_ContextId_t              Context[6];
    STFDMA_GenericNode_t           *Node_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};

    U32                             ESBuffSize = 8192;
    U8                             *Buff_p[6] = {NULL, NULL, NULL, NULL, NULL, NULL};
    void                           *ReadPtr;
    void                           *WritePtr;
    S32                             BuffSize;
    U32                             First;
    U32                             Second;
    STFDMA_SCEntry_t               *SCListEnd;
    U32                             Size;
    BOOL                            Overflow;



    static struct
    {
        BOOL                PESData;
        U8                 *Input;
        U32                 InputSize;
        U8                 *Output;
        U32                 OutputSize;
        STFDMA_SCResult_t  *SCResult;
        U32                 SCEntries;
        U32                 Offset;
        int                 HoldBack;
        char               *Desc;
    }
    TestDefine[] =
    {
        {TRUE,  PESData,    sizeof(PESData),    ESData,     sizeof(PESData)-PES_HEADER_SIZE, PESasPES,  PES_SC_ENTRIES, 0, 6, "PES transfer of MPEG PES data"},
        {FALSE, H264ESData, sizeof(H264ESData), H264ESData, sizeof(H264ESData), H264asES, H264_ES_SC_ENTRIES, 0, 4, "ES transfer of H264 ES data"},
    };

    STTBX_Print(("\nTesting simultaneous use of multiple PES channels...\n"));

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_PES_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = FDMA_PES_BASE_ADDRESS;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_PES;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_PES);
#endif

    for(i = 0; i < 2; i++)
    {
        ErrorCode = STFDMA_LockChannelInPool(STFDMA_PES_POOL, &PESChannel[i], STFDMA_PES);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* Allocate a Context */
        VERBOSE_PRINT("Allocate a Context, expect NO_ERROR\n");
        ErrorCode = STFDMA_AllocateContext(&Context[i]);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        ErrorCode = fdmatst_CreatePESNode(TestDefine[i].Input + 128, TestDefine[i].InputSize - 128, Context[i], &Node_p[i]);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_7109) || defined (ST_7200) || defined (ST_5525)
        Node_p[i]->ContextNode.Secure   = 0;
#endif

        ErrorCode = fdmatst_CreatePESNode(TestDefine[i].Input, 128, Context[i], &Node_p[i]);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* To make sure the two transfers are running simultaneously */
        Node_p[i]->ContextNode.NodeCompleteNotify = TRUE;
        Node_p[i]->ContextNode.NodeCompletePause  = TRUE;
#if defined (ST_7109) || defined (ST_7200) || defined (ST_5525)
        Node_p[i]->ContextNode.Secure   = 0;
#endif

        ErrorCode = fdmatst_CreateESBuffer(ESBuffSize, &Buff_p[i]);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        VERBOSE_PRINT("Configure the  Context, expect NO_ERROR\n");
#if defined (ST_OSLINUX)
        ErrorCode = STFDMA_ContextSetESBuffer(Context[i], (void*)fdmatst_GetBufferPhysicalAddressFromVirtual(Buff_p[i]), ESBuffSize);
#else
        ErrorCode = STFDMA_ContextSetESBuffer(Context[i], PERIPH_ADDR_TRANSLATE(Buff_p[i]), ESBuffSize);
#endif
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        ErrorCode = STFDMA_ContextSetESReadPtr(Context[i], PERIPH_ADDR_TRANSLATE(Buff_p[i] + TestDefine[i].Offset));
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        ErrorCode = STFDMA_ContextSetESWritePtr(Context[i], PERIPH_ADDR_TRANSLATE(Buff_p[i] + TestDefine[i].Offset));
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX)
        ErrorCode = STFDMA_ContextSetSCList(Context[i], (void*)SCListPhysicalAddr + (i * sizeof(SCList[0])), sizeof(SCList[i]));
#else
        ErrorCode = STFDMA_ContextSetSCList(Context[i], PERIPH_ADDR_TRANSLATE(SCList[i]), sizeof(SCList[i]));
#endif
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* PES start codes */
        State.RangeStart     = 0XBC;
        State.RangeEnd       = 0XFF;
        State.RangeEnabled   = TestDefine[i].PESData;
        State.PTSEnabled     = TRUE;
        State.OneShotEnabled = FALSE;
        ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_PES_RANGE_0);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        if(i == 0)
        {
            /* Picture start codes */
            State.RangeEnabled   = TRUE;
            State.RangeStart     = 0XB0;
            State.RangeEnd       = 0X00;
            ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_ES_RANGE_0);
            fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

            /* Slice start codes */
            State.RangeEnabled   = TRUE;
            State.OneShotEnabled = TRUE;
            State.RangeStart     = 0X01;
            State.RangeEnd       = 0XAF;
            ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_ES_RANGE_1);
            fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        }
        else
        {
            /* Picture start codes */
            State.RangeStart     = 0X01;
/*          State.RangeEnd       = 0XBB;*/
            State.RangeEnd       = 0XAF;
            State.OneShotEnabled = FALSE;
            State.RangeEnabled   = TRUE;
            ErrorCode = STFDMA_ContextSetSCState(Context[i], &State, STFDMA_DEVICE_H264_RANGE_0);
            fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        }
    }

    VERBOSE_PRINT("Start the PES Tranfer, expect NO_ERROR\n");
    TransferParams.ChannelId         = PESChannel[0];
    TransferParams.Pool              = STFDMA_PES_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[0]);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[0]);
    TransferParams.BlockingTimeout   = 0;
    TransferParams.CallbackFunction  = Callback;
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock         = STFDMA_PES;
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &PES1TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    TransferParams.ChannelId         = PESChannel[1];
    fdmatst_CovertNodeAddressDataToPeripheral((STFDMA_Node_t*)Node_p[1]);
    TransferParams.NodeAddress_p     = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p[1]);
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &PES2TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    for(i = 0; i < 2; i++)
    {
        WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
        if (STOS_SemaphoreWaitTimeOut(pPausedSemap, &WaitTime) != 0)
        {
            VERBOSE_PRINT("*** ERROR: Did not get node complete notification within the time allowed.\n");
            fdmatst_SetSuccessState(FALSE);
        }
    }

    /* Resuming both transfers now */
    STFDMA_ResumeTransfer(PES2TransferId);
    STFDMA_ResumeTransfer(PES1TransferId);

    for (i = 0; i < 2; i++)
    {
        WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
        if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
        {
            VERBOSE_PRINT("*** ERROR: Did not get transfer complete notification within the time allowed.\n");
            fdmatst_SetSuccessState(FALSE);
        }
    }

    VERBOSE_PRINT("Check the results\n");

    for (i = 0; i < 2; i++)
    {
        /* Verify ES buffer */
        ErrorCode = STFDMA_ContextGetESReadPtr(Context[i], &ReadPtr);
        ReadPtr = (void*)ST40_NOCACHE_NOTRANSLATE(ReadPtr);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        if (ReadPtr != Buff_p[i] + TestDefine[i].Offset)
        {
            VERBOSE_PRINT("*** ERROR: ES buffer read pointer has moved.\n");
            fdmatst_SetSuccessState(FALSE);
        }

        ErrorCode = STFDMA_ContextGetESWritePtr(Context[i], &WritePtr, NULL);
        WritePtr = (void*)ST40_NOCACHE_NOTRANSLATE(WritePtr);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        BuffSize = ((U32)WritePtr - (U32)ReadPtr);
        if (BuffSize < 0) BuffSize += ESBuffSize;

        if (BuffSize != (TestDefine[i].OutputSize - TestDefine[i].HoldBack))
        {
            STTBX_Print(("*** ERROR: ES buffer write pointer is incorrect. [%d:%d]\n", BuffSize, TestDefine[i].OutputSize - TestDefine[i].HoldBack));
            fdmatst_SetSuccessState(FALSE);
        }

        BuffSize = MIN(BuffSize, (TestDefine[i].OutputSize - TestDefine[i].HoldBack));
        First    = MIN((ESBuffSize - TestDefine[i].Offset), BuffSize);
        Second   = BuffSize - First;

        if (memcmp(TestDefine[i].Output, Buff_p[i] + TestDefine[i].Offset, First))
        {
            STTBX_Print(("*** ERROR: ES buffer PES output is incorrect. (0) %08X %d %d %d\n", (U32)TestDefine[i].Output, First, Second, TestDefine[i].OutputSize));
            fdmatst_SetSuccessState(FALSE);
        }

        if (memcmp(TestDefine[i].Output + First, Buff_p[i], Second))
        {
            STTBX_Print(("*** ERROR: ES buffer PES output is incorrect. (1) %08X %d %d %d\n", (U32)TestDefine[i].Output, First, Second, TestDefine[i].OutputSize));
            fdmatst_SetSuccessState(FALSE);
        }

        /* Verify start code list */
        ErrorCode = STFDMA_ContextGetSCList(Context[i], &SCListEnd, &Size, &Overflow);
        SCListEnd = (STFDMA_SCEntry_t*)ST40_NOCACHE_NOTRANSLATE(SCListEnd);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        if ((SCList[i] + TestDefine[i].SCEntries) != SCListEnd)
        {
            STTBX_Print(("*** ERROR: SC List write pointer is incorrect. %08X[%08X]\n", (U32)SCListEnd, (U32)(SCList[i] + TestDefine[i].SCEntries)));
#if defined(DEBUG)
            DebugSCList((U32)(Buff_p[i] + TestDefine[i].Offset), SCList[i], SCListEnd - SCList[i]);
#endif
            fdmatst_SetSuccessState(FALSE);
        }

        if (Size != (SC_LIST_MAX - TestDefine[i].SCEntries) * sizeof(SCListEnd[0]))
        {
            STTBX_Print(("*** ERROR: SC List remaining size is wrong. %d[%d]\n", Size, (SC_LIST_MAX - TestDefine[i].SCEntries) * sizeof(SCListEnd[0])));
            fdmatst_SetSuccessState(FALSE);
        }

        if (SCCompare((U32)Buff_p[i], TestDefine[i].SCResult, SCList[i], SCListEnd - SCList[i]))
        {
            VERBOSE_PRINT("*** ERROR: SC List entry is wrong.\n");
#if defined(DEBUG)
            DebugSCList((U32)Buff_p[i], SCList[i], SCListEnd - SCList[i]);
#endif
            fdmatst_SetSuccessState(FALSE);
        }

        if (Overflow)
        {
            VERBOSE_PRINT("*** ERROR: Unexpected SC List overflow.\n");
            fdmatst_SetSuccessState(FALSE);
        }
    }

    VERBOSE_PRINT("Calling STFDMA_Term, forced expect NO_ERROR and transfer abort.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_PES);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Clean up */
    VERBOSE_PRINT("Clean up.\n");
    fdmatst_DeallocateNodes();

    /* Clear out tranfer id */
    PES1TransferId = 0;
    PES2TransferId = 0;
}
#endif

#if defined (ST_5188)
/****************************************************************************
Name         : CaseFei
Description  :
Parameters   :
Return Value :
****************************************************************************/
static void CaseFei(int arg)
{
    ST_ErrorCode_t                  ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t             InitParams;
    STFDMA_GenericNode_t           *Node_p;
    STFDMA_TransferGenericParams_t  TransferParams;
    U32                             NumPackets = 8;

    STTBX_Print(("Checking FEI transfer without CPU intervention...\n\n"));

    /* Initialise the FDMA */
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;

    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Setting up linked list of nodes.\n");

    ErrorCode = fdmatst_CreateFEINode(  FDMATST_DIM_0D, FDMATST_Y_STATIC,   TRUE,
                                        FDMATST_DIM_1D, FDMATST_Y_INC,      TRUE,
                                        FALSE,          FALSE,              NumPackets,
                                        &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    TransferParams.Pool = STFDMA_FEI_POOL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = (STFDMA_GenericNode_t *)TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;

    VERBOSE_PRINT("Call STFDMA_StartTransfer for a blocking transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartGenericTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    STSYS_WriteRegDev32LE(0x20402000, 0x00200000);
    STFEI_Init();
    STFEI_Start ();

    /* wait for node complete signal */
    VERBOSE_PRINT("Waiting for node complete signal.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....no notification provided..error */
        VERBOSE_PRINT("*** ERROR: Did not get node complete within time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

#if defined DISPLAY_FEI_DATA
    {
        U8 *Temp = NULL;
        U32 Index = 0;
        STTBX_Print(("\n\n"));
        Temp = (U8*)(Node_p->FEINode.DestinationAddress_p);
        for(Index = 0; Index < (192*NumPackets); Index++)
        {
            if(!(Index%16) && (Index))
            {
                STTBX_Print(("\n"));
            }
            if(!(Index%192) && (Index))
            {
                STTBX_Print(("\n"));
            }

            STTBX_Print(("%02x ",Temp[Index]));
        }
        STTBX_Print(("\n\n"));
    }
#endif

    /* Term, forced. Expect no error */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();
}
#endif

#if defined (ST_OS20)
/****************************************************************************
Name         : CaseF305
Description  : Tests for the occurance of ST_ERROR_NO_MEMORY
Parameters   :
Return Value :
****************************************************************************/
static void CaseF305(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;


    STTBX_Print(("Checking for occurance of ST_ERROR_NO_MEMORY...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_MEMORY.\n");
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p       = fdmatst_GetBaseAddress();
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 10000;  /* Error value */
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock           = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_ERROR_NO_MEMORY);
}
#endif

/****************************************************************************
Name         : CaseF306
Description  : Tests for the occurance of ST_ERROR_INTERRUPT_INSTALL
Parameters   :
Return Value :
****************************************************************************/
static void CaseF306(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;

    STTBX_Print(("Checking for occurance of ST_ERROR_INTERRUPT_INSTALL...\n\n"));

    /* Initialise the FDMA with bad interrupt parameters */
    VERBOSE_PRINT("Calling STFDMA_Init with interrupt bad level, expect ERROR_INTERRUPT_INSTALL.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = -1;  /* bad value */
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_ERROR_INTERRUPT_INSTALL);

#if !defined (ARCHITECTURE_ST40) && !defined (ARCHITECTURE_ST200) /* Interrupt level isn't used on the ST40/ST200 */

    VERBOSE_PRINT("Calling STFDMA_Init with bad interrupt number, expect ERROR_INTERRUPT_INSTALL.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = -1;  /* bad value */
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_ERROR_INTERRUPT_INSTALL);
#endif
}

/****************************************************************************
Name         : CaseF307
Description  : Tests for the occurance of ST_ERROR_UNKNOWN_DEVICE
Parameters   :
Return Value :
****************************************************************************/
static void CaseF307(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;

    STTBX_Print(("Checking for occurance of ST_ERROR_UNKNOWN_DEVICE...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 1;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Calling STFDMA_Term, expect UNKNOWN_DEVICE.\n");
    ErrorCode = STFDMA_Term("INVALIDDEVICENAME", FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_ERROR_UNKNOWN_DEVICE);

    VERBOSE_PRINT("Calling STFDMA_Term, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
}

/****************************************************************************
Name         : CaseF309
Description  : Test for the occurance of STFDMA_ERROR_NO_FREE_CHANNELS
               from STFDMA_LockChannel
Parameters   :
Return Value :
****************************************************************************/
static void CaseF309(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    U32                         i = 0;
    STFDMA_ChannelId_t          ChannelId = 0;

    STTBX_Print(("Checking for occurance of STFDMA_ERROR_NO_FREE_CHANNELS...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 1;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Locking all channels\n");
    for (i=0; i < NUM_CHANNELS; i++)
    {
        VERBOSE_PRINT("Calling STFDMA_LockChannel, expect NO_ERROR.\n");
        ErrorCode = STFDMA_LockChannel(&ChannelId, STFDMA_1);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
        VERBOSE_PRINT_DATA("ChannelId = %d.\n",ChannelId);
    }

    VERBOSE_PRINT("Locking one too many channels\n");
    VERBOSE_PRINT("Calling STFDMA_LockChannel, expect NO_FREE_CHANNELS.\n");
    ErrorCode = STFDMA_LockChannel(&ChannelId, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_NO_FREE_CHANNELS);
    VERBOSE_PRINT_DATA("ChannelId = %d.\n",ChannelId);

    /* clean up */
    VERBOSE_PRINT("Calling STFDMA_Term, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
}

/****************************************************************************
Name         : CaseF311
Description  : Tests for the occurance of STFDMA_ERROR_CHANNEL_BUSY
Parameters   :
Return Value :
****************************************************************************/
static void CaseF311(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_ChannelId_t          ChannelId = 0;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;

    STTBX_Print(("Checking for occurance of STFDMA_ERROR_CHANNEL_BUSY...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 1;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Locking a channel.\n");
    VERBOSE_PRINT("Calling STFDMA_LockChannel, expect NO_ERROR.\n");
    ErrorCode = STFDMA_LockChannel(&ChannelId, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT_DATA("ChannelId = %d.\n",ChannelId);


    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = ChannelId;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a non-blocking, endless transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Try to start another transfer using same ChannelId\n");
    VERBOSE_PRINT("Call STFDMA_StartTransfer again, expect CHANNEL_BUSY.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_CHANNEL_BUSY);

    /* clean up */
    VERBOSE_PRINT("Clean up\n");
    VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : CaseF314
Description  : Tests for the occurance of STFDMA_ERROR_NO_CALLBACK_TASK
Parameters   :
Return Value :
****************************************************************************/
static void CaseF314(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;

    STTBX_Print(("Checking for occurance of STFDMA_ERROR_NO_CALLBACK_TASK...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 0;  /* No callback task */
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback; /* request callback */
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect NO_CALLBACK_TASK.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_NO_CALLBACK_TASK);

    /* clean up */
    VERBOSE_PRINT("Clean up\n");
    VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : CaseF316
Description  : Tests for the occurance of STFDMA_ERROR_UNKNOWN_CHANNEL_ID
Parameters   :
Return Value :
****************************************************************************/
static void CaseF316(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_ChannelId_t          ChannelId = 0;

    STTBX_Print(("Checking for occurance of STFDMA_ERROR_UNKNOWN_CHANNEL_ID...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 1;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    VERBOSE_PRINT("Unlocking a non-locked channel.\n");
    VERBOSE_PRINT("Calling STFDMA_UnlockChannel, expect UNKNOWN_CHANNEL_ID.\n");
    ErrorCode = STFDMA_UnlockChannel(ChannelId, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_UNKNOWN_CHANNEL_ID);

    /* clean up */
    VERBOSE_PRINT("Clean up\n");
    VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
}

/****************************************************************************
Name         : CaseF317
Description  : Tests for the occurance of STFDMA_ERROR_TRANSFER_IN_PROGRESS
Parameters   :
Return Value :
****************************************************************************/
static void CaseF317(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;

    STTBX_Print(("Checking for occurance of STFDMA_ERROR_TRANSFER_IN_PROGRESS...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 1;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Attempt an unforced driver termination.\n");
    VERBOSE_PRINT("Calling STFDMA_Term, unforced, expect TRANSFER_IN_PROGRESS.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_TRANSFER_IN_PROGRESS);

    /* clean up */
    VERBOSE_PRINT("Clean up\n");
    VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_DeallocateNodes();
}

/****************************************************************************
Name         : CaseF318
Description  : Tests for the occurance of STFDMA_ERROR_CHANNEL_NOT_LOCKED
Parameters   :
Return Value :
****************************************************************************/
static void CaseF318(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_ChannelId_t          ChannelId = 0;
    STFDMA_TransferParams_t     TransferParams;


    STTBX_Print(("Checking for occurance of STFDMA_ERROR_CHANNEL_NOT_LOCKED...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.NumberCallbackTasks = 1;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Setup non-blocking, end less transfer */
    VERBOSE_PRINT("Setup circular transfer.\n");
    ErrorCode = fdmatst_SetupCircularTransfer(FALSE, FALSE, FALSE, FALSE, FALSE, &Node_p);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Start the transfer on any channel */
    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = ChannelId;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect CHANNEL_NOT_LOCKED.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &GeneralTransferId);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_CHANNEL_NOT_LOCKED);

    /* clean up */
    VERBOSE_PRINT("Clean up\n");
    VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_DeallocateNodes();
}

#if !defined (ST_OSLINUX)
/****************************************************************************
Name         : CaseF319
Description  : Tests application notification of an error occurring by missed
               interrupt.
               Use the scenario of a linked list of three nodes with the middle
               node giving end of node notification. The last node is very short
               transfer. It is intended that the last node will complete before
               the middle node end of node interrupt is responded to, thus
               an interrupt has been missed. The ErrorFlag in the callback
               must be set in such a condition.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF319(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_TransferParams_t     TransferParams;

    STTBX_Print(("Checking callback ErrorFlag is set when interrupt missed..\n\n"));

    g_Test319 = TRUE;

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_1;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* setup nodes with end of node notify, not pause */
    VERBOSE_PRINT("Setting up linked list of 1D nodes.\n");
    VERBOSE_PRINT("Node 1...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&Node_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 2...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   TRUE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&Node_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
    VERBOSE_PRINT("Node 3...\n");
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FDMATST_DIM_1D, FDMATST_Y_INC, TRUE,
                                   FALSE, FALSE,
                                   STFDMA_REQUEST_SIGNAL_NONE,&Node_p->Next_p->Next_p);

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Adjusting default node configuration....");
    VERBOSE_PRINT_DATA("Reducing the nodes NumberBytes and Length to %d\n",SMALL_NUMBER_BYTES);
    Node_p->NumberBytes = SMALL_NUMBER_BYTES;
    Node_p->Length = SMALL_NUMBER_BYTES;
    Node_p->Next_p->NumberBytes = SMALL_NUMBER_BYTES;
    Node_p->Next_p->Length = SMALL_NUMBER_BYTES;
    Node_p->Next_p->Next_p->NumberBytes = SMALL_NUMBER_BYTES;
    Node_p->Next_p->Next_p->Length = SMALL_NUMBER_BYTES;

    VERBOSE_PRINT("List now comprises:\n");
    VERBOSE_PRINT_DATA("  Node1 at             0x%x\n",Node_p);
    VERBOSE_PRINT_DATA("  Node1 NumberBytes == %d\n",Node_p->NumberBytes);
    VERBOSE_PRINT_DATA("  Node2 at             0x%x\n",Node_p->Next_p);
    VERBOSE_PRINT_DATA("  Node2 NumberBytes == %d\n",Node_p->Next_p->NumberBytes);
    VERBOSE_PRINT_DATA("  Node3 at             0x%x\n",Node_p->Next_p->Next_p);
    VERBOSE_PRINT_DATA("  Node3 NumberBytes == %d\n",Node_p->Next_p->Next_p->NumberBytes);

    /* Disable all interrupts to invoke error condition */

    STOS_InterruptLock();

#if !defined (ST_5517)
    /* StartTransfer unlocks interrupts so disable the
      FDMA interrupts by writing directly to the int mask */
    STSYS_WriteRegDev32LE(INTERRUPT_MASK_REG, 0x00000000);
#endif

    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
    TransferParams.ApplicationData_p = NULL;
    TransferParams.FDMABlock = STFDMA_1;
    VERBOSE_PRINT("Call STFDMA_StartTransfer for a non-blocking transfer expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &F319TransferId);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* wait for second  for transfers to complete an interrupts to be missed */
    STOS_TaskDelay(fdmatst_GetClocksPerSec() * 1 * DELAY_MODIFIER);

#if !defined (ST_5517)
    /* Re-enable the interrupts in the int mask */
    STSYS_WriteRegDev32LE(INTERRUPT_MASK_REG, 0xFFFFFFFF);
#endif

    STOS_InterruptUnlock();

    VERBOSE_PRINT("Waiting for transfer complete signal AND ErrorFlag set.\n");
    WaitTime = (STOS_time_plus(time_now(),(10 * DELAY_MODIFIER * fdmatst_GetClocksPerSec())));
    if (STOS_SemaphoreWaitTimeOut(pTransferCompleteSemap, &WaitTime) != 0)
    {
        /* semaphore timed out....desired notification not provided */
        VERBOSE_PRINT("*** ERROR: Did not get transfer complete with error flag in time allowed.\n");
        fdmatst_SetSuccessState(FALSE);
    }

    /* Term, forced. Expect no error */
    VERBOSE_PRINT("Calling STFDMA_Term, unforced. Expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, FALSE, STFDMA_1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    VERBOSE_PRINT("Clean up memory.\n");
    fdmatst_DeallocateNodes();

    F319TransferId = 0;

    g_Test319 = FALSE;
}
#endif

/****************************************************************************
Name         : CaseF320
Description  : Alloate all contexts until and error is produced this should
               be the STFDMA_ERROR_NO_FREE_CONTEXTS error.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF320(int arg)
{
    ST_ErrorCode_t                   ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t              InitParams;
    STFDMA_ContextId_t               Context;
    int                              Count;

    /* First check a transfer can run to completion while a circular in progress..*/

    /* Init, expect no error */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType          = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p   = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p   = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber     = FDMA_PES_INTERRUPT_NUMBER;
    InitParams.InterruptLevel      = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p       = FDMA_PES_BASE_ADDRESS;
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
    InitParams.FDMABlock = STFDMA_PES;
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_PES);
#endif

    /* Allocate a Contexts until an error occurs */

    Count = 100;
    VERBOSE_PRINT("Allocate all the contexts.\n");
    do
    {
        ErrorCode = STFDMA_AllocateContext(&Context);
    }
    while ((ErrorCode == ST_NO_ERROR) && (Count--));

    VERBOSE_PRINT("expect STFDMA_ERROR_NO_FREE_CONTEXTS.\n");
    fdmatst_ErrorReport("", ErrorCode, POST_FDMA_1(STFDMA_ERROR_NO_FREE_CONTEXTS, ST_ERROR_FEATURE_NOT_SUPPORTED));

    /* Clean up */

    VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_PES);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
}

/****************************************************************************
Name         : CaseF401
Description  : Self contained performance test for checking transfer of 810K
               block from one SMI block to another
               Reference 5517 : Library Requirement Document SR Id 759 and 760.
               Uses its own node creation, array filling and data checking code
               since usage is special case and not default memory size.
Parameters   :
Return Value :
****************************************************************************/
static void CaseF401(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node_p = NULL;
    STFDMA_Node_t               *DeallocateNode_p = NULL;
    STFDMA_TransferParams_t     TransferParams;
    STFDMA_TransferId_t         TransferId = 0;
    U16                         *Src_p;
    U16                         *Dest_p;
    U16                         *DeallocateSrc_p;
    U16                         *DeallocateDest_p;
    U16                         TestValue = 0;
    U16                         RunningTestValue = 0;
#if defined (ST_OSLINUX)
    struct timeval              StartTime;
    struct timeval              EndTime;
    struct timeval              ElapsedTime;
    dma_addr_t                  physical_address;
#else
    partition_status_t          MemUsage;
    STOS_Clock_t                StartTime = 0;
    STOS_Clock_t                EndTime = 0;
    STOS_Clock_t                ElapsedTime = 0;
    U32                         TicksPerSec = 0;
#endif
    U32                         BytesPerSec = 0;
    U32                         LineWordCount = 0;
    U32                         ArrayWordCount = 0;
    U32                         TransferType = 0;
    U32                         StructureType = 0;
    U32                         MemSize = 0;
    BOOL                        LineContainsUsefulData = FALSE;
    BOOL                        DataWrong = FALSE;
    enum
    {
        DIM_1D = 0,
        DIM_2D,
        TEST_COMPLETE
    };

    STTBX_Print(("Performance test for a SMI to SMI transfer.\n\n"));

    for (StructureType=DIM_1D; StructureType!=TEST_COMPLETE; StructureType++)
    {

        if (StructureType == DIM_1D)
        {
            STTBX_Print(("Transferring 720*288*16bits as 1D data structure...\n"));
            MemSize = F401_MEMSIZE_1D;
        }
        else
        {
            STTBX_Print(("Transferring 720*288*16bits as 2D data structure...\n"));
            MemSize = F401_MEMSIZE_2D;
        }
        /* create memory for node */
        VERBOSE_PRINT("Creating memory for node\n");

        /* Nodes must be 32 byte aligned... */

#if defined (ST_OSLINUX)
        DeallocateNode_p =
            (STFDMA_Node_t *)dma_pool_alloc(g_NodePool,
            GFP_KERNEL,
            &physical_address);

        Node_p = (STFDMA_Node_t *)DeallocateNode_p;
#else
        /* Create node+31bytes and store pointer for deallocation later */
        DeallocateNode_p = (STFDMA_Node_t *)(STOS_MemoryAllocateClear(fdmatst_GetNCachePartition(),
                                                                    1,
                                                                    (sizeof(STFDMA_Node_t)+31)));
        /* Ensure the node pointer is aligned on a 32byte boundary */
        Node_p = (STFDMA_Node_t *) (((U32)DeallocateNode_p + 31) & ~31);
#endif

#if defined (ARCHITECTURE_ST40) && defined (ST_OS21)
        cache_purge_data(DeallocateNode_p, (sizeof(STFDMA_Node_t)+31));
#endif

        if (DeallocateNode_p == NULL)
        {
            VERBOSE_PRINT("*** ERROR: Node creation: Not enough memory\n");
            fdmatst_SetSuccessState(FALSE);
            return;
        }

#if defined (ARCHITECTURE_ST40) && defined (ST_OS21)
        Node_p = (STFDMA_Node_t *)ADDRESS_TO_P2(Node_p);
#endif

        TransferType = ALIGNED_TRANSFER;

        /* Create source and destination memory spaces */
        VERBOSE_PRINT("Creating memory source and destination\n");

        /* Allocate src pointer and 31 bytes too many for alignement */

#if defined (ST_5517)
        DeallocateSrc_p = (U16 *) STOS_MemoryAllocateClear(fdmatst_GetSMIPartition(), 1, MemSize + 35);
#else
        DeallocateSrc_p = (U16 *) STOS_MemoryAllocateClear(fdmatst_GetNCachePartition(), 1, MemSize + 35);
#if defined (ARCHITECTURE_ST40) && defined (ST_OS21)
        cache_purge_data(DeallocateSrc_p, MemSize + 35);
#endif

#endif
        if (DeallocateSrc_p == NULL)
        {
            VERBOSE_PRINT("*** ERROR: Source mem creation: Not enough memory\n");
            fdmatst_SetSuccessState(FALSE);
#if !defined (ST_OSLINUX)
#if defined (ST_5517)
            if (partition_status(fdmatst_GetSMIPartition(), &MemUsage, 0) != -1)
#else
            if (partition_status(fdmatst_GetNCachePartition(), &MemUsage, 0) != -1)
#endif
            {
                fdmatst_DisplayPartitionStatus(&MemUsage);
            }
#endif
            return;
        }

        /* Check alignement requirement..*/
        if (TransferType == ALIGNED_TRANSFER)
        {
            /* align to 32byte boundary */
            Src_p = (U16 *) (((U32)DeallocateSrc_p + 31) & ~31);
        }
        else
        {
            /* Ensure NOT aligned to 32byte boundary */
            Src_p = (U16 *) ((((U32)DeallocateSrc_p + 31) & ~31) + 4);
        }

#if defined (ST_5517)
        DeallocateDest_p = (U16 *) STOS_MemoryAllocateClear(fdmatst_GetSMIPartition(), 1, MemSize + 35);
#else
        DeallocateDest_p = (U16 *) STOS_MemoryAllocateClear(fdmatst_GetNCachePartition(), 1, MemSize + 35);
#if defined (ARCHITECTURE_ST40)
#if defined (ST_OS21)
        cache_purge_data(DeallocateDest_p, MemSize + 35);
#endif
#endif

#endif
        if (DeallocateDest_p == NULL)
        {
            VERBOSE_PRINT("*** ERROR: Destination mem creation: Not enough memory\n");
            fdmatst_SetSuccessState(FALSE);
            STOS_MemoryDeallocate(fdmatst_GetNCachePartition(), DeallocateNode_p);
#if !defined (ST_OSLINUX)
#if defined (ST_5517)
            STOS_MemoryDeallocate(fdmatst_GetSMIPartition(), DeallocateSrc_p);
            if (partition_status(fdmatst_GetSMIPartition(), &MemUsage, 0) != -1)
#else
            STOS_MemoryDeallocate(fdmatst_GetNCachePartition(), DeallocateSrc_p);
            if (partition_status(fdmatst_GetNCachePartition(), &MemUsage, 0) != -1)
#endif
            {
                fdmatst_DisplayPartitionStatus(&MemUsage);
            }
#endif
            return;
        }
        /* Check alignement requirement..*/
        if (TransferType == ALIGNED_TRANSFER)
        {
            /* align to 32byte boundary */
            Dest_p = (U16 *) (((U32)DeallocateDest_p + 31) & ~31);
        }
        else
        {
            /* Ensure NOT aligned to 32byte boundary */
            Dest_p = (U16 *) ((((U32)DeallocateDest_p + 31) & ~31) + 4);
        }

#if defined (ARCHITECTURE_ST40) && defined (ST_OS21)
        Src_p = (U16*)ADDRESS_TO_P2(Src_p);
        Dest_p = (U16*)ADDRESS_TO_P2(Dest_p);
#endif

        /* Fill all source memory space to known values */
        RunningTestValue = 1;

        /* MEMSIZE measured in byte but we are accessing via 16bit words, so size is / 2.
         * Need to fill lines with useful data, and leave gaps recognisable pattern between lines.
         * So, want to fill F401_USEFUL_LINE_LENGTH * 16bits with TestValue, then skip
         * 16bits and continue, leaving 16bit any gaps between useful data.
         */
        LineWordCount = 0;
        TestValue = RunningTestValue;
        LineContainsUsefulData = TRUE;
        for (ArrayWordCount = 0; ArrayWordCount < (MemSize / 2); ArrayWordCount++)
        {
            /* Load test value to 16bit location */
            Src_p[ArrayWordCount] = TestValue;

            /* Move to next 16bit location in the line. */
            LineWordCount++;

            if (LineContainsUsefulData)
            {
                /* If at the end of the line and we are in a 2d transfer...
                 * (note: _LINE_LENGTH / 2 since we are counting 16bit words, not bytes).
                 */
                 if ((LineWordCount == (F401_USEFUL_LINE_LENGTH / 2)) && (StructureType == DIM_2D))
                 {
                     /* End of useful data and in a 2d structure, next word is unused gap area */
                     LineWordCount = 0;
                     TestValue = F401_UNUSED_TEST_PATTERN;
                     LineContainsUsefulData = FALSE;
                 }
                 else
                 {
                     /* Use running test value */
                     TestValue = ++RunningTestValue;
                 }
            }
            else  /* Line is an unused line in a 2D array... */
            {
                 if (LineWordCount == (F401_NUMBER_UNUSED_BYTES_PER_LINE / 2))
                 {
                     /* Reached end of gap line, next word is start of useful data */
                     LineWordCount = 0;
                     TestValue = ++RunningTestValue;
                     LineContainsUsefulData = TRUE;
                 }
                 else
                 {
                     TestValue = F401_UNUSED_TEST_PATTERN;
                 }
            }
        }

        /* Generic node config */
        Node_p->Next_p = NULL;
        Node_p->NumberBytes = F401_NUMBER_USEFUL_BYTES;
#if defined (ST_OSLINUX)
        Node_p->DestinationAddress_p = (void*)dma_map_single(NULL, Dest_p, MemSize + 35, DMA_TO_DEVICE);
        Node_p->SourceAddress_p = (void*)dma_map_single(NULL, Src_p, MemSize + 35, DMA_FROM_DEVICE);
#else
        Node_p->SourceAddress_p = (U32 *)Src_p;
        Node_p->DestinationAddress_p = (U32 *)Dest_p;
#endif
        Node_p->NodeControl.PaceSignal = STFDMA_REQUEST_SIGNAL_NONE;
        Node_p->NodeControl.Reserved = 0;
        Node_p->NodeControl.SourceDirection = STFDMA_DIRECTION_INCREMENTING;
        Node_p->NodeControl.DestinationDirection = STFDMA_DIRECTION_INCREMENTING;
        Node_p->NodeControl.NodeCompleteNotify = FALSE;
        Node_p->NodeControl.NodeCompletePause = FALSE;

        /* Setup for 2d transfer */
        if (StructureType != DIM_1D)
        {
            Node_p->SourceStride = (F401_USEFUL_LINE_LENGTH + F401_NUMBER_UNUSED_BYTES_PER_LINE);
            Node_p->DestinationStride = (F401_USEFUL_LINE_LENGTH + F401_NUMBER_UNUSED_BYTES_PER_LINE);
            Node_p->Length = F401_USEFUL_LINE_LENGTH;
        }
        else  /* 1d transfer */
        {
            Node_p->SourceStride = 0;
            Node_p->DestinationStride = 0;
            Node_p->Length = Node_p->NumberBytes;
        }

        VERBOSE_PRINT_DATA(" Node at 0x%x\n",Node_p);
        VERBOSE_PRINT_DATA(" Control.PaceSignal         : 0x%x\n",Node_p->NodeControl.PaceSignal);
        VERBOSE_PRINT_DATA(" Control.SrcDir             : 0x%x\n",Node_p->NodeControl.SourceDirection);
        VERBOSE_PRINT_DATA(" Control.DestDir            : 0x%x\n",Node_p->NodeControl.DestinationDirection);
        VERBOSE_PRINT_DATA(" Control.Reserved           : 0x%x\n",Node_p->NodeControl.Reserved);
        VERBOSE_PRINT_DATA(" Control.NodeCompletePause  : 0x%x\n",Node_p->NodeControl.NodeCompletePause);
        VERBOSE_PRINT_DATA(" Control.NodeCompleteNotify : 0x%x\n",Node_p->NodeControl.NodeCompleteNotify);
        VERBOSE_PRINT_DATA(" NumberBytes                : %d\n",Node_p->NumberBytes);
        VERBOSE_PRINT_DATA(" SrcAddress_p               : 0x%x\n",Node_p->SourceAddress_p);
        VERBOSE_PRINT_DATA(" DestAddress_p              : 0x%x\n",Node_p->DestinationAddress_p);
        VERBOSE_PRINT_DATA(" Length                     : %d\n",Node_p->Length);
        VERBOSE_PRINT_DATA(" SrcStride                  : %d\n",Node_p->SourceStride);
        VERBOSE_PRINT_DATA(" DestStride                 : %d\n",Node_p->DestinationStride);
        /* Initialise the FDMA */
        VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
        InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
        InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
        InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
        InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
        InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
        InitParams.DeviceType = FDMA_TEST_DEVICE;
        InitParams.NumberCallbackTasks = 1;
        InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
        InitParams.FDMABlock = STFDMA_1;
        ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
        LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

        /* Start the transfer on any channel */
#if defined (ST_5188)
        TransferParams.BlockingTimeout = 1025 * DELAY_MODIFIER; /* 1025ms: Experimentally determined, as the arbitration priority for */
                                                                /* the default (& PES) pool channels has been decreased in f/w v1.3 */
#elif defined (ST_5105)
        TransferParams.BlockingTimeout = 130 * DELAY_MODIFIER;  /* 130ms: Experimentally determined, as the arbitration priority for */
                                                                /* the default (& PES) pool channels has been decreased in f/w v1.1 */
#else
        TransferParams.BlockingTimeout = 50 * DELAY_MODIFIER; /* 50ms: Expect complete in within 20 */
#endif
        TransferParams.CallbackFunction = NULL;
        TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
#if defined (ST_OSLINUX)
        TransferParams.NodeAddress_p = (void*)physical_address;
#else
        fdmatst_CovertNodeAddressDataToPeripheral(Node_p);
        TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node_p);
#endif
        TransferParams.ApplicationData_p = NULL;
        TransferParams.FDMABlock = STFDMA_1;
        VERBOSE_PRINT("Call STFDMA_StartTransfer, blocking transfer, expect NO_ERROR.\n");
#if defined (ST_OSLINUX)
        do_gettimeofday(&StartTime);
#else
        StartTime = time_now();
#endif

        ErrorCode = STFDMA_StartTransfer(&TransferParams, &TransferId);

#if defined (ST_OSLINUX)
        do_gettimeofday(&EndTime);
#else
        EndTime = time_now();
#endif
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX)
        dma_unmap_single(NULL, Node_p->SourceAddress_p,  MemSize + 35, DMA_FROM_DEVICE);
        dma_unmap_single(NULL, Node_p->DestinationAddress_p,  MemSize + 35, DMA_TO_DEVICE);
#endif

        /* Check data */
        VERBOSE_PRINT("Checking data\n");
        LineWordCount = 0;
        LineContainsUsefulData = TRUE;
        for (ArrayWordCount = 0; ArrayWordCount < (MemSize / 2); ArrayWordCount++)
        {
            if (LineContainsUsefulData)
            {
                /* Load test value to 16bit location */
                if (Src_p[ArrayWordCount] != Dest_p[ArrayWordCount])
                {
                    DataWrong = TRUE;
                    STTBX_Print(("*** ERROR: Data not transfered correctly!\n"));
                    fdmatst_SetSuccessState(FALSE);
                    break;
                }

                /* Move to next 16bit location in the line. */
                LineWordCount++;

                if ((LineWordCount == (F401_USEFUL_LINE_LENGTH / 2)) && (StructureType == DIM_2D))
                {
                    /* End of useful data and in a 2d structure, next word is unused gap area */
                    LineWordCount = 0;
                    LineContainsUsefulData = FALSE;
                }
            }
            else  /* Line is an unused line in the 2D src array... */
            {
                /* Do NOT expect to see 2D gap test pattern in destination buffer */
                if (F401_UNUSED_TEST_PATTERN == Dest_p[ArrayWordCount])
                {
                    DataWrong = TRUE;
                    STTBX_Print(("*** ERROR: Data in 2D gap not as expected!\n"));
                    fdmatst_SetSuccessState(FALSE);
                    break;
                }

                /* Move to next 16bit location in the line. */
                LineWordCount++;

                if (LineWordCount == (F401_NUMBER_UNUSED_BYTES_PER_LINE / 2))
                {
                    /* Reached end of gap line, next word is start of useful data */
                    LineWordCount = 0;
                    LineContainsUsefulData = TRUE;
                }
            }
        }

        /* Summarise...*/
        if (DataWrong == FALSE)
        {
            VERBOSE_PRINT("-> Data transfered correctly.\n");
        }

        /* Check time taken */
        VERBOSE_PRINT("Checking time take for transfer to complete and function to return\n");
        BytesPerSec = 0;
#if defined(ST_OSLINUX)
        ElapsedTime.tv_sec = 0;
        ElapsedTime.tv_usec = EndTime.tv_usec - StartTime.tv_usec;
        BytesPerSec = F401_NUMBER_USEFUL_BYTES  * (10000000 / ElapsedTime.tv_usec);
#else
        ElapsedTime = STOS_time_minus(EndTime, StartTime);
        TicksPerSec =  fdmatst_GetClocksPerSec();

        /* If transfer takes more than 1sec, it took too long. Otheriwse find data rate. */
        if (ElapsedTime < TicksPerSec)
        {
            BytesPerSec = ((F401_NUMBER_USEFUL_BYTES  * (TicksPerSec / ElapsedTime)));
        }
#endif

        STTBX_Print(("Data rate: %d bytes/sec\n\n",BytesPerSec));

        VERBOSE_PRINT("Calling STFDMA_Term, forced, expect NO_ERROR.\n");
        ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
        fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

        /* clean up */
        VERBOSE_PRINT("Clean up\n");

#if defined (ST_5517)
        STOS_MemoryDeallocate(fdmatst_GetSMIPartition(), DeallocateDest_p);
        STOS_MemoryDeallocate(fdmatst_GetSMIPartition(), DeallocateSrc_p);
#else
        STOS_MemoryDeallocate(fdmatst_GetNCachePartition(), DeallocateDest_p);
        STOS_MemoryDeallocate(fdmatst_GetNCachePartition(), DeallocateSrc_p);
#endif
#if defined (ST_OSLINUX)
        dma_pool_free(g_NodePool,
            DeallocateNode_p,
            physical_address);
#else
        STOS_MemoryDeallocate(fdmatst_GetNCachePartition(), DeallocateNode_p);
#endif
    }
}

#if !defined (ST_5517)
/****************************************************************************
Name         : NonblockingMultipleDreqTest
Description  : Tests the case when multiple tasks try to use the same DREQ line.
                    The first task (wanting to make a non-blocking transfer)acquires the DREQ
                    line while the second returns with the 'BUSY' error.
Parameters   :
Return Value :
****************************************************************************/
static void NonblockingMultipleDreqTest(int arg)
{
    ST_ErrorCode_t              ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         InitParams;
    STFDMA_Node_t               *Node1_p, *Node2_p;
    STFDMA_TransferParams_t     TransferParams;

    STTBX_Print(("Checking multiple transfers (non-blocking) same DREQ line usage...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
#if defined (ST_5525)
    InitParams.InterruptNumber = FDMA2_INTERRUPT_NUMBER;
    InitParams.BaseAddress_p = (U32 *)FDMA2_BASE_ADDRESS;
    InitParams.FDMABlock = STFDMA_2;
#else
    InitParams.FDMABlock = STFDMA_1;
#endif
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    TransferParams.BlockingTimeout = 0;
    TransferParams.CallbackFunction = Callback;
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    TransferParams.ApplicationData_p = NULL;
#if defined (ST_5525)
    TransferParams.FDMABlock = STFDMA_2;
#else
    TransferParams.FDMABlock = STFDMA_1;
#endif

    /*Transfer1 - 1D finite non-blocking transfer*/
#if defined(ST_7109)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC/*does not matter for a 0D destination*/, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS1, &Node1_p);
#elif defined(ST_5105) || defined (ST_5188) || defined (ST_5107) || defined (ST_7200)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC/*does not matter for a 0D destination*/, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_SSC1_TX, &Node1_p);
#else
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC/*does not matter for a 0D destination*/, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS, &Node1_p);
#endif

    /*Making it a circular list (infinite transfer loop)*/
    Node1_p->Next_p = Node1_p;
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral(Node1_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node1_p);

    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect NO_ERROR.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &NonblockingMultipleDreqTestTransferId1);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /*Transfer2 - 0D finite non-blocking transfer*/
#if defined(ST_7109)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC /*does not matter for a 0D destination*/, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS1, &Node2_p);
#elif defined(ST_5105) || defined (ST_5188) || defined (ST_5107) || defined (ST_7200)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC /*does not matter for a 0D destination*/, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_SSC1_TX, &Node2_p);
#else
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC /*does not matter for a 0D destination*/, FALSE, FALSE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS, &Node2_p);
#endif

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral(Node2_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node2_p);

    VERBOSE_PRINT("Call STFDMA_StartTransfer, expect STFDMA_ERROR_REQUEST_SIGNAL_BUSY.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &NonblockingMultipleDreqTestTransferId2);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_REQUEST_SIGNAL_BUSY);

    /* Wait for first transfer to complete and interrupts to be missed */
    STOS_TaskDelay(fdmatst_GetClocksPerSec() * 3 * DELAY_MODIFIER);

    /* Kill driver */
    VERBOSE_PRINT("Calling STFDMA_Term, Forced, expect NO_ERROR after all transfers abort.\n");
#if defined (ST_5525)
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_2);
#else
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
#endif

    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /* Deallocate node memory */
    VERBOSE_PRINT("Cleaning memory space.\n");
    fdmatst_DeallocateNodes();

    /* Reset transfer ids */
    NonblockingMultipleDreqTestTransferId1 = 0;
    NonblockingMultipleDreqTestTransferId2 = 0;
}
#endif

#if !defined (ST_5517)
/****************************************************************************
Name         : Func_BlockingMultipleDreqTestTransferTask
Description  : Starts a transfer of the specified type on the given channel
Parameters   : TransferTaskParams_t  (see above)
Return Value :
****************************************************************************/
#if defined (ST_OSLINUX)
static int  Func_BlockingMultipleDreqTestTransferTask(void *TransferParams_p)
#else
static void Func_BlockingMultipleDreqTestTransferTask(void *TransferParams_p)
#endif
{
    ST_ErrorCode_t ErrorCode = ST_NO_ERROR;

    STOS_TaskEnter(TransferParams_p);

    VERBOSE_PRINT("Starting 1D finite blocking transfer. Expect STFDMA_ERROR_BLOCKING_TIMEOUT .\n");
    ErrorCode = STFDMA_StartTransfer((STFDMA_TransferParams_t*)TransferParams_p, &BlockingMultipleDreqTestTransferId1);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_BLOCKING_TIMEOUT);

    STOS_SemaphoreSignal(pTestContinue);
    STOS_SemaphoreWait(pTaskContinue1);

    STOS_TaskExit(TransferParams_p);
#if defined(ST_OSLINUX)
    return ST_NO_ERROR;
#endif
}
#endif

#if !defined (ST_5517)
/****************************************************************************
Name         : BlockingMultipleDreqTest
Description  : Tests the case when multiple tasks try to use the same DREQ line.
                    The first task (wanting to make a blocking transfer) acquires the DREQ line
                    while the second returns with the 'BUSY' error.
Parameters   :
Return Value :
****************************************************************************/
static void BlockingMultipleDreqTest(int arg)
{
    ST_ErrorCode_t              		ErrorCode = ST_NO_ERROR;
    STFDMA_InitParams_t         	InitParams;
    STFDMA_TransferParams_t     	TransferParams;
    STFDMA_Node_t               	*Node1_p, *Node2_p;

    STTBX_Print(("Checking multiple transfers (blocking) same DREQ line usage...\n\n"));

    /* Initialise the FDMA */
    VERBOSE_PRINT("Calling STFDMA_Init, expect NO_ERROR.\n");
    InitParams.DeviceType = FDMA_TEST_DEVICE;
    InitParams.DriverPartition_p = fdmatst_GetSystemPartition();
    InitParams.NCachePartition_p = fdmatst_GetNCachePartition();
    InitParams.InterruptNumber = FDMA_INTERRUPT_NUMBER;
    InitParams.InterruptLevel = FDMA_INTERRUPT_LEVEL;
    InitParams.NumberCallbackTasks = 1;
    InitParams.BaseAddress_p = fdmatst_GetBaseAddress();
    InitParams.ClockTicksPerSecond = fdmatst_GetClocksPerSec();
#if defined (ST_5525)
    InitParams.InterruptNumber = FDMA2_INTERRUPT_NUMBER;
    InitParams.BaseAddress_p = (U32 *)FDMA2_BASE_ADDRESS;
    InitParams.FDMABlock = STFDMA_2;
#else
    InitParams.FDMABlock = STFDMA_1;
#endif
    ErrorCode = STFDMA_Init(FDMATEST_DEVICENAME, &InitParams);
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

#if defined (ST_OSLINUX) && defined (CONFIG_STM_DMA)
    LOCK_FDMA_CHANNELS(&Lock_7100_fdma2[0], STFDMA_1);
#endif

    /* Transfer1 - 1D finite blocking transfer*/
    TransferParams.ChannelId = STFDMA_USE_ANY_CHANNEL;
    TransferParams.BlockingTimeout = 1000;
    TransferParams.CallbackFunction = NULL;
    TransferParams.ApplicationData_p = NULL;
#if defined (ST_5525)
    TransferParams.FDMABlock = STFDMA_2;
#else
    TransferParams.FDMABlock = STFDMA_1;
#endif

#if defined(ST_7109)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, TRUE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS1, &Node1_p);
#elif defined(ST_5105) || defined (ST_5188) || defined (ST_5107) || defined (ST_7200)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, TRUE, FALSE, STFDMA_REQUEST_SIGNAL_SSC1_TX, &Node1_p);
#else
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_1D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, TRUE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS, &Node1_p);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    /*Making it a circular list (infinite transfer loop)*/
    Node1_p->Next_p = Node1_p;

    fdmatst_CovertNodeAddressDataToPeripheral(Node1_p);
    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node1_p);

    /*Transfer2 - 0D finite non-blocking transfer*/
#if defined(ST_7109)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC /*does not matter for a 0D destination*/, FALSE, TRUE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS1, &Node2_p);
#elif defined(ST_5105) || defined (ST_5188) || defined (ST_5107) || defined (ST_7200)
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC /*does not matter for a 0D destination*/, FALSE, TRUE, FALSE, STFDMA_REQUEST_SIGNAL_SSC1_TX, &Node2_p);
#else
    ErrorCode = fdmatst_CreateNode(FDMATST_DIM_0D, FDMATST_Y_INC, FALSE, FDMATST_DIM_0D, FDMATST_Y_INC /*does not matter for a 0D destination*/, FALSE, TRUE, FALSE, STFDMA_REQUEST_SIGNAL_SWTS, &Node2_p);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);

    fdmatst_CovertNodeAddressDataToPeripheral(Node2_p);

    STOS_TaskCreate((void(*)(void *))Func_BlockingMultipleDreqTestTransferTask,
                    (void *)&TransferParams,
                    system_partition,
                    (size_t)TASK_STACK_SIZE,
                    (void **)&BlockingMultipleDreqTestTransferTaskStack,
                    system_partition,
                    &pBlockingMultipleDreqTestTransferTask,
                    BlockingMultipleDreqTestTransferTaskDescriptor,
                    MAX_USER_PRIORITY,
                    "BlockingMultipleDreqTestTransferTask",
                    (task_flags_t)0);

    /*To ensure that the blocking transfer starts first*/
    STOS_TaskSchedule();

    TransferParams.NodeAddress_p = TRANSLATE_NODE_ADDRESS_TO_PHYS(Node2_p);

    VERBOSE_PRINT("Starting 0D finite blocking transfer, expect STFDMA_ERROR_REQUEST_SIGNAL_BUSY.\n");
    ErrorCode = STFDMA_StartTransfer(&TransferParams, &BlockingMultipleDreqTestTransferId2);
    fdmatst_ErrorReport("", ErrorCode, STFDMA_ERROR_REQUEST_SIGNAL_BUSY);

    /*
    Had to introduce the semaphore duo so that the blocking circular transfer (started in the task) which
    waits on the blocking queue via 'wait_event_interruptible_timeout' times out comfortably before SIGKILL
    is passed by the following STOS_TaskWait() call to the same. Second semaphore simply coordinates task
    termination.
    */
    STOS_SemaphoreWait(pTestContinue);
    STOS_SemaphoreSignal(pTaskContinue1);

    STOS_TaskWait(&pBlockingMultipleDreqTestTransferTask, (STOS_Clock_t *)TIMEOUT_INFINITY);
    STOS_TaskDelete(pBlockingMultipleDreqTestTransferTask,
                    system_partition,
                    (void *)BlockingMultipleDreqTestTransferTaskStack,
                    system_partition);

    /* Clean up */
    VERBOSE_PRINT("Task complete, clean memory space.\n");
    fdmatst_DeallocateNodes();

    /* Kill driver */
    VERBOSE_PRINT("Calling STFDMA_Term, exepct NO_ERROR.\n");
#if defined (ST_5525)
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_2);
#else
    ErrorCode = STFDMA_Term(FDMATEST_DEVICENAME, TRUE, STFDMA_1);
#endif
    fdmatst_ErrorReport("", ErrorCode, ST_NO_ERROR);
}
#endif

static struct
{
    U32    Number;
    char  *Title;
    void (*Func)(int);
    int    Arg;
}
TestSet[] =
{
    {101, "F101 executing:\n\n", CaseF101, 0},
    {102, "F102 executing:\n\n", CaseF102, 0},
    {103, "F103 executing:\n\n", CaseF103, 0},
#if !defined (ST_OSWINCE)
    {107, "F107 executing:\n\n", CaseF107, 0},
#endif
    {109, "F109 executing:\n\n", CaseF109, 0},
#if !defined(ST_5517) && !defined(ST_OSLINUX)
    {110, "F110 executing:\n\n", CaseF110, 0},
#endif
    {112, "F112 executing:\n\n", CaseF112, 0},
    {201, "F201 executing:\n\n", F201ToF208TransferTests, F201},
    {202, "F202 executing:\n\n", F201ToF208TransferTests, F202},
    {203, "F203 executing:\n\n", F201ToF208TransferTests, F203},
    {204, "F204 executing:\n\n", F201ToF208TransferTests, F204},
    {205, "F205 executing:\n\n", F201ToF208TransferTests, F205},
    {206, "F206 executing:\n\n", F201ToF208TransferTests, F206},
    {207, "F207 executing:\n\n", F201ToF208TransferTests, F207},
    {208, "F208 executing:\n\n", F201ToF208TransferTests, F208},
    {209, "F209 executing:\n\n", F209ToF210TransferTests, F209},
    {210, "F210 executing:\n\n", F209ToF210TransferTests, F210},
    {211, "F211 executing:\n\n", CaseF211, 0},
    {212, "F212 executing:\n\n", CaseF212, 0},

#if !defined(ST_5517)
    /* Theses tests are only valid of FDMA 2 */
    {213, "F213 executing:\n\n", PESTransfer, 0},
    {214, "F214 executing:\n\n", PESTransfer, 1},
    {215, "F215 executing:\n\n", PESTransfer, 2},
    {216, "F216 executing:\n\n", PESTransfer, 3},
    {218, "F218 executing:\n\n", CaseF218, 0},
    {221, "F221 executing:\n\n", CaseF221, 0},
#if !defined (ST_7710) && !defined (STFDMA_NO_PACED_TESTS)
    {230, "F223 executing:\n\n", CaseF230, 0},
    {231, "F224 executing:\n\n", CaseF231, 0},
    {232, "F225 executing:\n\n", CaseF232, 0},
    {233, "F226 executing:\n\n", CaseF233, 0},
    {234, "F227 executing:\n\n", CaseF234, 0},
    {235, "F228 executing:\n\n", CaseF235, 0},
#endif

#if defined (ST_7100) || defined (ST_7109) || defined (ST_7200)
    {240, "F240 executing:\n\n", H264Transfer, 0},
#endif

#if defined (ST_7200)
    {250, "F250 executing:\n\n", MultiPESTransfer, 0},
#endif
#endif

#if defined (ST_5188)
    {260, "F260 executing:\n\n", CaseFei, 0},
#endif

#if defined (ST_OS20)
    {305, "F305 executing:\n\n", CaseF305, 0},
#endif
    {306, "F306 executing:\n\n", CaseF306, 0},
    {307, "F307 executing:\n\n", CaseF307, 0},
    {309, "F309 executing:\n\n", CaseF309, 0},
    {311, "F311 executing:\n\n", CaseF311, 0},
    {314, "F314 executing:\n\n", CaseF314, 0},
    {316, "F316 executing:\n\n", CaseF316, 0},
    {317, "F317 executing:\n\n", CaseF317, 0},
    {318, "F318 executing:\n\n", CaseF318, 0},
#if !defined(ST_OSLINUX)
    {319, "F319 executing:\n\n", CaseF319, 0},
#endif
    {320, "F320 executing:\n\n", CaseF320, 0},

#if !defined (ST_5517)
    {321, "F321 executing:\n\n", NonblockingMultipleDreqTest, 0},
    {322, "F322 executing:\n\n", BlockingMultipleDreqTest, 0},
#endif

    {401, "F401 executing:\n\n", CaseF401, 0},
};

#if defined(DEBUG)
/****************************************************************************
Name         : func_RunTest
Description  : Run a specific test
Parameters   :
Return Value :
****************************************************************************/
static void func_RunTest(U32 Number)
{
    int i;

    for (i = 0; (i < sizeof(TestSet)/sizeof(*TestSet)); i++)
    {
        if (Number == TestSet[i].Number)
        {
            STTBX_Print((TestSet[i].Title));
            TestSet[i].Func(TestSet[i].Arg);
            fmdatst_TestCaseSummarise();
            break;
        }
    }
}
#endif

/****************************************************************************
Name         : func_RunFuncTest
Description  : Entry point for functional test
Parameters   :
Return Value :
****************************************************************************/
void func_RunFuncTest()
{
    int i;
    int SCListSize = (4 * sizeof(SCTable_t)) + 16;

    pTestContinue           = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pTaskContinue1          = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pTaskContinue2          = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pTaskContinue3          = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pAbortSemap             = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pPausedSemap            = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pTransferCompleteSemap  = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pListCompleteSemap      = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);
    pNodeCompleteSemap      = STOS_SemaphoreCreateFifoTimeOut(system_partition, 0);

#if defined (ST_OS20)
#if !defined (ST_5517)
    BlockingMultipleDreqTestTransferTaskDescriptor = (tdesc_t *)STOS_MemoryAllocate(system_partition, sizeof(tdesc_t));
#endif
    TransferTask1Descriptor = (tdesc_t *)STOS_MemoryAllocate(system_partition, sizeof(tdesc_t));
    TransferTask2Descriptor = (tdesc_t *)STOS_MemoryAllocate(system_partition, sizeof(tdesc_t));
    TransferTask3Descriptor = (tdesc_t *)STOS_MemoryAllocate(system_partition, sizeof(tdesc_t));
#if !defined (ST_5517) && !defined(ST_OSLINUX)
    CaseF110TaskDescriptor  = (tdesc_t *)STOS_MemoryAllocate(system_partition, sizeof(tdesc_t));
#endif
#endif

    if (SCListMalloc == NULL)
    {
#if defined (ST_OSLINUX)
        SCListMalloc = dma_alloc_coherent(
            NULL,
            SCListSize,
            &SCListPhysicalAddrMalloc,
            GFP_KERNEL);
        SCList = (SCTable_t*)(((U32)SCListMalloc +15) & ~0X0F);
        SCListPhysicalAddr = SCListPhysicalAddrMalloc + ((U32)SCList - (U32)SCListMalloc);
#else
        SCListMalloc = (char*)STOS_MemoryAllocateClear (fdmatst_GetNCachePartition(), 1, SCListSize);
        SCList = (SCTable_t*)(((U32)SCListMalloc +15) & ~0X0F);
#endif

#if defined (ARCHITECTURE_ST40) && defined (ST_OS21)
        cache_purge_data(SCListMalloc, SCListSize);
#endif
    }

#if defined (ARCHITECTURE_ST40) && defined (ST_OS21)
    SCList = (SCTable_t*)ADDRESS_TO_P2(SCList);
#endif

    STTBX_Print(("\nFunctional Test Cases:\n"));
    STTBX_Print(("--------------------------------------------------------\n"));

    fdmatst_ResetSuccessState();

#if defined(DEBUG)
    /* Emulation test set */
    func_RunTest(107);  /* Simple non-blocking transfer       */
    func_RunTest(112);  /* More complex non-blocking transfer */
    func_RunTest(103);  /* Simple blocking transfer        */
    func_RunTest(109);  /* More complex blocking transfer  */
    func_RunTest(102);  /* All channels transfer           */
    func_RunTest(101);  /* Multi task simple transfer      */

    func_RunTest(201);  /* 2D to 2D */
    func_RunTest(202);  /* 2D to 2D */
    func_RunTest(203);  /* 2D to 2D */
    func_RunTest(204);  /* 1D to 1D */
    func_RunTest(205);  /* 1D to 2D */
    func_RunTest(206);  /* 2D to 1D */
    func_RunTest(207);  /* 0D to 1D */ /* Data differs */
    func_RunTest(208);  /* 0D to 2D */

    func_RunTest(209);  /* High load - single   callback manager  */
    func_RunTest(210);  /* High load - multiple callback managers */

    func_RunTest(213);  /* PES transfer of PES data  */
    func_RunTest(214);  /* PES transfer of  ES data  */
    func_RunTest(215);  /*  ES transfer of PES data  */
    func_RunTest(216);  /*  ES transfer of  ES data  */
    func_RunTest(218);  /* Multiple transfers        */
    func_RunTest(221);  /* Overflow conditions.      */

    func_RunTest(223);  /* SPDIF */
    func_RunTest(224);
    func_RunTest(225);
    func_RunTest(226);
    func_RunTest(227);
    func_RunTest(228);
#else
    for (i = 0; (i < sizeof(TestSet)/sizeof(*TestSet)); i++)
    {
        STTBX_Print((TestSet[i].Title));
        TestSet[i].Func(TestSet[i].Arg);
        fmdatst_TestCaseSummarise();
    }
#endif

    if (SCListMalloc != NULL)
    {
#if defined (ST_OSLINUX)

       dma_free_coherent(NULL,
            SCListSize,
            SCListMalloc,
            SCListPhysicalAddrMalloc);
#else
        STOS_MemoryDeallocate(fdmatst_GetNCachePartition(), SCListMalloc);
#endif
        SCListMalloc = NULL;
    }

    STOS_SemaphoreDelete(system_partition, pTestContinue);
    STOS_SemaphoreDelete(system_partition, pTaskContinue1);
    STOS_SemaphoreDelete(system_partition, pTaskContinue2);
    STOS_SemaphoreDelete(system_partition, pTaskContinue3);
    STOS_SemaphoreDelete(system_partition, pAbortSemap);
    STOS_SemaphoreDelete(system_partition, pPausedSemap);
    STOS_SemaphoreDelete(system_partition, pTransferCompleteSemap);
    STOS_SemaphoreDelete(system_partition, pListCompleteSemap);

#if defined (ST_OS20)
#if !defined (ST_5517)
    STOS_MemoryDeallocate(system_partition, BlockingMultipleDreqTestTransferTaskDescriptor);
#endif
    STOS_MemoryDeallocate(system_partition, TransferTask1Descriptor);
    STOS_MemoryDeallocate(system_partition, TransferTask2Descriptor);
    STOS_MemoryDeallocate(system_partition, TransferTask3Descriptor);
#if !defined (ST_5517) && !defined(ST_OSLINUX)
    STOS_MemoryDeallocate(system_partition, CaseF110TaskDescriptor);
#endif
#endif
}

#if !defined(ST_5517)
/****************************************************************************
Name         : SCCompare
Description  : Compare the start code list with the expected results
Parameters   :
Return Value : return non-zero if they differ.
****************************************************************************/
static int SCCompare(U32 BaseES, STFDMA_SCResult_t *List1, STFDMA_SCEntry_t *List2, U32 Size)
{
    int i;

    for (i = 0; (i < Size); i++, List1++, List2++)
    {
        if ((List1->Type != List2->SC.Type) ||
            (List1->Tag  != List2->SC.Tag)  ||
            (List1->Addr != ((U32)ST40_NOCACHE_NOTRANSLATE(List2->SC.Addr) - BaseES)))
        {
            /* The entry does not match */
				VERBOSE_PRINT_DATA("ERR>> Type/TAG/Addr Entry:%d \n", i); 		
            return (1);
        }

        if (List1->Type == STFDMA_SC_ENTRY)
        {
#if defined (ST_7100) || defined (ST_7109) || defined (ST_7200)
            if (List1->Res1 != *(U32 *)&(List2->SC.ExtendedInfo))
#else
            if (List1->Res1 != List2->SC.SCValue)
#endif
            {
                /* The entry does not match */
					VERBOSE_PRINT_DATA("ERR>> STFDMA_SC_ENTRY Entry:%d \n", i); 			
                return (1);
            }
        }
        else if (List1->Type == STFDMA_PTS_ENTRY)
        {
            if ((List1->Res0 != List2->PTS.PTS0) ||
                (List1->Res1 != List2->PTS.PTS1))
            {
                /* The entry does not match */
				VERBOSE_PRINT_DATA("ERR>> STFDMA_PTS_ENTRY Entry:%d \n", i); 				
                return (1);
            }
        }
        else
        {
            /* The entry does not match */
			VERBOSE_PRINT_DATA("ERR>> UNKNOWN Entry:%d \n", i); 				
            return (1);
        }
    }

    /* All entries match */
    return (0);
}
#endif

#if defined(DEBUG)
/* Poll the FDMA reporting its state */
void DebugActive()
{
    U32 State;
    char         *BaseAddr  = (char*)fdmatst_GetBaseAddress();

    STTBX_Print((">>> %08X\n", *(U32*)(BaseAddr +0X4004))); /* What FDMA thinks the current active channels are */
}

/* Poll the FDMA reporting its state */
void DebugPoll(int Count)
{
    U32 State;
    char         *BaseAddr  = (char*)fdmatst_GetBaseAddress();
    volatile U32 *ItrState  = (volatile U32*)(BaseAddr + 0X5FC0);
    volatile U32 *Base      = (volatile U32*)(BaseAddr + 0X4000);

    do
    {
        STOS_TaskDelay(1);
        State = *ItrState;
        STTBX_Print((">>> Itr %08X ", State));                    /* The state of the interupts to th FDMA */
        STTBX_Print(("I-Ptr  %08X ", *(U32*)(BaseAddr +0X20)));   /* The currect FDMA instruction pointer */
        STTBX_Print(("Active %08X ", *(U32*)(BaseAddr +0X4004))); /* What FDMA thinks the current active channels are */

        STTBX_Print(("\n"));
    }
    while (State || --Count);
}

/* Fill the internal buffer for channel idx with known values */
void DebugBufferStuff(int idx)
{
    U32 Offset;
    U32 Size;
    U32 Patern = 0X01020304;
    U32 Config;
    char         *BaseAddr  = (char*)fdmatst_GetBaseAddress();
    volatile U32 *Base      = (volatile U32*)(BaseAddr + 0X4000);

    Config = *(Base +(0X0AC+idx*64)/4);
    Offset = (Config&0X01FF) << 3;
    Size   = (Config&0X7E00) >> (9-2);

    while (Size--)
    {
        *(Base +Offset +Size) = Patern;
        Patern += 0X01010101;
    }
}

/* Read the contents of the internal buffer for channel idx */
void DebugBufferGrab(int idx)
{
    U32 Offset;
    U32 Size;
    U32 Config;
    int i;
    char         *BaseAddr  = (char*)fdmatst_GetBaseAddress();
    volatile U32 *Base      = (volatile U32*)(BaseAddr + 0X4000);

    Config = *(Base +(0X0AC+idx*64)/4);
    Offset = (Config&0X01FF) << 3;
    Size   = (Config&0X7E00) >> (9-2);

    for (i = 0; (i < Size); i++)
    {
        if ((i+1)%16 == 0)
        {
            STTBX_Print(("%08X\n", *(Base +Offset +i)));
        }
        else
        {
            STTBX_Print(("%08X ", *(Base +Offset +i)));
        }
    }
    STTBX_Print(("\n"));
}

/* Read the contents of the channel config for channel idx */
void DebugNodeGrab(int idx)
{
    U32 Offset;
    int i;
    char         *BaseAddr  = (char*)fdmatst_GetBaseAddress();
    volatile U32 *Base      = (volatile U32*)(BaseAddr + 0X4000);

    Offset = (0X070+idx*64)/4;

    for (i = 0; (i < 16); i++)
    {
        STTBX_Print(("%08X ", *(Base +Offset +i)));
    }
    STTBX_Print(("\n"));
}

/* Dump/compare two arrays of bytes */
int DebugDump32(U32 *Master, U32 *Result, U32 Size)
{
    int i;
    int rtn = 0;
    for (i = 0; (i < Size/4); i++)
    {
        if (*Result != *Master)
        {
            STTBX_Print(("%08X<%08X> ", *(Result++), *(Master++)));
            rtn = 1;
        }
        else
        {
            STTBX_Print(("%08X[%08X] ", *(Result++), *(Master++)));
        }

        if (((i+1)&0X01) == 0) STTBX_Print(("\n"));
    }
    if ((i&0X07) != 0) STTBX_Print(("\n"));

    return rtn;
}

#if 0
/* Dump/compare two arrays of bytes */
int DebugDump(U8 *Master, U8 *Result, U32 Size)
{
    int i;
    int rtn = 0;
    for (i = 0; (i < Size); i++)
    {
        if (*Result != *Master)
        {
            STTBX_Print(("%02X<%02X> ", *(Result++), *(Master++)));
            rtn = 1;
        }
        else
        {
            STTBX_Print(("%02X[%02X] ", *(Result++), *(Master++)));
        }

        if (((i+1)&0X07) == 0) STTBX_Print(("\n"));
    }
    if ((i&0X07) != 0) STTBX_Print(("\n"));

    return rtn;
}
#endif

/* Dump the contents of the start code list */
void DebugSCList(U32 BaseES, STFDMA_SCEntry_t *List, U32 Size)
{
    int i;
    for (i = 0; (i < Size); i++, List++)
    {
        STTBX_Print(("%08X : %d %02X %08X %08X ", List, List->SC.Type, List->SC.Tag, (U32)List->SC.Addr - BaseES, (U32)List->SC.Addr));
        if (List->SC.Type == STFDMA_SC_ENTRY)
        {
#if defined (ST_7100) || defined (ST_7109) || (ST_7200)
            STTBX_Print(("%08X (SC)\n", *(U32 *)&(List->SC.ExtendedInfo)));
#else
            STTBX_Print(("%08X (SC)\n", List->SC.SCValue));
#endif
        }
        else if (List->SC.Type == STFDMA_PTS_ENTRY)
        {
            STTBX_Print(("%08X%08X (PTS)\n", List->PTS.PTS1, List->PTS.PTS0));
        }
        else
        {
            STTBX_Print(("UNKNOWN\n"));
        }
    }
    STTBX_Print(("\n"));
}
#endif

/*eof*/
