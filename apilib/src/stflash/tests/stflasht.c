/****************************************************************************

File Name   : stflasht.c

Description : Flash Memory API Test Routines

Copyright (C) 2005, ST Microelectronics

History     :

    11/07/03  Restructured test harness for clarity,added Testtool support.
              Added 5528 support.

    27/01/04  Added 5100 support.

    19/07/04  Added 7710 support.
              Ported to OS21

    10/01/05  Added 7100 support.

    11/03/05  Added 5301 support.

    05/05/05  Added 8010 support.

    07/11/05  Added 7109 support.

    31/01/06  Added 5188 support.

    31/01/06  Added 5525 support.

    04/05/06  Added 5107 support.
    
    27/03/07  Added 7200 support.


References  :

$ClearCase (VOB: stflash)

****************************************************************************/

/* Includes --------------------------------------------------------------- */

#include <stdio.h>
#include <string.h>
#include "stdevice.h"
#include "stack.h"
#include "stlite.h"
#ifndef ST_OS21
#include "ostime.h"
#endif
#include "stos.h"

#include "stddefs.h"
#include "stflash.h"
#include "stboot.h"
#include "stcommon.h"
#ifdef USE_TESTTOOL
#include "testtool.h"
#endif

#include "stflashtst.h"

#if defined(ST_5301)
#include "..\..\..\target\core\include\bsp\mmu.h"
#elif defined(ST_5525)
#include "..\..\..\target\core\include\bsp\mmu.h"
#include "..\..\..\target\core\include\bsp.h"
#endif

/* Private Types ---------------------------------------------------------- */
/* Private Constants ------------------------------------------------------ */

#if defined(FLASH_TEST_M58LW064D)
#define DEVICE_TYPE STFLASH_M58LW064D
#elif defined(FLASH_TEST_M58LW032)
#define DEVICE_TYPE STFLASH_M58LW032
#elif defined(FLASH_TEST_M29W800T)
#define DEVICE_TYPE STFLASH_M29W800T
#elif defined(FLASH_TEST_M29W160BT)
#define DEVICE_TYPE STFLASH_M29W160BT
#elif defined(FLASH_TEST_M29DW640D)
#define DEVICE_TYPE STFLASH_M29DW640D
#elif defined(FLASH_TEST_M29W320DT)       /* On DTTi5516 brick board */
#define DEVICE_TYPE STFLASH_M29W320DT
#elif defined(FLASH_TEST_AM29LV160D)
#define DEVICE_TYPE STFLASH_AM29LV160D
#elif defined(FLASH_TEST_AT49BV162AT)
#define DEVICE_TYPE STFLASH_AT49BV162AT
#elif defined(FLASH_TEST_E28F640)
#define DEVICE_TYPE STFLASH_E28F640
#elif defined(FLASH_TEST_M28W320CB)
#define DEVICE_TYPE STFLASH_M28W320CB
#elif defined(FLASH_TEST_M28W320FS)
#define DEVICE_TYPE STFLASH_M28W320FS
#elif defined(FLASH_TEST_M28W640FS)
#define DEVICE_TYPE STFLASH_M28W640FS
#elif defined(FLASH_TEST_M28W320FSU)
#define DEVICE_TYPE STFLASH_M28W320FSU
#elif defined(FLASH_TEST_M28W640FSU)
#define DEVICE_TYPE STFLASH_M28W640FSU
#elif defined(FLASH_TEST_M58LT128GS)
#define DEVICE_TYPE STFLASH_M58LT128GS
#elif defined(FLASH_TEST_M58LT256GS)
#define DEVICE_TYPE STFLASH_M58LT256GS
#else     /* (FLASH_TEST_M28F411) */       /* default to 5510 board */
#define DEVICE_TYPE STFLASH_M28F411
#endif

#if defined(mb382)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS

#elif defined(mb361)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS

#elif defined(mb314)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS

#elif defined(mb376) || defined(espresso)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS

#elif defined(mb390) || defined(mb391) || defined(mb394) || defined(mb400) || defined(mb411) \
|| defined(mb421) || defined(mb428) || defined(mb436) || defined(mb519)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS

#elif defined(mb317b)||defined(mb317a)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS

#elif defined(mb282b)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS

#elif defined(mb275)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS

#elif defined(mb5518)
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS

#else
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_08_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_32_BITS

#endif

#if defined(mb361)  /* there is only 1 flash chip */
#ifdef FLASH_BANK_1_BASE_ADDRESS
#undef FLASH_BANK_1_BASE_ADDRESS
#endif
#endif

/* STACK SIZE FOR TASKS */
#ifdef ST_OS21
#define STACK_SIZE  20*1024
#else
#define STACK_SIZE 1024
#endif

/* Declarations for memory partitions */
#ifndef ST_OS21

/* Sizes of partitions */
#define INTERNAL_PARTITION_SIZE          (ST20_INTERNAL_MEMORY_SIZE-1200)
#define SYSTEM_PARTITION_SIZE            0x100000

/* Memory partitions */
#define TEST_PARTITION_1        &the_system_partition
#define TEST_PARTITION_2        &the_internal_partition

/* Declarations for memory partitions */
static U8               internal_block [INTERNAL_PARTITION_SIZE];
static partition_t      the_internal_partition;
partition_t             *internal_partition = &the_internal_partition;
#ifdef ARCHITECTURE_ST20
#pragma ST_section      ( internal_block, "internal_section")
#endif

static U8               system_block [SYSTEM_PARTITION_SIZE];
static partition_t      the_system_partition;
partition_t             *system_partition = &the_system_partition;
#ifdef ARCHITECTURE_ST20
#pragma ST_section      ( system_block,   "system_section")
#endif

/* This is to avoid a linker warning */
static unsigned char    internal_block_noinit[1];
#ifdef ARCHITECTURE_ST20
#pragma ST_section      ( internal_block_noinit, "internal_section_noinit")
#endif

static unsigned char    system_block_noinit[1];
#ifdef ARCHITECTURE_ST20
#pragma ST_section      ( system_block_noinit, "system_section_noinit")
#endif

#if defined(ST_5100) || defined(ST_7710) || defined(ST_5528) || defined(ST_5105) || defined(ST_5301) \
|| defined(ST_5107)
static unsigned char    data_section[1];
#ifdef ARCHITECTURE_ST20
#pragma ST_section      ( data_section, "data_section")
#endif
#endif

#else /* ST_OS21 */

#define                 SYSTEM_MEMORY_SIZE          0x100000
static unsigned char    external_block[SYSTEM_MEMORY_SIZE];
partition_t             *system_partition;

#endif /* ST_OS21 */

#if defined(espresso) /* this will be removed after correction in espresso.h*/
#ifdef FLASH_BANK_0_ST40_BASE_ADDRESS
#undef FLASH_BANK_0_ST40_BASE_ADDRESS
#define FLASH_BANK_0_ST40_BASE_ADDRESS  0xA0000000
#endif
#endif

#ifndef STFLASH_M28W320CB

#ifdef ARCHITECTURE_ST40
#define STFLASH_BANK_0_BASE     FLASH_BANK_0_ST40_BASE_ADDRESS
#else
#define STFLASH_BANK_0_BASE     FLASH_BANK_0_BASE_ADDRESS
#endif /* ARCHITECTURE_ST40 */

#if !defined(espresso)
#if defined(FLASH_BANK_1_BASE_ADDRESS) || defined(FLASH_BANK_1_ST40_BASE_ADDRESS)
#ifdef ARCHITECTURE_ST40
#define STFLASH_BANK_1_BASE     FLASH_BANK_1_ST40_BASE_ADDRESS
#else
#define STFLASH_BANK_1_BASE     FLASH_BANK_1_BASE_ADDRESS
#endif /* ARCHITECTURE_ST40 */
#else
#define STFLASH_VPP_1_ENABLE    (U32)NULL
#endif /* FLASH_BANK_1_BASE_ADDRESS */
#endif /* espresso */
#endif

#define ARRAY_SIZE        32 * 1024
#define ARRAY_SIZEM1     ( ARRAY_SIZE - 1 )
#define ARRAY_SIZEM2     ( ARRAY_SIZE - 2 )
#define ERASED_STATE     0xFF
#define WRONG_HANDLE     0x01234567 /* invalid handle value */
#define INTO_BLOCK_0     0x00001000 /* not on block boundary */
#define FURTHER_IN_0     0x00002000 /* further into block 0 */
#define INTO_BLOCK_1     STFLASH_MAIN_0_SIZE + 0x00000800
                                    /* into main block 1 */
#define MISS32_BLK_1     STFLASH_MAIN_0_SIZE + 0x00001002
                                    /* further into block 1, U32 misaligned */
#define MISS16_BLK_1     STFLASH_MAIN_0_SIZE + 0x00002003
                                    /* further into block 1, U16 misaligned */

                          
#define NEAR_MEM_END     0x01FFFF70  /* ARRAY_SIZE read/write falls off end */
#define NOT_BLOCK_SIZE   0x00050000 /* invalid block size */
/* Private Variables ------------------------------------------------------ */

static ST_ErrorCode_t       retVal;

/* Suppress linker warning */
#ifdef ARCHITECTURE_ST20
#pragma ST_section      ( retVal,   "ncache_section")
#endif

#if defined(mb314)
#define DEBUG_OFFSET 0x00040000
#else
#define DEBUG_OFFSET 0x00020000
#endif

#if defined(FLASH_TEST_M58LW032)|| defined(FLASH_TEST_M29DW640D)  \
    || (defined(FLASH_TEST_M58LW064D) && !defined(mb376) && !defined(espresso) \
    && !defined(mb390) && !defined(mb394) && !defined(mb391) && !defined(mb400) \
    && !defined(mb411)) && !defined(mb421) && !defined(mb428) && !defined(mb436) \
    && !defined(mb519) 
#undef MIN_ACCESS_WIDTH
#undef MAX_ACCESS_WIDTH
#define MIN_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define MAX_ACCESS_WIDTH     STFLASH_ACCESS_16_BITS
#define STFLASH_VPP_0_ENABLE (U32)NULL
#define STFLASH_VPP_1_ENABLE (U32)NULL
#endif

#if defined(mb376)
#ifdef ARCHITECTURE_ST40
#define STFLASH_VPP_0_ENABLE 0xA2300000
#define STFLASH_VPP_1_ENABLE 0xA2300000
#else
#define STFLASH_VPP_0_ENABLE 0x42300000
#define STFLASH_VPP_1_ENABLE 0x42300000
#endif /* ARCHITECTURE_ST40 */
#elif defined(mb390) || defined(mb391)
#define STFLASH_VPP_0_ENABLE 0x41400000

#elif defined(mb400) || defined(mb436)
#define STFLASH_VPP_0_ENABLE 0x45200000

#elif defined(mb411)
#define STFLASH_VPP_0_ENABLE 0xA3400000

#elif defined(mb519)
#define STFLASH_VPP_0_ENABLE 0xA5400000

#elif defined(mb421)
#define STFLASH_VPP_0_ENABLE 0x00C00000

#elif defined(mb428)
#define STFLASH_VPP_0_ENABLE 0x52000000
#define STFLASH_VPP_1_ENABLE 0x52000000
#ifdef STFLASH_BANK_0_BASE
#undef STFLASH_BANK_0_BASE
#define STFLASH_BANK_0_BASE 0x50000000
#endif
#ifdef STFLASH_BANK_1_BASE
#undef STFLASH_BANK_1_BASE
#define STFLASH_BANK_1_BASE 0x50800000
#endif
#endif

#if defined(espresso)
#ifdef ARCHITECTURE_ST40
#define STFLASH_VPP_0_ENABLE 0xA1300000
#define STFLASH_VPP_1_ENABLE (U32)NULL
#else
#define STFLASH_VPP_0_ENABLE 0x42300000
#define STFLASH_VPP_1_ENABLE (U32)NULL
#endif
#endif

#if defined(mb394)
#define PIO_1_PC2   0x2010D044
#define PIO_1_PC1   0x2010D034
#define PIO_1_PC0   0x2010D024
#define PIO_1_OUT   0x2010D004
#endif

#if defined(mb436) && defined(FLASH_TEST_M28W640FS)
#define PIO_3_PC2   0x20823044
#define PIO_3_PC1   0x20823034
#define PIO_3_PC0   0x20823024
#define PIO_3_OUT   0x20823004
#endif

#if defined(mb391)
#ifdef STFLASH_MAIN_SIZE
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE       0x00020000 /* each block is of 128kB */
#endif /* STFLASH_MAIN_SIZE */
#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE
#endif /* mb391 */

#if defined(FLASH_TEST_AT49BV162AT)
#ifndef STFLASH_PARA_SIZE
#define STFLASH_PARA_SIZE  STFLASH_PARA_0_SIZE
#endif
#endif

#if defined(FLASH_TEST_M28W320CB) && defined(mb314)

#if defined (FLASH_BANK_0_BASE_ADDRESS)
#undef FLASH_BANK_0_BASE_ADDRESS
#define FLASH_BANK_0_BASE_ADDRESS  0x60000000
#define STFLASH_BANK_0_BASE     FLASH_BANK_0_BASE_ADDRESS
#endif /* FLASH_BANK_0_BASE_ADDRESS */

#undef INTO_BLOCK_0
#define INTO_BLOCK_0     0x00021000 /* not on block boundary */
#define NUM_BLOCKS              71

#if defined (STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE     0x00020000  /* bytes */
#endif /* STFLASH_MAIN_SIZE */

#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE

#if defined (STFLASH_MAIN_0_OFFS)
#undef STFLASH_MAIN_0_OFFS
#endif /* STFLASH_MAIN_0_OFFS */

#define STFLASH_MAIN_0_OFFS   0x00020000
#define STFLASH_PARA_SIZE     0x00001000

    STFLASH_Block_t   BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK }
    };

#elif defined(FLASH_TEST_E28F640)||defined(FLASH_TEST_M58LW032)||defined(FLASH_TEST_M58LW064D)

#define NUM_BLOCKS              64
#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }
    };

#elif defined(FLASH_TEST_M29W320DT)

/*#define NUM_BLOCKS              67*/
#define NUM_BLOCKS                135
#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE         0x10000
#define STFLASH_MAIN_0_SIZE       0x10000
#define STFLASH_MAIN_1_SIZE       0x10000
#endif
#define STFLASH_PARA_0_SIZE       0x400


    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 20 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 50 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 60 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 70 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 80 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 90 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 100 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 110 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 120 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        /*{ STFLASH_MAIN_1_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_1_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_BOOT_0_SIZE, STFLASH_BOOT_BLOCK }*/
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK }
   };

#elif defined(FLASH_TEST_M28W320FS) /* KRYPTO Secured FLASH */
#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE
#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE       0x00008000 /* 32kW */
#endif
#if defined(STFLASH_PARA_SIZE)
#undef STFLASH_PARA_SIZE
#define STFLASH_PARA_SIZE       0x00001000 /* 4kW */
#else
#define STFLASH_PARA_SIZE       0x00001000 /* 4kW */
#endif
#define NUM_BLOCKS              71 /* Top Boot Block */

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
    	{ STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
    	{ STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK }, /* 8 parameter block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },      /* 64 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 10 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 20 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 30 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 40 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 50 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }, /* 60 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }
    };

#elif   defined(FLASH_TEST_M28W320FSU) /* KRYPTO Secured FLASH */
#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE
#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE       0x00010000 /* 64k */
#endif
#define NUM_BLOCKS              32

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 10 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 20 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 30 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }
    };

#elif   defined(FLASH_TEST_M28W640FSU) /* KRYPTO Secured FLASH */
#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE
#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE       0x00010000 /* 64k */
#endif
#define NUM_BLOCKS              64

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 10 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 20 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 30 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK }
    };

#elif defined(FLASH_TEST_M28W640FS) /* KRYPTO Secured FLASH */
#define STFLASH_MAIN_0_SIZE     STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE     STFLASH_MAIN_SIZE
#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE       0x00010000 /* 64k */
#endif
#define NUM_BLOCKS              135
#define STFLASH_PARA_0_SIZE     0x00002000

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {

        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 10 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 20 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 30 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 40 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 50 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 60 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 70 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 80 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 90 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 100 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 110 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 120 */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },/* 127 */
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK }

    };

#elif   defined(FLASH_TEST_M29W800T)

#define NUM_BLOCKS           19

    /*(STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_0_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_2_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_3_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_4_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_5_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_6_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_7_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_8_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_9_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_A_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_B_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_C_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_D_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_E_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_F_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_1_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_BOOT_0_SIZE, STFLASH_BOOT_BLOCK }
    };*/
        STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_BOOT_0_SIZE, STFLASH_BOOT_BLOCK },
        { STFLASH_PARA_1_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_MAIN_0_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_2_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_3_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_4_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_5_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_6_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_7_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_8_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_9_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_A_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_B_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_C_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_D_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_E_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_F_SIZE, STFLASH_MAIN_BLOCK }

    };


#elif defined(FLASH_TEST_M29DW640D)

#define NUM_BLOCKS           142
#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE    0x00008000
#endif
#if defined(STFLASH_MAIN_0_SIZE)
#undef STFLASH_MAIN_0_SIZE
#define STFLASH_MAIN_0_SIZE  STFLASH_MAIN_SIZE
#endif
#if defined(STFLASH_MAIN_1_SIZE)
#undef STFLASH_MAIN_1_SIZE
#define STFLASH_MAIN_1_SIZE  STFLASH_MAIN_SIZE
#endif
#define STFLASH_PARA_SIZE    0x00001000

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        /* Bank A,Size 8Mbit,15 main block ,8 parameter block */
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        /* Bank B,Size 24Mbit,48 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        /* Bank C,Size 24Mbit,48 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        /* Bank D,Size 8Mbit,8 parameter block,15 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK }
    };

#elif defined(FLASH_TEST_AM29LV160D)

#define NUM_BLOCKS           35

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_0_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_2_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_3_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_4_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_5_SIZE, STFLASH_MAIN_BLOCK }
        { STFLASH_MAIN_6_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_7_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_8_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_9_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_A_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_B_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_C_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_D_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_E_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_F_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_10_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_11_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_12_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_13_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_14_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_15_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_16_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_17_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_18_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_19_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1A_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1B_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1C_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1D_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1E_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1F_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_0_SIZE,  STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_1_SIZE,  STFLASH_PARAMETER_BLOCK },
        { STFLASH_BOOT_0_SIZE,  STFLASH_BOOT_BLOCK }
    };


#elif defined(FLASH_TEST_AT49BV162AT)

#define NUM_BLOCKS           39 /* Sectors */

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_0_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_2_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_3_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_4_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_5_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_6_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_7_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_8_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_9_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_A_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_B_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_C_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_D_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_E_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_F_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_10_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_11_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_12_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_13_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_14_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_15_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_16_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_17_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_18_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_19_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1A_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1B_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1C_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1D_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1E_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_0_SIZE,  STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_1_SIZE,  STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE,    STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE,    STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE,    STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE,    STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE,    STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE,    STFLASH_PARAMETER_BLOCK }/* boot block */
    };

#elif defined(FLASH_TEST_M58LT128GS)

#define NUM_BLOCKS           131
#define NUM_BANKS            17

#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE    0x00020000/*1 block size -1Mbit always specify in bytes*/
#endif

#define STFLASH_MAIN_0_SIZE  STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE  STFLASH_MAIN_SIZE
#define STFLASH_PARA_SIZE    0x00008000 /*16Kwords*/

#define BANK_0_OFFSET		 STFLASH_PARA_SIZE * 3
#define BANK_0_BLOCK_SIZE    STFLASH_PARA_SIZE
#define BANK_2_OFFSET	     0x100000
#define BANK_2_BLOCK_SIZE    STFLASH_MAIN_0_SIZE
#define BANK_3_OFFSET	     0x200000
#define BANK_3_BLOCK_SIZE    STFLASH_MAIN_0_SIZE

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        /*Bottom Boot flash*/
        /* Parameter bank,Size 8Mbit,,4 parameter blocks */
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },

        /* 7 main block each of 1Mbit size */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 0,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 1,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 2,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 3,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 4,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 5,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 6,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 7,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 8,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 9,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 10,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 11,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 12,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 13,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 14,Size 8Mbit,8 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
};

STFLASH_BankParams_t BankInfo_s[17] =
{
  /*Bottom Boot device*/
    { 0, 4 },
    { 1, 7 },
    { 2, 8 },
    { 3, 8 },
    { 4, 8 },
    { 5, 8 },
    { 6, 8 },
    { 7, 8 },
    { 8, 8 },
    { 9, 8 },
    { 10, 8 },
    { 11, 8 },
    { 12, 8 },
    { 13, 8 },
    { 14, 8 },
    { 15, 8 },
    { 16, 8 }
};
#elif defined(FLASH_TEST_M58LT256GS)
#define NUM_BLOCKS           259
#define NUM_BANKS            17

#if defined(STFLASH_MAIN_SIZE)
#undef STFLASH_MAIN_SIZE
#define STFLASH_MAIN_SIZE    0x00020000  /*1 block size -1Mbit always specify in bytes*/
#endif

#define STFLASH_MAIN_0_SIZE  STFLASH_MAIN_SIZE
#define STFLASH_MAIN_1_SIZE  STFLASH_MAIN_SIZE
#define STFLASH_PARA_SIZE    0x00008000 /*16Kwords*/

#define BANK_0_OFFSET		  0x000000
#define BANK_0_BLOCK_SIZE     STFLASH_MAIN_SIZE
#define BANK_2_OFFSET	      0x400000
#define BANK_2_BLOCK_SIZE     STFLASH_MAIN_SIZE
#define BANK_3_OFFSET	      0x600000
#define BANK_3_BLOCK_SIZE     STFLASH_MAIN_SIZE
#define BANK_11_OFFSET	      0x1600000
#define BANK_11_BLOCK_SIZE     STFLASH_MAIN_SIZE
#define BANK_12_OFFSET	      0x1800000
#define BANK_12_BLOCK_SIZE     STFLASH_MAIN_SIZE


    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {

        /* 16 main block each of 1Mbit size */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
		{ STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        

        /* Bank 0,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 1,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 2,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 3,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },


        /* Bank 4,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },


        /* Bank 5,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },


        /* Bank 6,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },


        /* Bank 7,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },

        /* Bank 8,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        
        /* Bank 9,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        
        /* Bank 10,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        

        /* Bank 11,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        
        /* Bank 12,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        
        /* Bank 13,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        
        /* Bank 14,Size 16 Mbit,16 main block */
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_SIZE, STFLASH_MAIN_BLOCK },
        
         /*Top Boot flash*/
        /* Parameter bank,Size 8Mbit,,4 parameter blocks */
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_SIZE, STFLASH_PARAMETER_BLOCK },
};

STFLASH_BankParams_t BankInfo_s[17] =
{
	/*Top Boot device*/
    { 0, 16 },
    { 1, 16 },
    { 2, 16 },
    { 3, 16 },
    { 4, 16 },
    { 5, 16 },
    { 6, 16 },
    { 7, 16 },
    { 8, 16 },
    { 9, 16 },
    { 10, 16 },
    { 11, 16 },
    { 12, 16 },
    { 13, 16 },
    { 14, 16 },
    { 15, 15},	/*parameter bank*/
    { 16, 4} 	/*parameter bank*/
};

#else

/* Default to M28F411 flash type */
#define NUM_BLOCKS           7

    STFLASH_Block_t      BlockData_s[NUM_BLOCKS] =
    {
        { STFLASH_MAIN_0_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_1_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_2_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_MAIN_3_SIZE, STFLASH_MAIN_BLOCK },
        { STFLASH_PARA_0_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_PARA_1_SIZE, STFLASH_PARAMETER_BLOCK },
        { STFLASH_BOOT_0_SIZE, STFLASH_BOOT_BLOCK }
    };
#endif


STFLASH_Block_t         GetBlkDat_s[NUM_BLOCKS];
STFLASH_Params_t        GetParams_s;
STFLASH_InitParams_t    InitParams_s;
STFLASH_Handle_t        Handle0, Handle1;
STFLASH_OpenParams_t    OpenParams_s;
STFLASH_TermParams_t    TermParams_s;
STFLASH_CFI_Query_t     QueryCFI_s;

#if defined(STFLASH_MULTIBANK_SUPPORT)
typedef struct
{
    ST_ErrorCode_t Error;
    task_t 		   *Task_p;
} FLASH_TaskParams_t;
#endif

/* Private Macros --------------------------------------------------------- */

#define poke(addr, value) *((U32*)addr)=value
#define peek(addr) STFLASH_Print(("Value at %x is %x\n", (U32)addr, *((U32*)addr))

void test_init(void *dummy);
void test_overhead(void *dummy);
void test_term(void *dummy);
void test_typical(void *dummy);

/* Private Function prototypes -------------------------------------------- */
#if defined(STFLASH_MULTIBANK_SUPPORT)
static int MultiBankRWTest(void);
#else

#ifdef FLASH_FULLERW
static int FullERWTest( void );
#endif
static int NormalUse( void );
static int ErrantUse( void );
static void StackUsage(void);
static int MemLeak( void );
static int QueryCFI( void );

#endif

void ExTimeReport( clock_t TimeSnap );

void ErrorReport( int *ErrorCount,
                  ST_ErrorCode_t ErrorGiven,
                  ST_ErrorCode_t ExpectedErr );

void ParamsReport( STFLASH_Params_t *RetParams );
void CFIInfo( STFLASH_CFI_Query_t *CFIQuery );
void os20_main(void);

#ifdef USE_TESTTOOL
BOOL FLASH_RegisterTest( void );
static BOOL FLASH_ErrantUse( STTST_Parse_t *pars_p, char *Result );
static BOOL FLASH_NormalUse( STTST_Parse_t *pars_p, char *Result );
static BOOL FLASH_FullERW( STTST_Parse_t *pars_p, char *Result );
static BOOL FLASH_StackUsage( STTST_Parse_t *pars_p, char *Result );
static BOOL FLASH_MemLeak ( STTST_Parse_t *pars_p, char *Result );
static BOOL FLASH_QueryCFI ( STTST_Parse_t *pars_p, char *Result );

#if defined(STFLASH_MULTIBANK_SUPPORT)
static BOOL FLASH_MultiBank( STTST_Parse_t *pars_p, char *Result );
#endif
#endif
/* Functions -------------------------------------------------------------- */

/****************************************************************************
Name         : main()

Description  : Calls the specific test functions

Parameters   : none

Return Value : int

See Also     : OS20_main
 ****************************************************************************/
int main(void)
{
    os20_main();
    fflush (stdout);
    return(0);
}

void os20_main(void)
{
    int                     ErrorCount;
#if defined(ST_5525)
    int result;
#endif

#ifndef DISABLE_TOOLBOX
    STTBX_InitParams_t      sttbx_InitPars;
#endif
    STBOOT_InitParams_t     stboot_InitPars;
    STBOOT_TermParams_t     stboot_TermPars;

#ifdef USE_TESTTOOL
    STTST_InitParams_t      sttst_InitPars;
#endif

#ifndef DISABLE_DCACHE

#if defined CACHEABLE_BASE_ADDRESS

    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)CACHEABLE_BASE_ADDRESS, (U32 *)CACHEABLE_STOP_ADDRESS},
        { NULL, NULL }
    };

#elif defined(ST_5514) || defined(ST_5516)

    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)0x40200000, (U32 *)0x407FFFFF }, /* ok */
        { NULL, NULL }
    };

#elif defined(ST_5528) || defined(ST_5100)

    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)0x40000000, (U32 *)0x5FFFFFFF}, /* ok */
        { NULL, NULL }
    };

#elif defined(ST_5301)
    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)0xC0000000, (U32 *)0xC1FFFFFF }, /* ok */
        { NULL, NULL }
    };
#elif defined(ST_8010)
    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)0x80000000, (U32 *)0x81FFFFFF }, /* ok */
        { NULL, NULL }
    };
#elif defined(ST_5525)
    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)0x80000000, (U32 *)0x81FFFFFF }, /* ok */
        { NULL, NULL }
    };

#else

    STBOOT_DCache_Area_t DCacheMap[] =
    {
        { (U32 *)0x40080000, (U32 *)0x7FFFFFFF }, /* ok */
        { NULL, NULL }
    };
#endif

#endif /* end of !defined DISABLE_DCACHE */

#ifdef ARCHITECTURE_ST20
    /* to avoid linker warnings */
    internal_block_noinit[0] = 0;
    system_block_noinit[0] = 0;

#if defined(ST_5100) || defined(ST_7710) || defined(ST_5528) || defined(ST_5105) || defined(ST_5301) \
|| defined(ST_5107)
    data_section[0] = 0;
#endif
#endif

#ifdef ST_OS21

    /* Create memory partitions */
    system_partition = partition_create_heap((U8*)external_block, sizeof(external_block));

#else /* ifndef ST_OS21 */
    partition_init_heap (&the_internal_partition, internal_block,
                         sizeof(internal_block));
    partition_init_heap (&the_system_partition,   system_block,
                         sizeof(system_block));
#endif /* ST_OS21 */

#ifndef DISABLE_TOOLBOX

    /* Initialize the toolbox */
#ifdef ST_OS21
    sttbx_InitPars.CPUPartition_p      = system_partition;
#else
    sttbx_InitPars.CPUPartition_p      = TEST_PARTITION_1;
#endif

    sttbx_InitPars.SupportedDevices    = STTBX_DEVICE_DCU;
    sttbx_InitPars.DefaultOutputDevice = STTBX_DEVICE_DCU;
    sttbx_InitPars.DefaultInputDevice  = STTBX_DEVICE_DCU;

#endif /* disable TBX */

    /* Initialize stboot */
#ifdef DISABLE_ICACHE
    stboot_InitPars.ICacheEnabled             = FALSE;
#else
    stboot_InitPars.ICacheEnabled             = TRUE;
#endif

    stboot_InitPars.BackendType.DeviceType    = STBOOT_DEVICE_UNKNOWN;
    stboot_InitPars.BackendType.MajorRevision = STBOOT_REVISION_UNKNOWN;
    stboot_InitPars.BackendType.MinorRevision = STBOOT_REVISION_UNKNOWN;
    stboot_InitPars.CacheBaseAddress          = (U32*) CACHE_BASE_ADDRESS;

#ifdef DISABLE_DCACHE
    stboot_InitPars.DCacheMap                 = NULL;
#else
    stboot_InitPars.DCacheMap                 = DCacheMap;
#endif

    stboot_InitPars.MemorySize                = (STBOOT_DramMemorySize_t)SDRAM_SIZE;
    stboot_InitPars.SDRAMFrequency            = SDRAM_FREQUENCY;

#ifdef USE_TESTTOOL
    /* Initialize the testtool */
#ifdef ST_OS21
    sttst_InitPars.CPUPartition_p = system_partition;
#else
    sttst_InitPars.CPUPartition_p = TEST_PARTITION_1;
#endif
    sttst_InitPars.NbMaxOfSymbols = 1000;

#ifndef TESTTOOL_INPUT_FILE_NAME
#define TESTTOOL_INPUT_FILE_NAME ""
#endif

    strcpy( sttst_InitPars.InputFileName, TESTTOOL_INPUT_FILE_NAME );

#endif

#if defined(ST_5301)

    bsp_mmu_memory_unmap( (void *)(0x7f800000), 0x01000000);
    bsp_cache_purge_data_all();
    bsp_mmu_memory_map((void *)(0x7f800000),
                    0x01000000,
                    PROT_USER_EXECUTE|
                    PROT_USER_WRITE|
                    PROT_USER_READ|
                    PROT_SUPERVISOR_EXECUTE|
                    PROT_SUPERVISOR_WRITE|
                    PROT_SUPERVISOR_READ,
                    MAP_SPARE_RESOURCES,
                    (void *)(0x7f800000));



    bsp_mmu_memory_map((void *)(0x41000000),
                           0x02000000,
                           PROT_USER_EXECUTE|
                           PROT_USER_WRITE|
                           PROT_USER_READ|
                           PROT_SUPERVISOR_EXECUTE|
                           PROT_SUPERVISOR_WRITE|
                           PROT_SUPERVISOR_READ,
                           MAP_SPARE_RESOURCES,
                           (void *)(0x41000000));


#elif defined(ST_8010)
    __asm__ volatile ("pswclr %0" : : "r" (0x4));

#elif defined(ST_5525)

    result = (int) bsp_mmu_memory_map((void*)0x50000000,
                                        0x00800000,
                                        POLICY_UNCACHEABLE|
                                        PROT_USER_EXECUTE|
                                        PROT_USER_WRITE|
                                        PROT_USER_READ|
                                        PROT_SUPERVISOR_EXECUTE|
                                        PROT_SUPERVISOR_WRITE|
                                        PROT_SUPERVISOR_READ,
                                        MAP_LOCKED|
                                        MAP_OVERRIDE|
                                        MAP_SPARE_RESOURCES,
                                       (void*)0x00000000);

    if (result == BSP_FAILURE)
    {
    	STFLASH_Print((" First 8Mb of Flash on Bank 0\n");
    }

    /* FMI - Bank 1 -> Flash : 8MB */
    result = (int) bsp_mmu_memory_map((void*)0x50800000,
                                        0x00800020,
                                        POLICY_UNCACHEABLE|
                                        PROT_USER_EXECUTE|
                                        PROT_USER_WRITE|
                                        PROT_USER_READ|
                                        PROT_SUPERVISOR_EXECUTE|
                                        PROT_SUPERVISOR_WRITE|
                                        PROT_SUPERVISOR_READ,
                                        MAP_LOCKED|
                                        MAP_OVERRIDE|
                                        MAP_SPARE_RESOURCES,
                                        (void*)0x08000000);

    if ( result== BSP_FAILURE )
    {
    	STFLASH_Print((" First 4MB of Flash on Bank 1\n");
    }

    /* VPP Mapping */
    result = (int) bsp_mmu_memory_map((void*)0x52000000,
                                        0x00004000,
                                        POLICY_UNCACHEABLE|
                                        PROT_USER_EXECUTE|
                                        PROT_USER_WRITE|
                                        PROT_USER_READ|
                                        PROT_SUPERVISOR_EXECUTE|
                                        PROT_SUPERVISOR_WRITE|
                                        PROT_SUPERVISOR_READ,
                                        MAP_LOCKED|
                                        MAP_OVERRIDE|
                                        MAP_SPARE_RESOURCES,
                                        (void*)0x0980B000);

    if ( result== BSP_FAILURE )
    {
    	STFLASH_Print((" VPP mapping failed\n");
    }

#endif

    printf("\nStarting BOOT ...\n");
    retVal = STBOOT_Init( "FLASHTest", &stboot_InitPars );
    if (retVal != ST_NO_ERROR)
    {
        printf( "ERROR: STBOOT_Init() returned %d\n", retVal );
    }
    else
    {

#ifndef DISABLE_TOOLBOX
        printf("\nStarting TBX ...\n");
        retVal = STTBX_Init( "tbx", &sttbx_InitPars );
        if (retVal != ST_NO_ERROR)
        {
            printf( "ERROR: STTBX_Init() returned %d\n", retVal );
        }
        else
#endif
        {

            STFLASH_Print(("============================================================\n"));
            STFLASH_Print(("                    STFLASH Test Harness                    \n"));
            STFLASH_Print(("            Driver Revision: %s\n", STFLASH_GetRevision()));
            STFLASH_Print(("            Test Harness Revision: %s\n", HarnessRev));
            STFLASH_Print(( "============================================================\n" ));

#if defined(mb394)
            *(U32*)(PIO_1_PC2) = 0x00;
            *(U32*)(PIO_1_PC1) = 0x10;
            *(U32*)(PIO_1_PC0) = 0x00; /* to  provide BOOT block write access */
            *(U32*)(PIO_1_OUT) = 0x10;
#endif

#if defined(mb436) && defined(FLASH_TEST_M28W640FS)

            *(U32*)(PIO_3_PC2) = 0x00;
            *(U32*)(PIO_3_PC1) = 0x40;
            *(U32*)(PIO_3_PC0) = 0x00; /* to  provide BOOT block write access */
            *(U32*)(PIO_3_OUT) = 0x40;
#endif

#ifndef USE_TESTTOOL
#if !defined(STFLASH_MULTIBANK_SUPPORT)
#if !defined(ST_5525) /* to bypass task_delete problem of ST200 toolcahin */
            StackUsage();
#endif
            STFLASH_Print(( "============================================================\n" ));
            ErrorCount = NormalUse();
            ErrorCount = MemLeak();
            ErrorCount = QueryCFI();
            ErrorCount = ErrantUse();
#else /*STFLASH_MULTIBANK_SUPPORT*/
            ErrorCount = MultiBankRWTest();
#endif

#ifdef FLASH_FULLERW
#ifndef STFLASH_MULTIBANK_SUPPORT
            ErrorCount = FullERWTest();
#endif
            ErrorCount += ErrorCount;
#endif
            STFLASH_Print(( "Overall Test result is: " ));
            STFLASH_Print(( "%d errors\n", ErrorCount ));
            STFLASH_Print(( "============================================================\n" ));

#else /* USE_TESTTOOL */

            STFLASH_Print(("\nStarting TESTTOOL ...\n"));
            retVal = STTST_Init(&sttst_InitPars);
            if (retVal != ST_NO_ERROR)
            {
                STFLASH_Print(( "ERROR: STTST_Init() returned %d\n", retVal ));
            }
            else
            {
                FLASH_RegisterTest();
                /* Start Testtool prompt */
                STTST_Start();
                ErrorCount += Error;
                STTST_Term();
            }

#endif /* end of USE_TESTTOOL */
            retVal = STBOOT_Term( "FLASHTest", &stboot_TermPars );
        }
    }
}
/* Worker routines for stackusage */
void test_overhead(void *dummy)
{
    STFLASH_Print(( "test_overhead executing\n"));
    UNUSED_PARAMETER(dummy);    
}

void test_init(void *dummy)
{
    ST_ErrorCode_t error = ST_NO_ERROR;
    UNUSED_PARAMETER(dummy);    
    /* Build initparams */
    InitParams_s.DeviceType      = DEVICE_TYPE;
    InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_0_BASE;
    InitParams_s.VppAddress      = (U32*)STFLASH_VPP_0_ENABLE;
    InitParams_s.MinAccessWidth  = MIN_ACCESS_WIDTH;
    InitParams_s.MaxAccessWidth  = MAX_ACCESS_WIDTH;
    InitParams_s.NumberOfBlocks  = NUM_BLOCKS;
    InitParams_s.Blocks          = BlockData_s;

#if defined(STFLASH_SPI_SUPPORT)
    InitParams_s.IsSerialFlash   = FALSE;
#endif
#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif

    STFLASH_Print(( "test_init executing\n"));
    /* Initialise */
    error = STFLASH_Init("STACKTEST", &InitParams_s);
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Error initializing, got return code %i\n", error));
    }

}

void test_term(void *dummy)
{
    ST_ErrorCode_t error = ST_NO_ERROR;
    UNUSED_PARAMETER(dummy);    
    STFLASH_Print(( "test_term executing\n"));
    TermParams_s.ForceTerminate = FALSE;
    error = STFLASH_Term("STACKTEST", &TermParams_s);
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Error terminating, got return code %i\n", error));
    }
}

void test_typical(void *dummy)
{
    ST_ErrorCode_t          error = ST_NO_ERROR;
    int stored = 0;

    int                     i;
    U32                     NumberRead;
    U32                     NumberWrit;
    U32                     NumberToRead;

    static U8               ReadArray[ARRAY_SIZE];
    static U8               WritArray[ARRAY_SIZE];
    UNUSED_PARAMETER(dummy);    
    
    STFLASH_Print(( "test_typical executing\n"));

    /* Open Bank 0 */
    error = STFLASH_Open("STACKTEST", &OpenParams_s, &Handle0 );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Opening bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    /* GetParams for Bank 0 */
    GetParams_s.InitParams.Blocks = GetBlkDat_s;

    error = STFLASH_GetParams( Handle0, &GetParams_s );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Getting bank 0 params: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    error = STFLASH_BlockUnlock( Handle0, STFLASH_MAIN_0_OFFS );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Unlocking flash failed "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    /* Erase Bank 0 Main Block 0 */
    error = STFLASH_Erase(Handle0, STFLASH_MAIN_0_OFFS, STFLASH_MAIN_0_SIZE);
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Erasing bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    switch (GetParams_s.InitParams.MinAccessWidth)
    {
        case STFLASH_ACCESS_08_BITS:
            NumberToRead = ARRAY_SIZEM1;
            break;

        case STFLASH_ACCESS_16_BITS:
            NumberToRead = ARRAY_SIZEM2;
            break;

        case STFLASH_ACCESS_32_BITS:
            NumberToRead = ARRAY_SIZE;
            break;
    }

    /* Program Bank 0, part of Main Block 0 */
    for (i = 0; i < ARRAY_SIZE; i++)
    {
        WritArray[i] = (U8)i;
    }
    error = STFLASH_Write( Handle0,
                           INTO_BLOCK_0, /*DEBUG_OFFSET*/
                           WritArray,
                           ARRAY_SIZE,
                           &NumberWrit );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Writing to bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    error = STFLASH_Read( Handle0,
                          INTO_BLOCK_0,
                          ReadArray,
                          ARRAY_SIZE,
                          &NumberRead );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Reading bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    error = STFLASH_Close(Handle0);

    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Closing bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }
}

/****************************************************************************
Name:           StackUsage
Description:    Prints out the stack required for init, term, and
                    a typical sequence of operations.
Parameters:     None
Return value:   None
****************************************************************************/
#ifndef STFLASH_MULTIBANK_SUPPORT
static void StackUsage(void)
{
#ifndef ST_OS21
    task_t task;
    tdesc_t tdesc;
#endif
    task_t *task_p;

#ifndef ARCHITECTURE_ST40
    task_status_t status;
#endif

#ifdef ST_OS21
#define STACKSIZE 16*1024
#else
#define STACKSIZE 4*1024
    char stack[STACKSIZE];
#endif

    void (*func_table[])(void *) =  {   test_init,
                                        test_overhead,
                                        test_typical,
                                        test_term,
                                        NULL
                                    };
    void (*func)(void *);
    U8 i;

    STFLASH_Print(("Commencing Stack Usage Function ....\n" ));
    STFLASH_Print(("============================================================\n"));

#ifndef ST_OS21
    task_p = &task;
#endif

    for (i = 0; func_table[i]!=NULL ; i++)
    {
        func = func_table[i];

#ifdef ST_OS21
        task_p = task_create(func, NULL, STACKSIZE,MAX_USER_PRIORITY, "stack_test",(task_flags_t)0);
#else
        task_init(func, NULL, stack, STACKSIZE, task_p, &tdesc,
                    MAX_USER_PRIORITY, "stack_test",(task_flags_t)0);

#endif
        task_wait(&task_p, 1, TIMEOUT_INFINITY);

#ifndef ARCHITECTURE_ST40
        task_status(task_p, &status, task_status_flags_stack_used);
        STFLASH_Print(("Function %i, stack used = %d\n", i,
                    status.task_stack_used));
#endif
        task_delete(task_p);
    }
    STFLASH_Print(("\n"));
}
#endif/*STFLASH_MULTIBANK_SUPPORT*/

/****************************************************************************
Name         : FullERWTest()

Description  : Erases each block in turn and read verifies.
               Writes to each block in turn and read verifies.
               Every location is erased once, written to once
               and read twice.
               This routine is not included in the default test
               as all locations are overwritten.

Parameters   : None

Return Value : ST_ErrorCode_t specified as
               ST_NO_ERROR                  No errors occurred
               ST_ERROR_ALREADY_INITIALIZED More than one Init call w/o Term
               ST_ERROR_UNKNOWN_DEVICE      Open call w/o prior Init
               ST_ERROR_INVALID_HANDLE      Rogue Flash bank reference
               ST_ERROR_BAD_PARAMETER       One or more invalid parameters
               ST_ERROR_TIMEOUT             Timeout error during Erase/Write
               STFLASH_ERROR_WRITE          Error during programming sequence
               STFLASH_ERROR_ERASE          Error during erasure sequence
               STFLASH_ERROR_VPP_LOW        Vpp voltage low during either of
                                            Write or Erase sequences

See Also     : STFLASH_ErrorCode_t
 ****************************************************************************/
#ifdef FLASH_FULLERW
int FullERWTest( void )
{
    BOOL            Match;
    U32             i;
    U32             NumberRead;
    U32             NumberWrit;

    int  ErrorCount = 0;
    ST_ErrorCode_t  ReturnError;
    ST_Revision_t   RevisionStr;

    static U8       ReadArray[STFLASH_MAIN_0_SIZE];
    static U8       WritArray[STFLASH_MAIN_0_SIZE];
    U32             BankNo, TestBlock, TestSize, TestOffset, ErrorCounter;

    STFLASH_Print(( "\n============================================================\n" ));
    STFLASH_Print(( "Commencing Full Erase/Read/Write Test Function ....\n" ));
    STFLASH_Print(( "============================================================\n" ));

    /* revision string available before Flash Initialized */
    STFLASH_Print(( "Calling STFLASH_GetRevision() pre-Init \n" ));
    RevisionStr = STFLASH_GetRevision();
    STFLASH_Print(( "Software Revision reported as %s\n", RevisionStr ));
    STFLASH_Print(( "------------------------------------------------------------\n" ));

    /* Init Bank 0, Vpp 0 */

    InitParams_s.DeviceType      = DEVICE_TYPE;
    InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_0_BASE;
    InitParams_s.VppAddress      = (U32*)STFLASH_VPP_0_ENABLE;
    InitParams_s.MinAccessWidth  = MIN_ACCESS_WIDTH;
    InitParams_s.MaxAccessWidth  = MAX_ACCESS_WIDTH;
    InitParams_s.NumberOfBlocks  = NUM_BLOCKS;
    InitParams_s.Blocks          = BlockData_s;
#if defined(STFLASH_SPI_SUPPORT)
    InitParams_s.IsSerialFlash   = FALSE;
#endif
#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif

    STFLASH_Print(( "Calling STFLASH_Init() Bank0 ..........\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );


#ifdef STFLASH_BANK_1_BASE
    /* Init Bank 1, Vpp 1 */

    InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_1_BASE;
    InitParams_s.VppAddress      = (U32*)STFLASH_VPP_1_ENABLE;

    STFLASH_Print(( "Calling STFLASH_Init() Bank1 ..........\n" ));
    ReturnError = STFLASH_Init( "Bank1", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
#endif

    /* Open Bank 0 */
    STFLASH_Print(( "Calling STFLASH_Open() Bank0 ..........\n" ));
    ReturnError = STFLASH_Open( "Bank0",
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_BlockUnlock() Bank0 ..........\n" ));
    ReturnError = STFLASH_BlockUnlock( Handle0, 0 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    for (BankNo = 0; BankNo < 2; BankNo++)
    {

        /* GetParams for Bank BankNo */

        GetParams_s.InitParams.Blocks = GetBlkDat_s;
        STFLASH_Print(( "Calling STFLASH_GetParams() Bank %u ....\n", BankNo ));
        ReturnError = STFLASH_GetParams( Handle0, &GetParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
        ParamsReport( &GetParams_s );

        for (TestBlock = 0; TestBlock < InitParams_s.NumberOfBlocks; TestBlock++)
        {
            TestSize   = BlockData_s[TestBlock].Length;
            TestOffset = 0;
            for ( i = 0; i < TestBlock; i++ )
            {
                TestOffset += BlockData_s[i].Length;
            }

            STFLASH_Print(( "------------------------------------------------------------\n" ));
            STFLASH_Print(( "Bank %u, TestBlock %2u, TestOffset 0x%08x TestSize 0x%08x\n",
                           BankNo, TestBlock, TestOffset, TestSize ));
            STFLASH_Print(( "------------------------------------------------------------\n" ));
   	        ReturnError = STFLASH_BlockUnlock( Handle0,TestOffset );

            /* Erase Bank BankNo Block TestBlock  */

            STFLASH_Print(( "Calling STFLASH_Erase() Bank %u ........\n", BankNo ));
            ReturnError = STFLASH_Erase( Handle0,
                                         TestOffset,
                                         TestSize );
            if (ReturnError != ST_NO_ERROR)
            {
                ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
            }

            /* the following reads all of the erased block   */
            STFLASH_Print(( "Calling STFLASH_Read() Bank %u, ........\n", BankNo ));
            ReturnError = STFLASH_Read( Handle0,
                                        TestOffset,
                                        ReadArray,
                                        TestSize,
                                        &NumberRead );
            if (ReturnError != ST_NO_ERROR)
            {
                ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
            }
            STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                           NumberRead ));

            Match = TRUE;
            if ((ReturnError == ST_NO_ERROR) &&
                (NumberRead  == TestSize))
            {
                ErrorCounter = 0;
                for (i = 0; i < NumberRead; i++)
                {
                    if (ReadArray[i] != ERASED_STATE)
                    {
                        Match = FALSE;
                        STFLASH_Print(( "Mismatch => Erase/ReadArray[%2d] = %02X / %02X\n",
                                       i, ERASED_STATE, (U32)ReadArray[i] ));
                        ErrorCounter++;
                    }
                }

                if (Match)
                {
                    STFLASH_Print(( "Erased data verified with Read of %d bytes\n",
                                   NumberRead ));
                }
                else
                {
                    STFLASH_Print(( "=====> VERIFY ERROR: %u errors out of %u bytes\n",
                                   ErrorCounter, NumberRead ));
                }
            }

            /* Program Bank BankNo, Block TestBlock */

            for (i = 0; i < TestSize; i++)
            {
                WritArray[i] = (U8)(TestSize - i);
                ReadArray[i] = (U8)i;
            }
            STFLASH_Print(( "Calling STFLASH_Write() Bank %u, .......\n", BankNo ));

            ReturnError = STFLASH_Write( Handle0,
                                         TestOffset,
                                         WritArray,
                                         TestSize,
                                         &NumberWrit );

            if (ReturnError != ST_NO_ERROR)
            {
                ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
            }
            STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                          NumberWrit ));

            if (NumberWrit > 0)
            {
                STFLASH_Print(( "Calling STFLASH_Read() Bank %u, ........\n", BankNo ));
                ReturnError = STFLASH_Read( Handle0,
                                            TestOffset,
                                            ReadArray,
                                            TestSize,
                                            &NumberRead );
                if (ReturnError != ST_NO_ERROR)
                {
                    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
                }
                STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                              NumberRead ));
                Match = TRUE;
                if ((ReturnError == ST_NO_ERROR) &&
                    (NumberRead  == TestSize))
                {
                    ErrorCounter = 0;
                    for (i = 0; i < NumberRead; i++)
                    {
                        if (WritArray[i] != ReadArray[i])
                        {
                            Match = FALSE;
                            STFLASH_Print(( "Mismatch => Write/ReadArray[%2d] = %02X / %02X\n",
                                          i, (U32)WritArray[i], (U32)ReadArray[i] ));
                            ErrorCounter++;
                        }
                    }

                    if (Match)
                    {
                        STFLASH_Print(( "Write data verified with Read of %d bytes\n",
                                    NumberRead ));
                    }
                    else
                    {
                        STFLASH_Print(( "=====> VERIFY ERROR: %u errors out of %u bytes\n",
                                    ErrorCounter, NumberRead ));
                    }
                }
            }
        }

        STFLASH_Print(( "------------------------------------------------------------\n" ));

        if (BankNo == 0)
        {
            /* Close Bank 0 */

            STFLASH_Print(( "Calling STFLASH_Close() Bank0 ..........\n" ));
            ReturnError = STFLASH_Close( Handle0 );
            ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

#ifdef STFLASH_BANK_1_BASE
            /* Open Bank 1 */

            STFLASH_Print(( "Calling STFLASH_Open() Bank1 ..........\n" ));
            ReturnError = STFLASH_Open( "Bank1",
                                      &OpenParams_s,
                                      &Handle0 );
            ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
#else
            break;
#endif
        }
    }

    /* Term Bank 0 */
    TermParams_s.ForceTerminate = TRUE;
    STFLASH_Print(( "Calling STFLASH_Term() Bank 0 .........\n" ));
    ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

#ifdef STFLASH_BANK_1_BASE
    /* Term Bank 1 */
    STFLASH_Print(( "Calling STFLASH_Term() Bank 1 .........\n" ));
    ReturnError = STFLASH_Term( "Bank1", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
#endif

    return ErrorCount;
}
#endif/*FLASH_FULLERW*/
/****************************************************************************
Name         : MemLeak()

Description  : Checks for Memory Leak
*****************************************************************************/

int MemLeak( void )
{

    int  ErrorCount = 0;
    ST_ErrorCode_t  ReturnError;
    partition_status_t  pstatus;
    U32 PrevMem,AfterMem;
    ST_Revision_t   RevisionStr;

    STFLASH_Print(( "Commencing Leak Test  ....\n" ));
    STFLASH_Print(( "============================================================\n" ));

    /* Revision string available before Flash Initialized */
    STFLASH_Print(( "Calling STFLASH_GetRevision()\n" ));
    RevisionStr = STFLASH_GetRevision();
    STFLASH_Print(( "Software Revision reported as %s\n", RevisionStr ));
    STFLASH_Print(( "------------------------------------------------------------\n" ));

#ifdef ST_OS21
    if (0 != partition_status(system_partition, &pstatus,(partition_status_flags_t)0))
#else
    if (0 != partition_status(TEST_PARTITION_1, &pstatus,(partition_status_flags_t)0))
#endif
    {
        STFLASH_Print(("partition_status FAILED")) ;
    }

    PrevMem = pstatus.partition_status_free;

    /* Init Bank 0, Vpp 0 */
    InitParams_s.DeviceType      = DEVICE_TYPE;
    InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_0_BASE;
    InitParams_s.VppAddress      = (U32*)STFLASH_VPP_0_ENABLE;
    InitParams_s.MinAccessWidth  = MIN_ACCESS_WIDTH;
    InitParams_s.MaxAccessWidth  = MAX_ACCESS_WIDTH;
    InitParams_s.NumberOfBlocks  = NUM_BLOCKS;
    InitParams_s.Blocks          = BlockData_s;

#if defined(STFLASH_SPI_SUPPORT)
    InitParams_s.IsSerialFlash   = FALSE;
#endif

#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif

    STFLASH_Print(( "FLASH_BANK_0_BASE = %x\n", STFLASH_BANK_0_BASE ));

    STFLASH_Print(( "Calling STFLASH_Init() Bank0 ..........\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

     /* Term Bank 0 */
    TermParams_s.ForceTerminate = FALSE;
    STFLASH_Print(( "Calling STFLASH_Term() Bank 0 .........\n" ));
    ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

#ifdef ST_OS21
    if (0 != partition_status(system_partition, &pstatus,(partition_status_flags_t)0))
#else
    if (0 != partition_status(TEST_PARTITION_1, &pstatus,(partition_status_flags_t)0))
#endif
    {
        STFLASH_Print(("partition_status FAILED")) ;
    }

    AfterMem = pstatus.partition_status_free;

    if (PrevMem == AfterMem)
    {
        STFLASH_Print(("No Errors detected\n"));
    }
    else
    {
    	ErrorCount++;
    }

    STFLASH_Print(("Memory at Start=%d\n",PrevMem));
    STFLASH_Print(("Memory at End  =%d\n",AfterMem));

    STFLASH_Print(( "----------------------------------------------------------\n" ));

    STFLASH_Print(( "Leak test result is: " ));
    STFLASH_Print(( "%d errors\n", ErrorCount ));

    return( ErrorCount );

} /* MemLeak */

/****************************************************************************
Name:           Multibank
Description:    Prints out the stack required for init, term, and
                    a typical sequence of operations.
Parameters:     None
Return value:   None
****************************************************************************/
#if defined(STFLASH_MULTIBANK_SUPPORT)
static void FLASH_Task1(FLASH_TaskParams_t *Params_p)
{
    STFLASH_Params_t        GetParams_s;
    ST_ErrorCode_t          ReturnError;
    int                     ErrorCount = 0;
    BOOL                    Match;
    static U8               ReadArray[BANK_3_BLOCK_SIZE];
    U32                     NumberToRead = 0,NumberRead;
    clock_t                 SnapTime;
    U32                     i = 0;

    /* GetParams for Bank 0 */
    GetParams_s.InitParams.Blocks = GetBlkDat_s;
    STFLASH_Print(( "Calling STFLASH_GetParams() Bank 0 ....\n" ));
    ReturnError = STFLASH_GetParams( Handle0, &GetParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    ParamsReport( &GetParams_s );

    /* the following only checks a very small area of the erased block   */
    STFLASH_Print(( "Calling STFLASH_Read() Bank 0, ........\n" ));

    switch (GetParams_s.InitParams.MinAccessWidth)
    {
        case STFLASH_ACCESS_08_BITS:
            NumberToRead = ARRAY_SIZEM1;
            break;

        case STFLASH_ACCESS_16_BITS:
            NumberToRead = BANK_3_BLOCK_SIZE;
            break;

        case STFLASH_ACCESS_32_BITS:
            NumberToRead = ARRAY_SIZE;
            break;
    }
    if (GetParams_s.InitParams.MinAccessWidth <
        GetParams_s.InitParams.MaxAccessWidth)
    {
        STFLASH_Print(( "Erase verify, Max/Min access transition\n" ));
    }
    else
    {
        STFLASH_Print(( "Erase verify, Max access throughout\n" ));
    }

    SnapTime = STOS_time_now();

    ReturnError = STFLASH_Read( Handle0,
                                BANK_3_OFFSET,
                                ReadArray,
                                BANK_3_BLOCK_SIZE,
                                &NumberRead );

    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                   NumberRead ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    Match = TRUE;
    if ((ReturnError == ST_NO_ERROR) &&
        (NumberRead  == NumberToRead))
    {
        for (i = 0; i < NumberRead; i++)
        {
              if(ReadArray[i] != ERASED_STATE)
              {
                Match = FALSE;
                STFLASH_Print(( "Mismatch => Erase/ReadArray[%2d] = %02X / %02X\n",
                               i, ERASED_STATE, (U32)ReadArray[i] ));
              }
        }

        if (Match)
        {
            STFLASH_Print(( "Erased data verified with Read of %d bytes\n",
                           NumberRead ));
        }

        STFLASH_Print(( "----------------------------------------------------------\n" ));
    }
    Params_p->Error = ReturnError;
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
}
static void FLASH_Task2(FLASH_TaskParams_t *Params_p)
{
    static U8               WriteArray[BANK_2_BLOCK_SIZE];
    static U8               ReadArray[BANK_2_BLOCK_SIZE];
    STFLASH_Params_t        GetParams_s;
    U32                     NumberWritten;
    U32                     i = 0;
    ST_ErrorCode_t          ReturnError;
    int                     ErrorCount = 0;
    clock_t                 SnapTime;
    BOOL Match ;

    /* GetParams for Bank 0 */
    GetParams_s.InitParams.Blocks = GetBlkDat_s;
    STFLASH_Print(( "Calling STFLASH_GetParams() Bank 0 ....\n" ));
    ReturnError = STFLASH_GetParams( Handle1, &GetParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    ParamsReport( &GetParams_s );

    for (i = 0; i < BANK_2_BLOCK_SIZE; i++)
    {
        WriteArray[i] = (U8)i;
    }
    STFLASH_Print(( "Calling STFLASH_Write() Bank 0, .......\n" ));
    STFLASH_Print(( "Maximum access width used throughout ..\n" ));
    SnapTime = STOS_time_now();

    ReturnError = STFLASH_Write( Handle1,
                                 BANK_2_OFFSET,
                                 WriteArray,
                                 BANK_2_BLOCK_SIZE,
                                 &NumberWritten );
    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                   NumberWritten ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
   
    if (NumberWritten > 0)
    {
        STFLASH_Print(( "Calling STFLASH_Read() Bank 0, ........\n" ));
        STFLASH_Print(( "Write verify, Min access use forced ...\n" ));
        SnapTime = STOS_time_now();
        ReturnError = STFLASH_Read( Handle1,
                                    BANK_2_OFFSET,
                                    ReadArray,
                                    BANK_2_BLOCK_SIZE,
                                    &NumberWritten );
        ExTimeReport( SnapTime );
        STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                       NumberWritten ));
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
        Match = TRUE;
        if ((ReturnError == ST_NO_ERROR) &&
           (NumberWritten  == (BANK_2_BLOCK_SIZE )))
        {
            for (i = 0; i < NumberWritten; i++)
            {
                if (WriteArray[i] != ReadArray[i])
                {
                    Match = FALSE;
                    STFLASH_Print(( "Mismatch => Write/ReadArray[%2d] = %02X / %02X\n",
                                   i, (U32)WriteArray[i],
                                  (U32)ReadArray[i] ));
                }
            }

            if (Match)
            {
                STFLASH_Print(( "Write data verified with Read of %d bytes\n",
                               NumberWritten ));
            }

            STFLASH_Print(( "----------------------------------------------------------\n" ));
        }
    }    
}

int MultiBankRWTest(void)
{
    ST_ErrorCode_t    error = ST_NO_ERROR;
    ST_ErrorCode_t    ReturnError;
    int               ErrorCount = 0;
    FLASH_TaskParams_t TaskParams, Task2Params;
    TaskParams.Error  = error;
    Task2Params.Error = error;
    U32 rVal,rVal2;
    
#ifdef ST_OS21
#define STACKSIZE 16*1024
#else
#define STACKSIZE 4*1024
#endif

    STFLASH_Print(("Commencing MultiBank read write test....\n" ));
    STFLASH_Print(("============================================================\n"));

        /* Init Bank 0, Vpp 0 */
        InitParams_s.DeviceType      = DEVICE_TYPE;
        InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_0_BASE;
        InitParams_s.VppAddress      = (U32*)STFLASH_VPP_0_ENABLE;
        InitParams_s.MinAccessWidth  = MIN_ACCESS_WIDTH;
        InitParams_s.MaxAccessWidth  = MAX_ACCESS_WIDTH;
        InitParams_s.NumberOfBlocks  = NUM_BLOCKS;
        InitParams_s.Blocks          = BlockData_s;
        InitParams_s.BankInfo        = BankInfo_s;
        InitParams_s.NumberOfBanks   = NUM_BANKS;

#ifdef ST_OS21
        InitParams_s.DriverPartition = system_partition;
#else
        InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif
        STFLASH_Print(( "FLASH_BANK_0_BASE = %x\n", STFLASH_BANK_0_BASE ));
        STFLASH_Print(( "Calling STFLASH_Init() Bank0 ..........\n" ));
        ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
     
        STFLASH_Print(( "Calling STFLASH_Open() for first Bank..........\n" ));
        OpenParams_s.BankNumber = 3;
        ReturnError = STFLASH_Open( "Bank0",
                                    &OpenParams_s,
                                    &Handle0 );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

   	    STFLASH_Print(( "Calling STFLASH_BlockUnlock() Bank 0 ........\n" ));
   	    ReturnError = STFLASH_BlockUnlock( Handle0,BANK_3_OFFSET );
  	    
        STFLASH_Print(( "Calling STFLASH_Erase() First Bank  ........\n" ));
        ReturnError = STFLASH_Erase( Handle0,
                                     BANK_3_OFFSET,
                                     BANK_3_BLOCK_SIZE);      /*32 * 1024 = 16Kword*/

        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

        STFLASH_Print(( "Calling STFLASH_Open() for second Bank..........\n" ));

        OpenParams_s.BankNumber = 2;
        ReturnError = STFLASH_Open( "Bank0",
                                    &OpenParams_s,
                                    &Handle1);
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
        
  	    STFLASH_Print(( "Calling STFLASH_BlockUnlock() Bank 2 ........\n" ));
 	    
   	    ReturnError = STFLASH_BlockUnlock( Handle1,BANK_2_OFFSET);

        STFLASH_Print(( "Calling STFLASH_Erase() Second Bank ........\n" ));
        ReturnError = STFLASH_Erase( Handle1,
                                     BANK_2_OFFSET,
                                     STFLASH_MAIN_SIZE );

        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

     	rVal = STOS_TaskCreate((void(*)(void *))FLASH_Task1,
		                                &TaskParams,
		                                InitParams_s.DriverPartition,
		                                STACK_SIZE,
		                                NULL,
		                                InitParams_s.DriverPartition,
		                                &TaskParams.Task_p,
		                                NULL,
		                                MIN_USER_PRIORITY,
		                                "Flashbank0",
		                                (task_flags_t) task_flags_no_min_stack_size );
		                                
                               
		rVal2 = STOS_TaskCreate((void(*)(void *))FLASH_Task2,
		                                &Task2Params,
		                                InitParams_s.DriverPartition,
		                                STACK_SIZE,
		                                NULL,
		                                InitParams_s.DriverPartition,
		                                &Task2Params.Task_p,
		                                NULL,
		                                MIN_USER_PRIORITY,
		                                "FLashBank1",
		                                (task_flags_t) task_flags_no_min_stack_size );		                                
	    if (rVal != ST_NO_ERROR)
        {
             /* Unable to create the recieve task */
             error = ST_ERROR_NO_MEMORY;
             STFLASH_Print(("Unable to create task"));
        }
        if (rVal2 != ST_NO_ERROR)
        {
            STFLASH_Print(("Unable to create task"));
        }

        STFLASH_Print(("Waiting for tasks to complete...\n"));
        
        /* Wait for each task before deleting it */
        
        if ( STOS_TaskWait(&Task2Params.Task_p,TIMEOUT_INFINITY) == 0 )
        {
             STOS_TaskDelete(Task2Params.Task_p,
		                   	(partition_t *)InitParams_s.DriverPartition,
		                     NULL,
		                    (partition_t *)InitParams_s.DriverPartition);
        }

        if ( STOS_TaskWait(&TaskParams.Task_p,TIMEOUT_INFINITY) == 0 )
        {
             STOS_TaskDelete(TaskParams.Task_p,
		                   	(partition_t *)InitParams_s.DriverPartition,
		                     NULL,
		                    (partition_t *)InitParams_s.DriverPartition);
        }
      
        if (TaskParams.Error != ST_NO_ERROR ||
       		Task2Params.Error != ST_NO_ERROR)
    	{
       		 STFLASH_Print(( "Error during processing\n " ));
    	}

        error = STFLASH_Close(Handle0);

        if (error != ST_NO_ERROR)
        {
            STFLASH_Print(("Error in closing bank with handle 0 \n"));
            ErrorReport( &ErrorCount, error, ST_NO_ERROR );            
        }
        error = STFLASH_Close(Handle1);

        if (error != ST_NO_ERROR)
        {
            STFLASH_Print(("Error in closing bank with handle 1 \n "));
            ErrorReport( &ErrorCount, error, ST_NO_ERROR );
        }
        STFLASH_Print(("\n"));
        TermParams_s.ForceTerminate = FALSE;
        error = STFLASH_Term("Bank0", &TermParams_s);
        if (error != ST_NO_ERROR)
        {
            STFLASH_Print(("Error terminating, got return code %i\n", error));
            ErrorReport( &ErrorCount, error, ST_NO_ERROR );
        }

        STFLASH_Print(( "----------------------------------------------------------\n" ));

        STFLASH_Print(( "Multi bank test result is: " ));
        STFLASH_Print(( "%d errors\n", ErrorCount ));

        return( ErrorCount );
}
#endif/*STFLASH_MULTIBANK_SUPPORT*/

/****************************************************************************
Name         : QueryCFI()

Description  : CFI Query
*****************************************************************************/
int QueryCFI( void )
{
    ST_ErrorCode_t          error = ST_NO_ERROR;
    int stored = 0;
    int ErrorCount = 0;

    STFLASH_Print(( "\n============================================================\n" ));
    STFLASH_Print(( "Commencing CFI Query test ....\n" ));
    STFLASH_Print(( "============================================================\n" ));


    /* Build initparams */
    InitParams_s.DeviceType      = DEVICE_TYPE;
    InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_0_BASE;
    InitParams_s.VppAddress      = (U32*)STFLASH_VPP_0_ENABLE;
    InitParams_s.MinAccessWidth  = MIN_ACCESS_WIDTH;
    InitParams_s.MaxAccessWidth  = MAX_ACCESS_WIDTH;
    InitParams_s.NumberOfBlocks  = NUM_BLOCKS;
    InitParams_s.Blocks          = BlockData_s;
#if defined(STFLASH_SPI_SUPPORT)
    InitParams_s.IsSerialFlash   = FALSE;
#endif
#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif

    /* Initialise */
    error = STFLASH_Init("flash0", &InitParams_s);
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Error initializing, got return code %i\n", error));
        ErrorReport( &ErrorCount, error, ST_NO_ERROR );
    }

    /* Open Bank 0 */
    error = STFLASH_Open("flash0", &OpenParams_s, &Handle0 );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Opening bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    error = STFLASH_GetCFI( Handle0, &QueryCFI_s );
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Getting bank 0 CFI: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }
    CFIInfo(&QueryCFI_s);

    error = STFLASH_Close(Handle0);

    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Closing bank 0: "));
        ErrorReport(&stored, error, ST_NO_ERROR);
    }

    TermParams_s.ForceTerminate = FALSE;
    error = STFLASH_Term("flash0", &TermParams_s);
    if (error != ST_NO_ERROR)
    {
        STFLASH_Print(("Error terminating, got return code %i\n", error));
        ErrorReport( &ErrorCount, error, ST_NO_ERROR );
    }

    STFLASH_Print(( "----------------------------------------------------------\n" ));

    STFLASH_Print(( "CFI Query test result is: " ));
    STFLASH_Print(( "%d errors\n", ErrorCount ));

    return( ErrorCount );
}

/****************************************************************************
Name         : NormalUse()

Description  : Performs all the API interface calls in the correct
               sequence, with legal parameters, exercising all the
               Direct Access Flash calls for all hardware supported
               combinations of memory access widths, determined by
               the input parameter values.  Both Flash banks fitted
               to the Evaluation Platform are exercised without
               interleaved Term & Init calls.  This will prove the
               additional support for multiple instances added
               between 1.0.0 and 1.1.0 Driver Releases.
               Note that no errors should be raised during this test.
               Else the first error encountered will be returned.

Parameters   : None

Return Value : ST_ErrorCode_t specified as
               ST_NO_ERROR                  No errors occurred
               ST_ERROR_ALREADY_INITIALIZED More than one Init call w/o Term
               ST_ERROR_UNKNOWN_DEVICE      Open call w/o prior Init
               ST_ERROR_INVALID_HANDLE      Rogue Flash bank reference
               ST_ERROR_BAD_PARAMETER       One or more invalid parameters
               ST_ERROR_TIMEOUT             Timeout error during Erase/Write
               STFLASH_ERROR_WRITE          Error during programming sequence
               STFLASH_ERROR_ERASE          Error during erasure sequence
               STFLASH_ERROR_VPP_LOW        Vpp voltage low during either of
                                            Write or Erase sequences

See Also     : STFLASH_ErrorCode_t
 ****************************************************************************/

int NormalUse( void )
{
    BOOL            Match;
    U32             i;
    U32             NumberRead;
    U32             NumberWrit;
    U32             NumberToRead = 0;

#ifdef STFLASH_BANK_1_BASE
    U32             Offset;
    U32             NumberToWrite;
#endif

    clock_t         SnapTime;

    int  ErrorCount = 0;
    ST_ErrorCode_t  ReturnError;
    ST_Revision_t   RevisionStr;

    static U8              ReadArray[ARRAY_SIZE];
    static U8              WritArray[ARRAY_SIZE];

    STFLASH_Print(( "Commencing NormalUse Test Function ....\n" ));
    STFLASH_Print(( "============================================================\n" ));

    /* Revision string available before Flash Initialized */
    STFLASH_Print(( "Calling STFLASH_GetRevision()\n" ));
    RevisionStr = STFLASH_GetRevision();
    STFLASH_Print(( "Software Revision reported as %s\n", RevisionStr ));
    STFLASH_Print(( "------------------------------------------------------------\n" ));

    /* Init Bank 0, Vpp 0 */

    InitParams_s.DeviceType      = DEVICE_TYPE;
    InitParams_s.BaseAddress     = (U32*)STFLASH_BANK_0_BASE;
    InitParams_s.VppAddress      = (U32*)STFLASH_VPP_0_ENABLE;
    InitParams_s.MinAccessWidth  = MIN_ACCESS_WIDTH;
    InitParams_s.MaxAccessWidth  = MAX_ACCESS_WIDTH;
    InitParams_s.NumberOfBlocks  = NUM_BLOCKS;
    InitParams_s.Blocks          = BlockData_s;
#if defined(STFLASH_SPI_SUPPORT)
    InitParams_s.IsSerialFlash   = FALSE;
#endif
#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif

    STFLASH_Print(( "FLASH_BANK_0_BASE = %x\n", STFLASH_BANK_0_BASE ));
#ifdef STFLASH_BANK_1_BASE
    STFLASH_Print(( "FLASH_BANK_1_BASE = %x\n", STFLASH_BANK_1_BASE ));
#endif
    STFLASH_Print(( "Calling STFLASH_Init() Bank0 ..........\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
       /* Open Bank 0 */
    STFLASH_Print(( "Calling STFLASH_Open() Bank0 ..........\n" ));
    ReturnError = STFLASH_Open( "Bank0",
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    /* GetParams for Bank 0 */
    GetParams_s.InitParams.Blocks = GetBlkDat_s;
    STFLASH_Print(( "Calling STFLASH_GetParams() Bank 0 ....\n" ));
    ReturnError = STFLASH_GetParams( Handle0, &GetParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    ParamsReport( &GetParams_s );

    /* Erase Bank 0 Main Block 0 */

    ReturnError = STFLASH_BlockLock( Handle0, DEBUG_OFFSET );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    ReturnError = STFLASH_BlockUnlock( Handle0, DEBUG_OFFSET );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Erase() Bank 0 ........\n" ));
    SnapTime = STOS_time_now();

    ReturnError = STFLASH_Erase( Handle0,
                                 DEBUG_OFFSET,
                                 STFLASH_MAIN_0_SIZE );

    ExTimeReport( SnapTime );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    /* the following only checks a very small area of the erased block   */
    STFLASH_Print(( "Calling STFLASH_Read() Bank 0, ........\n" ));

    switch (GetParams_s.InitParams.MinAccessWidth)
    {
        case STFLASH_ACCESS_08_BITS:
            NumberToRead = ARRAY_SIZEM1;
            break;

        case STFLASH_ACCESS_16_BITS:
            NumberToRead = ARRAY_SIZEM2;
            break;

        case STFLASH_ACCESS_32_BITS:
            NumberToRead = ARRAY_SIZE;
            break;
    }
    if (GetParams_s.InitParams.MinAccessWidth <
        GetParams_s.InitParams.MaxAccessWidth)
    {
        STFLASH_Print(( "Erase verify, Max/Min access transition\n" ));
    }
    else
    {
        STFLASH_Print(( "Erase verify, Max access throughout\n" ));
    }

    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Read( Handle0,
                                DEBUG_OFFSET,
                                ReadArray,
                                NumberToRead,
                                &NumberRead );

    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                   NumberRead ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    Match = TRUE;
    if ((ReturnError == ST_NO_ERROR) &&
        (NumberRead  == NumberToRead))
    {
        for (i = 0; i < NumberRead; i++)
        {
            if(ReadArray[i] != ERASED_STATE)
            {
                Match = FALSE;
                STFLASH_Print(( "Mismatch => Erase/ReadArray[%2d] = %02X / %02X\n",
                               i, ERASED_STATE, (U32)ReadArray[i] ));
            }
        }

        if (Match)
        {
            STFLASH_Print(( "Erased data verified with Read of %d bytes\n",
                           NumberRead ));
        }

        STFLASH_Print(( "----------------------------------------------------------\n" ));
    }

    /* Program Bank 0, part of Main Block 0 */
    for (i = 0; i < ARRAY_SIZE; i++)
    {
        WritArray[i] = (U8)i;
    }

    STFLASH_Print(( "Calling STFLASH_Write() Bank 0, .......\n" ));
    STFLASH_Print(( "Maximum access width used throughout ..\n" ));
    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Write( Handle0,
                                 DEBUG_OFFSET,
                                 WritArray,
                                 ARRAY_SIZE,
                                 &NumberWrit );
    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                   NumberWrit ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    if (NumberWrit > 0)
    {
        STFLASH_Print(( "Calling STFLASH_Read() Bank 0, ........\n" ));
        STFLASH_Print(( "Write verify, Max access width read ...\n" ));
        SnapTime = STOS_time_now();
        ReturnError = STFLASH_Read( Handle0,
                                    DEBUG_OFFSET,
                                    ReadArray,
                                    ARRAY_SIZE,
                                    &NumberRead );
        ExTimeReport( SnapTime );
        STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                      NumberRead ));
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
        Match = TRUE;
        if ((ReturnError == ST_NO_ERROR) &&
            (NumberRead  == ARRAY_SIZE))
        {
            for (i = 0; i < NumberRead; i++)
            {
                if (WritArray[i] != ReadArray[i])
                {
                    Match = FALSE;
                    STFLASH_Print(( "Mismatch => Write/ReadArray[%2d] = %02X / %02X\n",
                                   i, (U32)WritArray[i], (U32)ReadArray[i] ));
                }
            }

            if (Match)
            {
                STFLASH_Print(( "Write data verified with Read of %d bytes\n",
                              NumberRead ));
            }

            STFLASH_Print(( "----------------------------------------------------------\n" ));
        }
    }

    if (GetParams_s.InitParams.MinAccessWidth <
        GetParams_s.InitParams.MaxAccessWidth)
    {

        /* Program Bank 0, another part of Main Block 0 */

        for (i = 0; i < ARRAY_SIZEM1; i++)
        {
            WritArray[i] = (U8)(ARRAY_SIZEM1 - i);
        }
        STFLASH_Print(( "Calling STFLASH_Write() Bank 0, .......\n" ));
        STFLASH_Print(( "testing Max to Min access transition ..\n" ));
        SnapTime = STOS_time_now();
        ReturnError = STFLASH_Write( Handle0,
                                     FURTHER_IN_0,
                                     WritArray,
                                     ARRAY_SIZEM1,
                                     &NumberWrit );
        ExTimeReport( SnapTime );
        STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                       NumberWrit ));
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

        if (NumberWrit > 0)
        {
            STFLASH_Print(( "Calling STFLASH_Read() Bank 0, ........\n" ));
            STFLASH_Print(( "Write verify, Min access use forced ...\n" ));
            SnapTime = STOS_time_now();
            ReturnError = STFLASH_Read( Handle0,
                                        FURTHER_IN_0,
                                        ReadArray,
                                        ARRAY_SIZEM1,
                                        &NumberRead );
            ExTimeReport( SnapTime );
            STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                           NumberRead ));
            ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
            Match = TRUE;
            if ((ReturnError == ST_NO_ERROR) &&
               (NumberRead  == ARRAY_SIZEM1))
            {
                for (i = 0; i < NumberRead; i++)
                {
                    if (WritArray[i] != ReadArray[i])
                    {
                        Match = FALSE;
                        STFLASH_Print(( "Mismatch => Write/ReadArray[%2d] = %02X / %02X\n",
                                       i, (U32)WritArray[i],
                                      (U32)ReadArray[i] ));
                    }
                }

                if (Match)
                {
                    STFLASH_Print(( "Write data verified with Read of %d bytes\n",
                                   NumberRead ));
                }

                STFLASH_Print(( "----------------------------------------------------------\n" ));
            }
        }
    }

#ifdef STFLASH_BANK_1_BASE
    /* Init Bank 1, Vpp 1, configured as 16-bit wide devices
     * where possible in order to exercise remaining width
     * paths of code.  Note that Bank 0 is still Open,
     * proving multi-bank support.
     */

    InitParams_s.BaseAddress = (U32*)STFLASH_BANK_1_BASE;
    InitParams_s.VppAddress  = (U32*)STFLASH_VPP_1_ENABLE;
    if (MIN_ACCESS_WIDTH <= STFLASH_ACCESS_16_BITS)
    {
        InitParams_s.MinAccessWidth = STFLASH_ACCESS_16_BITS;
    }
    else
    {
        InitParams_s.MinAccessWidth = STFLASH_ACCESS_32_BITS;
    }
    STFLASH_Print(( "Calling STFLASH_Init() Bank 1, 16 bit .\n" ));
    ReturnError = STFLASH_Init( "Bank1", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    /* Open Bank 1 */

    STFLASH_Print(( "Calling STFLASH_Open() Bank1 ..........\n" ));
    ReturnError = STFLASH_Open( "Bank1",
                                &OpenParams_s,
                                &Handle1 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );


    /* GetParams for Bank 1 */

    GetParams_s.InitParams.Blocks = GetBlkDat_s;
    STFLASH_Print(( "Calling STFLASH_GetParams() Bank 1 ....\n" ));
    ReturnError = STFLASH_GetParams( Handle1, &GetParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    ParamsReport( &GetParams_s );

    /* Program Bank 1 before Erase test */
    /* Erase Bank 1 Main Block 1 */

    STFLASH_Print(( "Calling STFLASH_Erase() Bank 1 ........\n" ));
    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Erase( Handle1,
                                 STFLASH_MAIN_1_OFFS,
                                 STFLASH_MAIN_1_SIZE );
    ExTimeReport( SnapTime );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    /* the following only checks a very small area of the erased block */
    STFLASH_Print(( "Calling STFLASH_Read() Bank 1, ........\n" ));

    switch (GetParams_s.InitParams.MinAccessWidth)
    {
        case STFLASH_ACCESS_16_BITS:
            STFLASH_Print(( "Erase verify, Min(16) access throughout\n" ));
            Offset        = MISS32_BLK_1;
            NumberToRead  = ARRAY_SIZEM2;
            break;

        case STFLASH_ACCESS_32_BITS:
            STFLASH_Print(( "Erase verify, Min(32) access throughout\n" ));
            Offset        = STFLASH_MAIN_1_OFFS;;
            NumberToRead  = ARRAY_SIZE;
            break;
    }

    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Read( Handle1,
                                Offset,
                                ReadArray,
                                NumberToRead,
                                &NumberRead );
    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                   NumberRead ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    Match = TRUE;
    if ((ReturnError == ST_NO_ERROR) &&
        (NumberRead  == NumberToRead))
    {
        for (i = 0; i < NumberRead; i++)
        {
            if (ReadArray[i] != ERASED_STATE)
            {
                Match = FALSE;
                STFLASH_Print(( "Mismatch => Erase/ReadArray[%2d] = %02X / %02X\n",
                               i, ERASED_STATE, (U32)ReadArray[i] ));
            }
        }

        if (Match)
        {
            STFLASH_Print(( "Erased data verified with Read of %d bytes\n",
                NumberRead ));
        }

        STFLASH_Print(( "----------------------------------------------------------\n" ));
    }


    /* Program Bank 1, part of Main Block 1 */

    for (i = 0; i < ARRAY_SIZE; i++)
    {
        WritArray[i] = (U8)i;
        ReadArray[i] = 0;
    }
    STFLASH_Print(( "Calling STFLASH_Write() Bank 1, .......\n" ));
    if (GetParams_s.InitParams.MinAccessWidth == STFLASH_ACCESS_32_BITS)
    {
        STFLASH_Print(( "Min access width (32) used throughout .\n" ));
        Offset = INTO_BLOCK_1 & ~(STFLASH_ACCESS_32_BITS - 1);
        NumberToWrite = ARRAY_SIZE;
    }
    else
    {
        STFLASH_Print(( "Min access width (16) used throughout .\n" ));
        Offset = INTO_BLOCK_1;
        NumberToWrite = ARRAY_SIZEM2;
    }

    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Write( Handle1,
                                 Offset,
                                 WritArray,
                                 NumberToWrite,
                                 &NumberWrit );
    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                  NumberWrit ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Read() Bank 1, ........\n" ));
    STFLASH_Print(( "Write verify, max to min width access .\n" ));
    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Read( Handle1,
                                Offset,
                                ReadArray,
                                NumberWrit,
                                &NumberRead );
    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                   NumberRead ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    Match = TRUE;
    if ((ReturnError == ST_NO_ERROR) &&
        (NumberRead  == NumberWrit))
    {
        for (i = 0; i < NumberRead; i++)
        {
            if (WritArray[i] != ReadArray[i])
            {
                Match = FALSE;
                STFLASH_Print(( "Mismatch => Write/ReadArray[%2d] = %02X / %02X\n",
                               i, (U32)WritArray[i], (U32)ReadArray[i] ));
            }
        }

        if (Match)
        {
            STFLASH_Print(( "Write data verified with Read of %d bytes\n",
                           NumberRead ));
        }

        STFLASH_Print(( "----------------------------------------------------------\n" ));
    }
#endif

    /* Re-Read data in Bank 0 to prove multiple access works */

    STFLASH_Print(( "Calling STFLASH_Read() Bank 0, ........\n" ));
    STFLASH_Print(( "to verify Bank 0 accessibility ........\n" ));
    SnapTime = STOS_time_now();
    ReturnError = STFLASH_Read( Handle0,
                                DEBUG_OFFSET,
                                ReadArray,
                                ARRAY_SIZE,
                                &NumberRead );
    ExTimeReport( SnapTime );
    STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                  NumberRead ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    Match = TRUE;
    if ((ReturnError == ST_NO_ERROR) &&
        (NumberRead  == ARRAY_SIZE))
    {
        for (i = 0; i < ARRAY_SIZE; i++)
        {
            if (WritArray[i] != ReadArray[i])
            {
                Match = FALSE;
                STFLASH_Print(( "Mismatch => Write/ReadArray[%2d] = %02X / %02X\n",
                               i, (U32)WritArray[i], (U32)ReadArray[i] ));
            }
        }

        if (Match)
        {
            STFLASH_Print(( "Write data verified with Read of %d bytes\n",
                           NumberRead ));
        }

        STFLASH_Print(( "----------------------------------------------------------\n" ));
    }


    /* Close Bank 0 */
    STFLASH_Print(( "Calling STFLASH_Close() Bank 0 ........\n" ));
    ReturnError = STFLASH_Close( Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );


    /* Term Bank 0 */
    TermParams_s.ForceTerminate = FALSE;
    STFLASH_Print(( "Calling STFLASH_Term() Bank 0 .........\n" ));
    ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );


#ifdef STFLASH_BANK_1_BASE
    /* Term Bank 1 without prior Close */

    TermParams_s.ForceTerminate = TRUE;
    STFLASH_Print(( "Calling STFLASH_Term() Bank 1 (forced) \n" ));
    ReturnError = STFLASH_Term( "Bank1", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
#endif
    STFLASH_Print(( "----------------------------------------------------------\n" ));

    STFLASH_Print(( "Normal Use test result is: " ));
    STFLASH_Print(( "%d errors\n", ErrorCount ));

    return( ErrorCount );
}


/****************************************************************************
Name         : ErrantUse()

Description  : Performs API interface calls, generally mis-sequenced,
               with illegal parameters, or with the wrong Vpp bank
               selected.  This is intended to exercise as much of the
               error checking built into the routines as is practical.
               Note that errors should be raised during this test,
               but these MUST be the expected ones.  If this is the
               case, an overall pass will be reported.

Parameters   : None

Return Value : ST_ErrorCode_t specified as
               ST_NO_ERROR                  No errors occurred
               ST_ERROR_ALREADY_INITIALIZED More than one Init call w/o Term
               ST_ERROR_UNKNOWN_DEVICE      Open call w/o prior Init
               ST_ERROR_INVALID_HANDLE      Rogue Handle value passed
               ST_ERROR_BAD_PARAMETER       One or more invalid parameters
               ST_ERROR_TIMEOUT             Timeout limit reached
               STFLASH_ERROR_WRITE          Error during programming sequence
               STFLASH_ERROR_ERASE          Error during erasure sequence
               STFLASH_ERROR_VPP_LOW        Vpp voltage low during either of
                                            Write or Erase sequences


See Also     : STFLASH_ErrorCode_t
 ****************************************************************************/

int ErrantUse( void )
{
    U32             NumberRead;
    U32             NumberWrit;

    int  ErrorCount = 0;
    ST_ErrorCode_t  ReturnError;
    static U8              ReadArray[ARRAY_SIZE];
    static U8              WritArray[ARRAY_SIZE];
    STFLASH_Print(( "\n" ));
    STFLASH_Print(( "============================================================\n" ));
    STFLASH_Print(( "Commencing ErrantUse Test Function ..\n" ));
    STFLASH_Print(( "============================================================\n" ));

    /* Try to Open without a prior Init */

    STFLASH_Print(( "Calling STFLASH_Open() Bank0 w/o Init .\n" ));
    ReturnError = STFLASH_Open( "Bank0",
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_UNKNOWN_DEVICE );


    /* Exercise the Init error handling, including a successful call */

    InitParams_s.BaseAddress    = (U32*)STFLASH_BANK_0_BASE;
    InitParams_s.VppAddress     = (U32*)STFLASH_VPP_0_ENABLE;
    InitParams_s.MinAccessWidth = MIN_ACCESS_WIDTH;
    InitParams_s.MaxAccessWidth = MAX_ACCESS_WIDTH;
    InitParams_s.NumberOfBlocks = NUM_BLOCKS;
    InitParams_s.Blocks         = BlockData_s;
#if defined(STFLASH_SPI_SUPPORT)
    InitParams_s.IsSerialFlash  = FALSE;
#endif
#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1;
#endif

    STFLASH_Print(( "Calling STFLASH_Init(), NULL Name ptr. \n" ));
    ReturnError = STFLASH_Init( NULL, &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Init(), NUL DeviceName \n" ));
    ReturnError = STFLASH_Init( "", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Init(), too long Name .\n" ));
    ReturnError = STFLASH_Init( "TooLongDeviceName", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

#if !defined(ST_8010) && !defined(ST_5525)
    InitParams_s.BaseAddress = NULL;    /* "forgotten" BaseAddress pointer */
    STFLASH_Print(( "Calling STFLASH_Init(), NULL BaseAddr. \n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );
#endif

    InitParams_s.BaseAddress = (U32*)STFLASH_BANK_0_BASE; /* corrected value */
    InitParams_s.NumberOfBlocks = 0; /* no block data or count omitted */
    STFLASH_Print(( "Calling STFLASH_Init(), zero No. Blocks\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );
    InitParams_s.NumberOfBlocks = NUM_BLOCKS; /* corrected value */

    InitParams_s.Blocks = NULL; /* STFLASH_Block_t array ptr. omitted */
    STFLASH_Print(( "Calling STFLASH_Init(), NULL Blocks ptr\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );
    InitParams_s.Blocks = BlockData_s; /* corrected value */

    InitParams_s.DriverPartition = NULL; /* Driver partition  ptr. omitted */
    STFLASH_Print(( "Calling STFLASH_Init(), NULL Driver partition ptr\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );
#ifdef ST_OS21
    InitParams_s.DriverPartition = system_partition;
#else
    InitParams_s.DriverPartition = TEST_PARTITION_1; /* corrected value */
#endif

    STFLASH_Print(( "Calling STFLASH_Init() with no errors .\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Init() 2nd time no Term\n" ));
    ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_ALREADY_INITIALIZED );

    /* exercise API routines with wrong handle */

    GetParams_s.InitParams.Blocks = GetBlkDat_s;
    STFLASH_Print(( "Calling STFLASH_GetParams() w/o Open ..\n" ));
    ReturnError = STFLASH_GetParams( WRONG_HANDLE, &GetParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_INVALID_HANDLE );

    STFLASH_Print(( "Calling STFLASH_Read() w/o Open .......\n" ));
    ReturnError = STFLASH_Read( WRONG_HANDLE,
                                STFLASH_MAIN_0_OFFS,
                                ReadArray,
                                ARRAY_SIZE,
                                &NumberRead );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_INVALID_HANDLE );

    STFLASH_Print(( "Calling STFLASH_Erase() w/o Open ......\n" ));
    ReturnError = STFLASH_Erase( WRONG_HANDLE,
                                 STFLASH_MAIN_0_OFFS,
                                 STFLASH_MAIN_0_SIZE );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_INVALID_HANDLE );

    STFLASH_Print(( "Calling STFLASH_Write() w/o Open ......\n" ));
    ReturnError = STFLASH_Write( WRONG_HANDLE,
                                 STFLASH_MAIN_0_OFFS,
                                 WritArray,
                                 ARRAY_SIZE,
                                 &NumberWrit );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_INVALID_HANDLE );


    /* exercise the Open error handling, including a valid call */

    STFLASH_Print(( "Calling STFLASH_Open(), NULL Name .....\n" ));
    ReturnError = STFLASH_Open( NULL,
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Open(), wrong Name ....\n" ));
    ReturnError = STFLASH_Open( "different",
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_UNKNOWN_DEVICE );

    STFLASH_Print(( "Calling STFLASH_Open(), NULL Handle ptr\n" ));
    ReturnError = STFLASH_Open( "Bank0",
                                &OpenParams_s,
                                NULL );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Open(), no errors .....\n" ));
    ReturnError = STFLASH_Open( "Bank0",
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Open() a second time ..\n" ));
    ReturnError = STFLASH_Open( "Bank0",
                                &OpenParams_s,
                                &Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_NO_FREE_HANDLES );


    /* exercise API calls with various errors */

    STFLASH_Print(( "Calling STFLASH_GetParams(), NULL ptr. \n" ));
    ReturnError = STFLASH_GetParams( Handle0, NULL );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Read(), zero bytes ....\n" ));
    ReturnError = STFLASH_Read( Handle0,
                                INTO_BLOCK_0,
                                ReadArray,
                                0,
                                &NumberRead );
    STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                   NumberRead ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Read() off device end .\n" ));
    ReturnError = STFLASH_Read( Handle0,
                                NEAR_MEM_END,
                                ReadArray,
                                ARRAY_SIZE,
                                &NumberRead );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Erase() off a blk start\n" ));
    ReturnError = STFLASH_Erase( Handle0,
                                 INTO_BLOCK_0,
                                 STFLASH_MAIN_0_SIZE );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Erase(), wrong length .\n" ));
    ReturnError = STFLASH_Erase( Handle0,
                                 STFLASH_MAIN_0_OFFS,
                                 NOT_BLOCK_SIZE );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Write(), zero bytes ...\n" ));
    ReturnError = STFLASH_Write( Handle0,
                                 INTO_BLOCK_0,
                                 WritArray,
                                 0,
                                 &NumberWrit );
    STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                   NumberWrit ));
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Write() off device end \n" ));
    ReturnError = STFLASH_Write( Handle0,
                                 NEAR_MEM_END,
                                 WritArray,
                                 ARRAY_SIZE,
                                 &NumberWrit );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );
    /* exercise Term with Handle open, unforced */

    TermParams_s.ForceTerminate = FALSE;
    STFLASH_Print(( "Calling STFLASH_Term(), Handle open ...\n" ));
    ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_OPEN_HANDLE );


    /* exercise Close error handling, including a valid call */

    STFLASH_Print(( "Calling STFLASH_Close(), bad Handle ...\n" ));
    ReturnError = STFLASH_Close( WRONG_HANDLE );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_INVALID_HANDLE );

    STFLASH_Print(( "Calling STFLASH_Close() with no errors \n" ));
    ReturnError = STFLASH_Close( Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Close() a second time .\n" ));
    ReturnError = STFLASH_Close( Handle0 );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_INVALID_HANDLE );


    /* exercise remaining Term error handling, including a valid call */

    STFLASH_Print(( "Calling STFLASH_Term(), NULL DeviceName\n" ));
    ReturnError = STFLASH_Term( NULL, &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

    STFLASH_Print(( "Calling STFLASH_Term(), differing Name \n" ));
    ReturnError = STFLASH_Term( "NotTheSame", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_UNKNOWN_DEVICE );

    STFLASH_Print(( "Calling STFLASH_Term() with no errors .\n" ));
    ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

    STFLASH_Print(( "Calling STFLASH_Term() again, else OK .\n" ));
    ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
    ErrorReport( &ErrorCount, ReturnError, ST_ERROR_UNKNOWN_DEVICE );

    /* exercise Erase/Write programming failure handling */
    if (InitParams_s.DeviceType == STFLASH_M28F411)
    {
        /* Only run these tests on devices that support Vpp */
        InitParams_s.VppAddress = (U32*)STFLASH_VPP_1_ENABLE;
        STFLASH_Print(( "Calling STFLASH_Init(), wrong Vpp bank \n" ));
        ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

        STFLASH_Print(( "Calling STFLASH_Open() with no errors .\n" ));
        ReturnError = STFLASH_Open( "Bank0",
                                    &OpenParams_s,
                                    &Handle0 );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

        STFLASH_Print(( "Calling STFLASH_GetParams(), check Vpp \n" ));
        ReturnError = STFLASH_GetParams( Handle0, &GetParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
        ParamsReport( &GetParams_s );

        STFLASH_Print(( "Calling STFLASH_Erase(), wrong Vpp on .\n" ));
        ReturnError = STFLASH_Erase( Handle0,
                                 STFLASH_MAIN_1_OFFS,
                                     STFLASH_MAIN_1_SIZE );
        ErrorReport( &ErrorCount, ReturnError, STFLASH_ERROR_ERASE );

        STFLASH_Print(( "Calling STFLASH_Write(), wrong Vpp on .\n" ));
        ReturnError = STFLASH_Write( Handle0,
                                     INTO_BLOCK_1,
                                     WritArray,
                                     ARRAY_SIZE,
                                     &NumberWrit );
        STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                       NumberWrit ));
        ErrorReport( &ErrorCount, ReturnError, STFLASH_ERROR_WRITE );

        TermParams_s.ForceTerminate = TRUE;
        STFLASH_Print(( "Calling STFLASH_Term(), clean (forced) \n" ));
        ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

        /* exercise the 16 bit minimum width parameter checking.
         *  Note that Vpp is still wrong, but access calls should
         *  exit without attempt to access the Flash devices.
         */

        InitParams_s.MinAccessWidth = STFLASH_ACCESS_16_BITS;
        STFLASH_Print(( "Calling STFLASH_Init(), clean, 16 bit .\n" ));
        ReturnError = STFLASH_Init( "Bank0", &InitParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
        STFLASH_Print(( "Calling STFLASH_Open() with no errors .\n" ));
        ReturnError = STFLASH_Open( "Bank0",
                                    &OpenParams_s,
                                    &Handle0 );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );

        STFLASH_Print(( "Calling STFLASH_Write(), odd aligned ..\n" ));
        ReturnError = STFLASH_Write( Handle0,
                                     INTO_BLOCK_1,
                                     &WritArray[1], /* odd byte aligned */
                                     ARRAY_SIZE,
                                     &NumberWrit );
        STFLASH_Print(( "NumberActuallyWritten reported as %d bytes\n",
                       NumberWrit ));
        ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

        STFLASH_Print(( "Calling STFLASH_Read(), odd byte length\n" ));
        ReturnError = STFLASH_Read( Handle0,
                                    STFLASH_MAIN_0_OFFS,
                                    ReadArray,
                                    ARRAY_SIZEM1,
                                    &NumberRead );
        STFLASH_Print(( "NumberActuallyRead reported as %d bytes\n",
                       NumberRead ));
        ErrorReport( &ErrorCount, ReturnError, ST_ERROR_BAD_PARAMETER );

        TermParams_s.ForceTerminate = TRUE;
        STFLASH_Print(( "Calling STFLASH_Term(), clean (forced) \n" ));
        ReturnError = STFLASH_Term( "Bank0", &TermParams_s );
        ErrorReport( &ErrorCount, ReturnError, ST_NO_ERROR );
    }

    STFLASH_Print(( "Errant use test result is " ));
    STFLASH_Print(( "%d errors\n", ErrorCount ));

    return( ErrorCount );
}


/****************************************************************************
Name         : ErrorReport()

Description  : Expands the returned error code to a message string,
               followed by the expected code/message if different.

Parameters   : ST_ErrorCode_t pointer to an error store, the latest
               ST_ErrorCode_t error code returned, followed by the
               ST_ErrorCode_t expected error code.

Return Value : none

See Also     : STFLASH_ErrorCode_t
 ****************************************************************************/

void ErrorReport( int *ErrorCount,
                  ST_ErrorCode_t ErrorGiven,
                  ST_ErrorCode_t ExpectedErr )
{
    ST_ErrorCode_t  Temp = ErrorGiven;

    switch (Temp)
    {
        case ST_NO_ERROR:
            STFLASH_Print(( "ST_NO_ERROR - Successful Return\n" ));
            break;

        case ST_ERROR_ALREADY_INITIALIZED:
            STFLASH_Print(( "ST_ERROR_ALREADY_INITIALIZED - Prior Init call w/o Term\n" ));
            break;

        case ST_ERROR_FEATURE_NOT_SUPPORTED:
            STFLASH_Print(( "ST_ERROR_FEATURE_NOT_SUPPORTED - Device mismatch\n" ));
            break;

        case ST_ERROR_UNKNOWN_DEVICE:
            STFLASH_Print(( "ST_ERROR_UNKNOWN_DEVICE - Init call must precede access\n" ));
            break;

        case ST_ERROR_INVALID_HANDLE:
            STFLASH_Print(( "ST_ERROR_INVALID_HANDLE - Rogue Handle value or Closed\n" ));
            break;

        case ST_ERROR_OPEN_HANDLE:
            STFLASH_Print(( "ST_ERROR_OPEN_HANDLE - Term called with Open Handle\n" ));
            break;

        case ST_ERROR_BAD_PARAMETER:
            STFLASH_Print(( "ST_ERROR_BAD_PARAMETER - Parameter(s) out of valid range\n" ));
            break;

        case ST_ERROR_NO_FREE_HANDLES:
            STFLASH_Print(( "ST_ERROR_NO_FREE_HANDLES - DeviceName already Open\n" ));
            break;

        case ST_ERROR_TIMEOUT:
            STFLASH_Print(( "ST_ERROR_TIMEOUT - Timeout limit reached\n" ));
            break;

        case STFLASH_ERROR_WRITE:
            STFLASH_Print(( "STFLASH_ERROR_WRITE - Error during Flash Write\n" ));
            break;

        case STFLASH_ERROR_ERASE:
            STFLASH_Print(( "STFLASH_ERROR_ERASE - Error during Flash Erase\n" ));
            break;

        case STFLASH_ERROR_VPP_LOW:
            STFLASH_Print(( "STFLASH_ERROR_VPP_LOW - Flash Vpp Voltage too low\n" ));
            break;
			
        default:
            STFLASH_Print(( "*** Unrecognised return code  ***\n" ));
        }

        if (ErrorGiven != ExpectedErr)
        {
            (*ErrorCount)++;
        }

    STFLASH_Print(( "----------------------------------------------------------\n" ));
}



/****************************************************************************
Name         : ExTimeReport()

Description  : Outputs the Execution Time

Parameters   : clock_t SnapTime taken before driver function entry

Return Value : none

See Also     :
 ****************************************************************************/

void ExTimeReport( clock_t SnapTime )
{
    clock_t CurrTime, DiffTime;


    CurrTime = STOS_time_now();
    DiffTime = STOS_time_minus( CurrTime, SnapTime );

    STFLASH_Print(( "Execution time taken was %d slow ticks\n", (U32)DiffTime ));
}


/****************************************************************************
Name         : ParamsReport()

Description  : Outputs the GetParams_s values as text

Parameters   : STFLASH_GetParams_t pointer to returned Init data

Return Value : none

See Also     : STFLASH_Params_t
 ****************************************************************************/

void ParamsReport( STFLASH_Params_t *RetParams )
{
    U32 i;
    STFLASH_Block_t   *RetBlock_p;

    switch (RetParams->InitParams.DeviceType)
    {
        case STFLASH_M28F411:
            STFLASH_Print(( "DeviceType reported as STFLASH_M28F411\n" ));
            break;
        case STFLASH_M29W800T:
            STFLASH_Print(( "DeviceType reported as STFLASH_M29W800T\n" ));
            break;
        case STFLASH_M29W160BT:
            STFLASH_Print(( "DeviceType reported as STFLASH_M29W160BT\n" ));
            break;
        case STFLASH_AM29LV160D:          /* Works the same way as M29W800T */
            STFLASH_Print(( "DeviceType reported as STFLASH_AM29LV160D\n" ));
            break;
        case STFLASH_E28F640:              /* Works the same way as M28F411 */
            STFLASH_Print(( "DeviceType reported as STFLASH_E28F640\n" ));
            break;
        case STFLASH_M28W320CB:
            STFLASH_Print(( "DeviceType reported as STFLASH_M28W320CB\n" ));
            break;
        case STFLASH_M58LW032:
            STFLASH_Print(( "DeviceType reported as STFLASH_M58LW032\n" ));
            break;
        case STFLASH_M58LW064D:
            STFLASH_Print(( "DeviceType reported as STFLASH_M58LW064D\n" ));
            break;

        case STFLASH_M28W640FS:
            STFLASH_Print(( "DeviceType reported as STFLASH_M28W640FS\n" ));
            break;

        case STFLASH_M58LT128GS:
            STFLASH_Print(( "DeviceType reported as STFLASH_M58LT128GS\n" ));
            break;
  	    case STFLASH_M58LT256GS:
            STFLASH_Print(( "DeviceType reported as STFLASH_M58LT1256GS\n" ));
            break;            
        default:
            STFLASH_Print(( "Unknown DeviceType\n" ));
            break;
    }

#if !defined(ST_8010)  && !defined(ST_5525)
    switch ((U32)RetParams->InitParams.BaseAddress)
    {
        case STFLASH_BANK_0_BASE:
            STFLASH_Print(( "BaseAddress reported as STFLASH_BANK_0_BASE\n" ));
            break;

#ifdef STFLASH_BANK_1_BASE
        case STFLASH_BANK_1_BASE:
            STFLASH_Print(( "BaseAddress reported as STFLASH_BANK_1_BASE\n" ));
            break;
#endif
        default:
        STFLASH_Print(( "BaseAddress incorrectly reported as 0x%8X\n",
                       (U32)RetParams->InitParams.BaseAddress ));
    }
#endif /* 8010 */

    if ((U32)RetParams->InitParams.VppAddress == STFLASH_VPP_0_ENABLE)
    {
        STFLASH_Print(( "VppAddress reported as STFLASH_VPP_0_ENABLE\n" ));
    }
    else if ((U32)RetParams->InitParams.VppAddress == STFLASH_VPP_1_ENABLE)
    {
        STFLASH_Print(( "VppAddress reported as STFLASH_VPP_1_ENABLE\n" ));
    }
    else
    {
        STFLASH_Print(( "VppAddress unrecognized, reported as 0x%8X\n",
                      (U32)RetParams->InitParams.VppAddress ));
    }

    STFLASH_Print(( "MinAccessWidth reported as %d\n",
                   RetParams->InitParams.MinAccessWidth ));

    STFLASH_Print(( "MaxAccessWidth reported as %d\n",
                   RetParams->InitParams.MaxAccessWidth ));

    STFLASH_Print(( "Number of Blocks reported as %d\n",
                   RetParams->InitParams.NumberOfBlocks ));

    RetBlock_p = RetParams->InitParams.Blocks;

    for (i = 0; i < RetParams->InitParams.NumberOfBlocks; i++)
    {
        switch (RetBlock_p[i].Type)
        {
            case STFLASH_EMPTY_BLOCK:
                STFLASH_Print(( "Empty Block \t\t" ));
                break;

            case STFLASH_BOOT_BLOCK:
                STFLASH_Print(( "Boot Block \t\t" ));
                break;

            case STFLASH_PARAMETER_BLOCK:
                STFLASH_Print(( "Parameter Block \t" ));
                break;

            case STFLASH_MAIN_BLOCK:
                STFLASH_Print(( "Main Block \t\t" ));
                break;

            default:
                STFLASH_Print(( "Unknown Block \t\t" ));
        }
        STFLASH_Print(( "0x%08X bytes long\n", RetBlock_p[i].Length ));
    }

    STFLASH_Print(( "Manufacturer Code returned as 0x%08X\n", RetParams->ManufactCode ));
    STFLASH_Print(( "Device Code returned as 0x%08X\n", RetParams->DeviceCode ));

    STFLASH_Print(( "--------------------------------------------------------------\n" ));
}

/****************************************************************************
Name         : CFIInfo()

Description  : Outputs the CFI values as text

Parameters   : STFLASH_CFI_Query_t pointer to returned Init data

Return Value : none

 ****************************************************************************/

void CFIInfo( STFLASH_CFI_Query_t *CFIQuery )
{
    U32  i =0;

    STFLASH_Print(("\nCFI Query String Read = [%s]\n", (char *) CFIQuery->Query_String));
    STFLASH_Print(("Primary table address at offset [0x%2x] hex.\n",CFIQuery->Primary_Table_Address));

    STFLASH_Print(("\nManufacturer Code = [0x%2x] hex\n",CFIQuery->ManufacturerCode));
    STFLASH_Print(("Device Code = [0x%2x] hex\n",CFIQuery->DeviceCode));

    STFLASH_Print(("\n----Voltage and Signal Timing Parameters-------------------\n"));

    STFLASH_Print(("Vcc operating voltage Min is [%d.%d] Volts \n",CFIQuery->Vdd_Min.Volts,
                   CFIQuery->Vdd_Min.MilliVolts));
    STFLASH_Print(("Vcc operating voltage Max is [%d.%d] Volts \n",CFIQuery->Vdd_Max.Volts,
                   CFIQuery->Vdd_Max.MilliVolts));      

    if ((CFIQuery->Vpp_Min.Volts == 0) && (CFIQuery->Vpp_Min.MilliVolts == 0))
    {
	 	 STFLASH_Print(("Device does not support Vpp voltage.\n"));
    }
    else
    {
   		 STFLASH_Print(("Vpp operating voltage is from  [%d.%d] Volts to [%d.%d] Volts  \n",CFIQuery->Vpp_Min.Volts,
                   CFIQuery->Vpp_Min.MilliVolts,CFIQuery->Vpp_Max.Volts,CFIQuery->Vpp_Max.MilliVolts));   			  
    }


    STFLASH_Print(("Typical timeout for single write (micro-sec) : [%8i]us\n",
			CFIQuery->Timeout_Single_Write));

    if(CFIQuery->Timeout_Buffer_Write == 0x00)
    {
	STFLASH_Print(("Buffer writes not supported in this device.\n"));
    }
    else
    {
	STFLASH_Print(("Typical timeout for single write (micro-sec) : [%8i]us\n",
			  CFIQuery->Timeout_Buffer_Write));
    }

    STFLASH_Print(("Typical timeout for block erase (milli-sec) : [%8i]ms\n",
			CFIQuery->Timeout_Block_Erase));

    if(CFIQuery->Timeout_Chip_Erase == 0x00)
    {
	STFLASH_Print(("Chip erase timeouts not supported in this device.\n"));
    }
    else
    {
	STFLASH_Print(("Typical timeout for chip erase (milli-sec) : [%8i]ms\n",
			  CFIQuery->Timeout_Chip_Erase));
    }

    STFLASH_Print(("Maximum timeout for single write (micro-sec) : [%8i]us\n",
			CFIQuery->Max_Timeout_Single_Write));

    if(CFIQuery->Max_Timeout_Buffer_Write == 0x00)
    {
	STFLASH_Print(("Maximum buffer writes not supported in this device.\n"));
    }
    else
    {
	STFLASH_Print(("Maximum timeout for buffer write (micro-sec) : [%8i]us\n",
			  CFIQuery->Max_Timeout_Buffer_Write));
    }

    STFLASH_Print(("Maximum timeout for block erase (milli-sec) : [%8i]ms\n",
			CFIQuery->Max_Timeout_Block_Erase));

    if (CFIQuery->Max_Timeout_Chip_Erase == 0x00)
    {
	 STFLASH_Print(("Chip erase timeouts not supported in this device.\n"));
    }
    else
    {
	 STFLASH_Print(("Maximum timeout for chip erase (milli-sec) : [%8i]ms\n",
			  CFIQuery->Max_Timeout_Chip_Erase));
    }

    STFLASH_Print(("\n----Sector Organization Parameters-------------------\n"));

    STFLASH_Print(("Device size: [%8li] bytes, or [%2i] Mbit\n",
			CFIQuery->Device_Size, (int) (CFIQuery->Device_Size/((long)0x20000))));

    STFLASH_Print(("There are %4i erase block regions in this device:\n",
			CFIQuery->Num_Erase_Blocks));

    for(i=0; i<CFIQuery->Num_Erase_Blocks; i++)
    {
	 STFLASH_Print(("  Size:[%8li] bytes, Number:[%4i]\n",
			  CFIQuery->Erase_Block[i].Sector_Size,
			  CFIQuery->Erase_Block[i].Num_Sectors));
    }

    STFLASH_Print(("\n----Primary Vendor-Specific Extended Parameters----\n"));

    STFLASH_Print(("\nCFI Extended String Read = [%s]\n",
			(char *)CFIQuery->Primary_Extended_Query));

    STFLASH_Print(("Major version: [%3x]\n", CFIQuery->Major_Version));
    STFLASH_Print(("Minor version: [%3x]\n", CFIQuery->Minor_Version));

    STFLASH_Print(("Optional Features: [%3x]\n", CFIQuery->Optional_Feature));
    STFLASH_Print(("Is ChipErase: [%3x]\n", CFIQuery->Is_Chip_Erase));
    STFLASH_Print(("Is Program Suspend: [%3x]\n", CFIQuery->Is_Program_Suspend));
    STFLASH_Print(("Is Temporary Locking?: [%3x]\n", CFIQuery->Is_Locking));
    STFLASH_Print(("Is Queue Erase?: [%3x]\n", CFIQuery->Is_Queue_Erase));
    STFLASH_Print(("Is Instant Block Lock? : [%3x]\n", CFIQuery->Is_Instant_Block_Lock));
    STFLASH_Print(("Is Protection Bits?: [%3x]\n", CFIQuery->Is_Protection_Bits));
    STFLASH_Print(("Is Page Read Supported?: [%3x]\n", CFIQuery->Is_Page_Read));

    STFLASH_Print(("Burst Read: [%3x]\n", CFIQuery->Burst_Read));
    STFLASH_Print(("Erase Suspend : [%3x]\n", CFIQuery->Erase_Suspend));
    STFLASH_Print(("Block Protection : [%3x]\n", CFIQuery->Block_Protect));
    STFLASH_Print(("Vdd Optimum: [%3x]\n", CFIQuery->Vdd_Optimum));
    STFLASH_Print(("Vpp Optimum : [%3x]\n", CFIQuery->Vpp_Optimum));
    STFLASH_Print(("Is OTP supported? : [%3x]\n", CFIQuery->OTP_Protection));
    STFLASH_Print(("Protection Register LSB bits: [%3x]\n", CFIQuery->Protection_Reg_LSB));
    STFLASH_Print(("Protection Register MSB bits: [%3x]\n", CFIQuery->Protection_Reg_MSB));
    STFLASH_Print(("Factory Reprogrammable Bytes : [%3x]\n", CFIQuery->Factory_Prg_Bytes));
    STFLASH_Print(("User Programmable Bytes: [%3x]\n", CFIQuery->User_Prg_Bytes));
    STFLASH_Print(("Page Read 2n Bytes: [%3x]\n", CFIQuery->Page_Read));
    STFLASH_Print(("Synchronous Config: [%3x]\n", CFIQuery->Synchronous_Config));

}
#ifdef USE_TESTTOOL
/*-------------------------------------------------------------------------
 * Function : FlashTest_RegisterCommands
 *            Definition of the macros
 *            (commands and constants to be used with Testtool)
 * Input    :
 * Output   :
 * Return   : TRUE if error, FALSE if success
 * ----------------------------------------------------------------------*/
BOOL FLASH_RegisterTest( void )
{
    BOOL RetErr = FALSE;

    /* API Commands */
    RetErr |= STTST_RegisterCommand("STACKUSAGE", FLASH_StackUsage, "Stack required for init,open & typical sequence");
    RetErr |= STTST_RegisterCommand("NORMALUSE", FLASH_NormalUse, "Uses all the API interface calls");
    RetErr |= STTST_RegisterCommand("FULLERW", FLASH_FullERW, "Erase & Write operations are verified");
    RetErr |= STTST_RegisterCommand("CFI", FLASH_QueryCFI, "CFI Query Information");
    RetErr |= STTST_RegisterCommand("ERRANTUSE", FLASH_ErrantUse, "Perform all error checking");
    RetErr |= STTST_RegisterCommand("LEAK", FLASH_MemLeak, "Check for memory Leak");
#if defined(STFLASH_MULTIBANK_SUPPORT)    
    RetErr |= STTST_RegisterCommand("MULTIBANK_RW", FLASH_MultiBank, "Multibank dual operations");
#endif    
    STFLASH_Print(("FLASH_RegisterTest() : macros registrations "));
    return( RetErr );
}

/*-------------------------------------------------------------------------
 * Function : FLASH_StackUsage
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
static BOOL FLASH_StackUsage( STTST_Parse_t *pars_p, char *Result )
{
    int error=ST_NO_ERROR;
    StackUsage();
    return(error);
}
/*-------------------------------------------------------------------------
 * Function : FLASH_NormalUse
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
static BOOL FLASH_NormalUse( STTST_Parse_t *pars_p, char *Result )
{
    int error;

    error = NormalUse();

    return(error);
}
/*-------------------------------------------------------------------------
 * Function : FLASH_QueryCFI
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
static BOOL FLASH_QueryCFI( STTST_Parse_t *pars_p, char *Result )
{
    int error;

    error = QueryCFI();

    return(error);
}
/*-------------------------------------------------------------------------
 * Function : FLASH_FullERW
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
static BOOL FLASH_FullERW( STTST_Parse_t *pars_p, char *Result )
{
    int error;

    error = FullERWTest();

    return(error);
}
/*-------------------------------------------------------------------------
 * Function : FLASH_ErrantUse
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
static BOOL FLASH_ErrantUse( STTST_Parse_t *pars_p, char *Result )
{
    int error;

    error = ErrantUse();

    return(error);
}

/*-------------------------------------------------------------------------
 * Function : FLASH_MemLeak
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
static BOOL FLASH_MemLeak( STTST_Parse_t *pars_p, char *Result )
{
    int error;

    error = MemLeak();

    return(error);
}
/*-------------------------------------------------------------------------
 * Function : FLASH_MultiBank
 *
 * Input    :
 * Output   :
 * Return   : None
 * ----------------------------------------------------------------------*/
#if defined(STFLASH_MULTIBANK_SUPPORT)   
static BOOL FLASH_MultiBank( STTST_Parse_t *pars_p, char *Result )
{
    int error;

    error = MultiBankRWTest();

    return(error);
}
#endif
#endif/*USE_TESTTOOL*/

