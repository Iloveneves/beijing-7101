/*****************************************************************************
File Name   : space.c

Description : STBLAST space encoding/decoding routines

Copyright (C) 2001 STMicroelectronics

History     : Split from blastint May 2001 (PW)

Reference   :

*****************************************************************************/

/* Includes --------------------------------------------------------------- */
#if !defined(ST_OSLINUX) || defined(LINUX_FULL_USER_VERSION)
#include <stdlib.h>
#include <string.h>
#include "stdio.h"
#endif

#include "stddefs.h"
#include "stblast.h"
#include "blastint.h"
#include "space.h"

#if defined (IR_INVERT)
#include "invinput.h"
#endif

#if defined(STBLAST_NEC_REPEAT_MODE_FEATURE)
#include "stcommon.h"
#endif

#ifdef ST_OSLINUX
/* The allowed drift is defined to be 25% (1/4) */
/* Under Linux, sometimes the drift is more than 20% according to test */
#define DRIFT_THRESHOLD 4
#else
/* The allowed drift is defined to be 20% (1/5) */
#define DRIFT_THRESHOLD 5
#endif

static BOOL SymbolsOkay(const STBLAST_Symbol_t *Incoming,
                        const STBLAST_Symbol_t *Source,
                        const U32 Count);

#if defined(STBLAST_NEC_REPEAT_MODE_FEATURE)
#define REPEAT_MARK_DRIFT_THRESHOLD 90
#define REPEAT_SYMBOL_DRIFT_THRESHOLD 100
#define REPEAT_TIME      108 /* In ms */
#define REPEAT_TIME_MIN  80
#define REPEAT_TIME_MAX  (REPEAT_TIME + (REPEAT_TIME/2))
STBLAST_Symbol_t    NECProtocol_RepeatStartSymbols = {9000,11250};

static U32   PreviousCmd = 0;
static U32   RepeateKeyCount = 0;
#define STBLAST_REPEAT_KEY_IGNORE_COUNT    2 /* number of times the repeat key should be ignored */

#endif

/*****************************************************************************
BLAST_SpaceEncode()

Description:
    This routine will space-encode a user bufer to a symbol
    buffer.

Parameters:
    UserBuf_p,          User buffer to encode
    UserBufSize,        Number of packets to encode
    SymbolBuf_p,        Symbol buffer to store encoded data to
    SymbolBufSize,      Symbol buffer size
    SymbolsEncoded_p,   Stores number of symbols encoded
    ProtocolParams_p,       Protocol parameters to use

Return Value:
    ST_NO_ERROR,        no error.
    ST_ERROR_NO_MEMORY, insufficient symbol buffer space

See Also:
    BLAST_SpaceDecode()
*****************************************************************************/

ST_ErrorCode_t BLAST_SpaceEncode(const U32                  *UserBuf_p,
                                 const U32                  UserBufSize,
                                 STBLAST_Symbol_t           *SymbolBuf_p,
                                 const U32                  SymbolBufSize,
                                 U32                        *SymbolsEncoded_p,
                                 const STBLAST_ProtocolParams_t *ProtocolParams_p
                                )
{
    U32 SymbolCount = 0, i;
    U16 j;
    U8 SymLoop;

    *SymbolsEncoded_p = 0;              /* Reset symbol count */

    /* Check buffer size is large enough for the maximum number of
     * symbols that might be generated by the encoder function.
     */
    if(SymbolBufSize < ((ProtocolParams_p->UserDefined.NumberStartSymbols +
                          ProtocolParams_p->UserDefined.NumberStopSymbols +
                          ProtocolParams_p->UserDefined.NumberPayloadBits) * UserBufSize))
    {
        return ST_ERROR_NO_MEMORY;
    }

    /* Add start symbols at the front, if required */
    for(i = 0; i < UserBufSize; i++, UserBuf_p++)
    {
        for(SymLoop = 0; SymLoop < ProtocolParams_p->UserDefined.NumberStartSymbols; SymLoop++)
        {
            SymbolBuf_p->MarkPeriod =
                MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                        ProtocolParams_p->UserDefined.StartSymbols[SymLoop].MarkPeriod);
            SymbolBuf_p->SymbolPeriod =
                MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                        ProtocolParams_p->UserDefined.StartSymbols[SymLoop].SymbolPeriod);
            SymbolCount++;
            SymbolBuf_p++;
        }

        /* Encode the data bits */

        for(j = ProtocolParams_p->UserDefined.NumberPayloadBits; j > 0; j--)
        {
            if((*UserBuf_p & (1 << (j-1))) != 0)
            {
                /* Bit = 1 */
                SymbolBuf_p->MarkPeriod =
                    MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                            ProtocolParams_p->UserDefined.HighDataSymbol.MarkPeriod);
                SymbolBuf_p->SymbolPeriod =
                    MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                            ProtocolParams_p->UserDefined.HighDataSymbol.SymbolPeriod);
            }
            else
            {
                /* Bit = 0 */
                SymbolBuf_p->MarkPeriod =
                    MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                            ProtocolParams_p->UserDefined.LowDataSymbol.MarkPeriod);
                SymbolBuf_p->SymbolPeriod =
                    MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                            ProtocolParams_p->UserDefined.LowDataSymbol.SymbolPeriod);
            }

            /* Next free symbol */
            SymbolCount++;
            SymbolBuf_p++;
        }

        /* Add stop symbols, if required */
        for(SymLoop = 0; SymLoop < ProtocolParams_p->UserDefined.NumberStopSymbols; SymLoop++)
        {
            SymbolBuf_p->MarkPeriod =
                MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                        ProtocolParams_p->UserDefined.StopSymbols[SymLoop].MarkPeriod);
            SymbolBuf_p->SymbolPeriod =
                MICROSECONDS_TO_SYMBOLS(ProtocolParams_p->UserDefined.SubCarrierFreq,
                                        ProtocolParams_p->UserDefined.StopSymbols[SymLoop].SymbolPeriod);
            SymbolCount++;
            SymbolBuf_p++;
        }
    }

    /* Set symbols encoded count */
    *SymbolsEncoded_p = SymbolCount;

    return ST_NO_ERROR;
}

/*****************************************************************************
BLAST_SpaceDecode()

Description:
    This routine will attempt to decode a symbol buffer into a
    space coded user buffer.
    This function will only decode 'complete' patterns i.e., it
    does not maintain state between calls.  If the function is unable
    to find a complete and valid space coded value in the buffer it will
    not fill the user's buffer.
Parameters:

Return Value:

See Also:
    BLAST_SpaceEncode()
*****************************************************************************/

ST_ErrorCode_t BLAST_SpaceDecode(U32                  *UserBuf_p,
                                 const U32            UserBufSize,
                                 STBLAST_Symbol_t     *SymbolBuf_p,
                                 const U32            SymbolsAvailable,
                                 U32                  *NumDecoded_p,
                                 U32                  *SymbolsUsed_p,
                                 const STBLAST_ProtocolParams_t *ProtocolParams_p, 
                                 U32 TimeDiff)
{

    U32 i;
    U32 Data;
    S32 j;
    U32 MarkDrift, SymbolDrift;
    U32 AllowedMarkDriftH, AllowedSymbolDriftH,
        AllowedMarkDriftL, AllowedSymbolDriftL;

    U32 SymbolsLeft, SymbolsUsed =0, MinSymbols;
    U32 UserCount = 0;
    BOOL ProtocolError = FALSE;

    /* Set number of symbols allowed */
    SymbolsLeft = SymbolsAvailable;
    *SymbolsUsed_p = 0;
    *NumDecoded_p = 0;
    
    /* For only NEC Protocol */
#if defined(STBLAST_NEC_REPEAT_MODE_FEATURE)

    /* Check if key is remain pressed */
    if( TimeDiff > REPEAT_TIME_MIN && TimeDiff < REPEAT_TIME_MAX)
    {

     /* Check Mark Period and Space periods range */
     /* Mark period remains same, space period becomes half */

        if(TRUE == SymbolsOkay(SymbolBuf_p,
                        &NECProtocol_RepeatStartSymbols,
                        ProtocolParams_p->UserDefined.NumberStartSymbols))
        {
            if( (RepeateKeyCount--) && (PreviousCmd != 0))
            {
                if(RepeateKeyCount == 0)
                {
                    SymbolsUsed++;
                    *UserBuf_p = PreviousCmd;
                    UserCount++;
                    *SymbolsUsed_p += SymbolsUsed;
                    UserBuf_p++;
                    *NumDecoded_p = UserCount;
                    RepeateKeyCount = STBLAST_REPEAT_KEY_IGNORE_COUNT;
                    return ST_NO_ERROR;
                 }
                 else
                 {
                    /* ignore this repeate key */
                    return ST_NO_ERROR;
                 }
             }
             else
             {
                 ProtocolError = TRUE;
                *NumDecoded_p = 0;
                return ST_NO_ERROR;
             }
        }
        else
        {
            ProtocolError = TRUE;
            *NumDecoded_p = 0;
            return ST_NO_ERROR;
        }
    }

#else
    UNUSED_PARAMETER(TimeDiff);    
#endif

    /* Quickly check that we have enough symbols to process
     * the request (saves time).
     */
    MinSymbols = ProtocolParams_p->UserDefined.NumberStartSymbols +
                 ProtocolParams_p->UserDefined.NumberStopSymbols +
                 ProtocolParams_p->UserDefined.NumberPayloadBits;
    MinSymbols *= UserBufSize;

    if(SymbolsAvailable < MinSymbols)
        return ST_NO_ERROR;             /* Need more symbols */

    /* Compute allowed drift periods on H and L data symbols */
    AllowedMarkDriftH = ProtocolParams_p->UserDefined.HighDataSymbol.MarkPeriod /
                        DRIFT_THRESHOLD;
    AllowedMarkDriftL = ProtocolParams_p->UserDefined.LowDataSymbol.MarkPeriod /
                        DRIFT_THRESHOLD;
    AllowedSymbolDriftH = ProtocolParams_p->UserDefined.HighDataSymbol.SymbolPeriod /
                          DRIFT_THRESHOLD;
    AllowedSymbolDriftL = ProtocolParams_p->UserDefined.LowDataSymbol.SymbolPeriod /
                          DRIFT_THRESHOLD;

    /* generate correct interpretation from inverted IR receive input */
#if defined (IR_INVERT)
    if (InvertedInputCompensate(SymbolBuf_p,
                            ProtocolParams_p->UserDefined.StartSymbols[0].MarkPeriod,
                            SymbolsAvailable) == FALSE)
    {
        ProtocolError = TRUE;
    }
#endif

    /* Process as many user packets as are required */
    for(i = 0; i < UserBufSize && SymbolsLeft > 0 && !ProtocolError; i++)
    {
        /* Reset symbols used count */
        SymbolsUsed = 0;

        /* Check the symbols match the allowed start symbols */
        if(SymbolsOkay(SymbolBuf_p,
                        ProtocolParams_p->UserDefined.StartSymbols,
                        ProtocolParams_p->UserDefined.NumberStartSymbols) == FALSE)
        {
            ProtocolError = TRUE;
            continue;
        }

        /* Remove any (assumed) start-bits */
        SymbolsLeft -= ProtocolParams_p->UserDefined.NumberStartSymbols;
        SymbolsUsed += ProtocolParams_p->UserDefined.NumberStartSymbols;

        /* Process data bits */
        Data = 0;                       /* Zero data-byte */

        for(j = ProtocolParams_p->UserDefined.NumberStartSymbols;
             (j < (ProtocolParams_p->UserDefined.NumberPayloadBits +
                   ProtocolParams_p->UserDefined.NumberStartSymbols)) &&
              (SymbolsLeft > 0);
             j++)
        {
            Data <<= 1;

            /* Calculate drift for mark and symbol periods */
            MarkDrift = abs(SymbolBuf_p[j].MarkPeriod -
                            ProtocolParams_p->UserDefined.HighDataSymbol.MarkPeriod);
            SymbolDrift = abs(SymbolBuf_p[j].SymbolPeriod -
                              ProtocolParams_p->UserDefined.HighDataSymbol.SymbolPeriod);

            /* Check for a high data symbol */
            if((MarkDrift <= AllowedMarkDriftH) &&
                 ((SymbolDrift <= AllowedSymbolDriftH) ||
                   (j == ProtocolParams_p->UserDefined.NumberPayloadBits &&
                    (ProtocolParams_p->UserDefined.NumberStopSymbols == 0))
                 )
               )
            {
                /* This is a high data symbol */
                Data |= 1;
            }
            else
            {
                /* Calculate drift for mark and symbol periods */
                MarkDrift = abs(SymbolBuf_p[j].MarkPeriod -
                                ProtocolParams_p->UserDefined.LowDataSymbol.MarkPeriod);
                SymbolDrift = abs(SymbolBuf_p[j].SymbolPeriod -
                                  ProtocolParams_p->UserDefined.LowDataSymbol.SymbolPeriod);

                /* Check for low data symbol */
                if (!((MarkDrift <= AllowedMarkDriftL) &&
                        ((SymbolDrift <= AllowedSymbolDriftL) ||
                         (j == ProtocolParams_p->UserDefined.NumberPayloadBits &&
                         (ProtocolParams_p->UserDefined.NumberStopSymbols == 0))
                        ))
                   )
                {
                    /* Invalid symbol -- raise protocol error */
                    ProtocolError = TRUE;
                    break;
                }
                else
                {
                }
            }

            /* Next symbol */
            SymbolsLeft--;
            SymbolsUsed++;
        }

        if (!ProtocolError )
        {
            /* Make sure we've got enough symbols left to verify */
            if (SymbolsLeft >= ProtocolParams_p->UserDefined.NumberStopSymbols)
            {
                /* Verify the stop symbols */
                if (SymbolsOkay(&SymbolBuf_p[j],
                                ProtocolParams_p->UserDefined.StopSymbols,
                                ProtocolParams_p->UserDefined.NumberStopSymbols) == FALSE)
                {
                    ProtocolError = TRUE;
                }
                else
                {
                    SymbolsLeft -= ProtocolParams_p->UserDefined.NumberStopSymbols;
                    SymbolsUsed += ProtocolParams_p->UserDefined.NumberStopSymbols;
                    SymbolBuf_p += ProtocolParams_p->UserDefined.NumberStopSymbols;
                }

                /* Set data word */
                *UserBuf_p = Data;
#if defined(STBLAST_NEC_REPEAT_MODE_FEATURE)
                PreviousCmd = Data;
                RepeateKeyCount = STBLAST_REPEAT_KEY_IGNORE_COUNT;
#endif
                UserCount++;
                *SymbolsUsed_p += SymbolsUsed;

                UserBuf_p++;
            }
            else
            {
                /* Didn't get the stop bits, where'd they go? */
                ProtocolError = TRUE;
            }
        }
    }

    /* Set count information for user */
    *NumDecoded_p = UserCount;

    return ST_NO_ERROR;

}

/*****************************************************************************
SymbolsOkay
Description:
    Verify that two buffers of symbols are identical (within certain drift
    limits)

Parameters:
    Buf         the symbols to compare
    Ref         the 'reference' symbols to compare them against
    Count       how many symbols to compare

Return Value:
    TRUE        if symbols are basically the same
    FALSE       otherwise

See Also:
    BLAST_SpaceDecode
*****************************************************************************/

static BOOL SymbolsOkay(const STBLAST_Symbol_t *Buf,
                        const STBLAST_Symbol_t *Ref,
                        const U32 Count)
{
    BOOL Okay = TRUE;
    U32 AllowedMarkDrift, AllowedSymbolDrift;
    U32 MarkDrift, SymbolDrift;
    U8 j;

    for (j = 0; j < Count && (Okay == TRUE); j++)
    {
        AllowedMarkDrift = Ref[j].MarkPeriod / DRIFT_THRESHOLD;
        AllowedSymbolDrift = Ref[j].SymbolPeriod / DRIFT_THRESHOLD;

        MarkDrift = abs(Buf[j].MarkPeriod - Ref[j].MarkPeriod);
        SymbolDrift = abs(Buf[j].SymbolPeriod - Ref[j].SymbolPeriod);

        if ((MarkDrift > AllowedMarkDrift) ||
            (SymbolDrift > AllowedSymbolDrift)
           )
        {
            Okay = FALSE;
        }
    }

    return Okay;
}


/* EOF */
